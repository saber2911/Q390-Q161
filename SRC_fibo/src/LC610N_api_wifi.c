
#include "LC610N_api_dcep.h"

uint8 g_ui8CreateSocketID = 0x1F;//bit0-bit5代表未使用的socket id,eg:socketid=1,create之后，就变成了0b11110;
uint8 g_ui8SSLSocketCreateFlag = 0; //0:未创建ssl；1：已创建ssl
uint8 g_ui8SSLCreateSocketID = 0;
uint8 g_ui8IPDBuffInitFlag = 0;     //0：设备上电初始化；1：手动初始化；
uint8 g_ui8NetFlag = 0;             //1:微信配网； 2：web配网
uint32 g_ui32ApiWiFiSendMutex;
struct WIFI_STRUCT g_stWifiState;
extern uint8_t  g_ui8Lrc;
extern ST_AP_INFO_ASY g_stApAsyInfo;
extern int wifi_setWkupTrue();

int g_wifiAutoSleepMode = 1; //0:关闭wifi自动休眠 1:开启WiFi自动休眠

void wifiResourceRelease(void)
{
	if((g_ui8CreateSocketID & 0x01) == 0)
	{
       memset(g_stWifiUart.IPD_zero_uart_buff, 0x00, IPDUARTBUFF_LEN);
	   free(g_stWifiUart.IPD_zero_uart_buff);
	   g_stWifiUart.IPD_zero_uart_buff = NULL;
	   sysLOG(APIWIFI_LOG_LEVEL_4, "g_ui8CreateSocketID = %x\r\n",g_ui8CreateSocketID);
	   g_ui8CreateSocketID |= (1<<0x00);
	}
	if((g_ui8CreateSocketID & 0x02) == 0)
	{
		memset(g_stWifiUart.IPD_one_uart_buff, 0x00, IPDUARTBUFF_LEN);
		free(g_stWifiUart.IPD_one_uart_buff);
		g_stWifiUart.IPD_one_uart_buff = NULL;
		sysLOG(APIWIFI_LOG_LEVEL_4, "g_ui8CreateSocketID = %x\r\n",g_ui8CreateSocketID);
		g_ui8CreateSocketID |= (1<<0x01);
	}
	if((g_ui8CreateSocketID & 0x04) == 0)
	{
		memset(g_stWifiUart.IPD_two_uart_buff, 0x00, IPDUARTBUFF_LEN);
		free(g_stWifiUart.IPD_two_uart_buff);
		g_stWifiUart.IPD_two_uart_buff = NULL;
		sysLOG(APIWIFI_LOG_LEVEL_4, "g_ui8CreateSocketID = %x\r\n",g_ui8CreateSocketID);
		g_ui8CreateSocketID |= (1<<0x02);
	}
	if((g_ui8CreateSocketID & 0x08) == 0)
	{
		memset(g_stWifiUart.IPD_three_uart_buff, 0x00, IPDUARTBUFF_LEN);
		free(g_stWifiUart.IPD_three_uart_buff);
		g_stWifiUart.IPD_three_uart_buff = NULL;
		sysLOG(APIWIFI_LOG_LEVEL_4, "g_ui8CreateSocketID = %x\r\n",g_ui8CreateSocketID);
		g_ui8CreateSocketID |= (1<<0x03);
	}
	if((g_ui8CreateSocketID & 0x10) == 0)
	{
		memset(g_stWifiUart.IPD_four_uart_buff, 0x00, IPDUARTBUFF_LEN);
		free(g_stWifiUart.IPD_four_uart_buff);
		g_stWifiUart.IPD_four_uart_buff = NULL;
		sysLOG(APIWIFI_LOG_LEVEL_4, "g_ui8CreateSocketID = %x\r\n",g_ui8CreateSocketID);
		g_ui8CreateSocketID |= (1<<0x04);
	}
}

void wifiRevBuffInit(void)
{
	g_stWifiUart.CMD_read_P=g_stWifiUart.CMD_write_P=0;
	memset(g_stWifiUart.CMD_uart_buff,0,sizeof(g_stWifiUart.CMD_uart_buff));
	g_stWifiUart.read_P=g_stWifiUart.write_P=0;
	g_stWifiUart.uart_buff_count=0;
	memset(g_stWifiUart.uart_buff,0,sizeof(g_stWifiUart.uart_buff));
	//g_stWifiUart.IPD_read_P=g_stWifiUart.IPD_write_P=0;
	//g_stWifiUart.IPD_uart_buff_len=0;
	//memset(g_stWifiUart.IPD_uart_buff,0,sizeof(g_stWifiUart.IPD_uart_buff));
	g_stWifiUart.IPD_zero_read_P=g_stWifiUart.IPD_zero_write_P=0; 
	g_stWifiUart.IPD_zero_uart_buff_len=0;
	//memset(g_stWifiUart.IPD_zero_uart_buff, 0x00, sizeof(g_stWifiUart.IPD_zero_uart_buff));
	g_stWifiUart.IPD_one_read_P=g_stWifiUart.IPD_one_write_P=0; 
	g_stWifiUart.IPD_one_uart_buff_len=0;
	//memset(g_stWifiUart.IPD_one_uart_buff, 0x00, sizeof(g_stWifiUart.IPD_one_uart_buff));
	g_stWifiUart.IPD_two_read_P=g_stWifiUart.IPD_two_write_P=0; 
	g_stWifiUart.IPD_two_uart_buff_len=0;
	//memset(g_stWifiUart.IPD_two_uart_buff, 0x00, sizeof(g_stWifiUart.IPD_two_uart_buff));
	g_stWifiUart.IPD_three_read_P=g_stWifiUart.IPD_three_write_P=0; 
	g_stWifiUart.IPD_three_uart_buff_len=0;
	//memset(g_stWifiUart.IPD_three_uart_buff, 0x00, sizeof(g_stWifiUart.IPD_three_uart_buff));
	g_stWifiUart.IPD_four_read_P=g_stWifiUart.IPD_four_write_P=0; 
	g_stWifiUart.IPD_four_uart_buff_len=0;
	//memset(g_stWifiUart.IPD_four_uart_buff, 0x00, sizeof(g_stWifiUart.IPD_four_uart_buff));
	g_stWifiUart.invailddatalen=0;//
	if(g_ui8IPDBuffInitFlag==1)
	{
		if((g_ui8CreateSocketID & 0x1F) != 0x1F)
		{
			wifiResourceRelease();
		}
	}
	else{
		sysLOG(APIWIFI_LOG_LEVEL_4, "g_ui8CreateSocketID = %x\r\n",g_ui8CreateSocketID);
		 g_stWifiUart.IPD_zero_uart_buff = NULL;
		 g_stWifiUart.IPD_one_uart_buff = NULL;
		 g_stWifiUart.IPD_two_uart_buff = NULL;
		 g_stWifiUart.IPD_three_uart_buff = NULL;
		 g_stWifiUart.IPD_four_uart_buff = NULL;
		 g_ui8IPDBuffInitFlag = 1;
		 sysLOG(APIWIFI_LOG_LEVEL_4, "g_ui8CreateSocketID = %x\r\n",g_ui8CreateSocketID);
	}
} 

int wifiInit_lib(void)
{
	int i32Ret = 0;
	char acWifiVerBuf[20];
	sysLOG(APIWIFI_LOG_LEVEL_4, "\r\n");
	
	g_stWifiState.cOpenState = NO_OPEN;

	g_ui8WifiConnectClosed=1;//上电伊始8266会输出一些东西，屏蔽掉

	Wifi_init(115200);/*初始化了串口、唤醒IO*/

	DR_Wifi_Pwr_EN(FALSE);	//对WIFI重新上电
	sysDelayMs(20);
	
	DR_Wifi_Pwr_EN(TRUE);

	memset((uint8_t*)&g_stApAsyInfo,0,sizeof(ST_AP_INFO_ASY));
	g_stApAsyInfo.apErrFlag = WIFI_NOT_APCONNECT_ERR;

	sysDelayMs(800);
	g_ui8WifiConnectClosed=0;
	DR_IPDmutex_lock(g_ui32IPDMutexHandle);
	g_stWifiUart.IPD_holdflag=0;
	
	g_ui8CldsdClosemodeFlag=0;
	
	wifiRevBuffInit();
	DR_IPDmutex_unlock(g_ui32IPDMutexHandle);
	g_stWifiState.cOpenState = OPEN_SUCC;
	memset(acWifiVerBuf, 0x00, sizeof(acWifiVerBuf));
	i32Ret = wifiGetUserVersion_lib(acWifiVerBuf,sizeof(acWifiVerBuf));
	if(i32Ret > 0)
    {
	   if((acWifiVerBuf[1] - '0')>=2){
		   g_cWifiVersionFlag = RTOSSDKVERSION;
	   }
       else{
		   g_cWifiVersionFlag = NOSDKVERSION;
	   }
    }

	i32Ret = ESP_Cmd_Init();
	DR_BTPwrCtl(FALSE);
	if(i32Ret < 0)
	{
		sysLOG(APIWIFI_LOG_LEVEL_2, "<ERR> ESP_Cmd_Init i32Ret:%d\r\n", i32Ret);
		DR_Wifi_Pwr_EN(FALSE);
		DR_Wifi_Pwr_init();

		g_stWifiState.cOpenState = NO_OPEN;
		i32Ret = hal_sysSetSleepMode(1);
		sysLOG(APIWIFI_LOG_LEVEL_4, "hal_sysSetSleepMode(1) i32Ret=%d\r\n", i32Ret);
		return WIFI_OPEN_FAIL;
	}
	
	//hal_wifiAtRESTORE();

	//hal_espSetWifiMode(1);
	
    hal_espSetCIPMUX(1);
//	memset(ab,0,sizeof(ab));
//	memset(cd,0,sizeof(cd));

	sysLOG(APIWIFI_LOG_LEVEL_1, "<SUCC> wifi open succ, wifistate is %d\r\n", g_stWifiState.cOpenState);
	//hal_espSleepNotice();//WiFi端默认4G是休眠状态，不用发送指令
	i32Ret = hal_sysSetSleepMode(1);//ccb//再次确认退休眠，是因为上电伊始pdp激活里面会在g_stWifiState.cOpenState == NO_OPEN时进休眠的。
	sysLOG(APIWIFI_LOG_LEVEL_4, "hal_sysSetSleepMode(1) i32Ret=%d\r\n", i32Ret);

	return 0;
}


/**
 * [Function]       wifiOpen_lib
 * [Description]    开启WIFI模块
 * [param]          无
 * [return]         0      成功
 					<0     见返回值列表
 * [modify]              
 */
int wifiOpen_lib(void)
{
	int i32Ret = 0;
	sysLOG(APIWIFI_LOG_LEVEL_4, "\r\n");
	i32Ret = hal_sysSetSleepMode(1);//ccb//调用open之后先退休眠，需要和WiFi交互
	sysLOG(APIWIFI_LOG_LEVEL_1, "hal_sysSetSleepMode(1) i32Ret=%d\r\n", i32Ret);	
	if(OPEN_SUCC == g_stWifiState.cOpenState)
	{
		return 0;
	}
	//fibo_mutex_delete(g_ui32ApiWiFiSendMutex);
	//g_ui32ApiWiFiSendMutex = fibo_mutex_create();
	fibo_mutex_unlock(g_ui32ApiWiFiSendMutex);
	DR_BTPwrCtl(TRUE);
	//sysDelayMs(500);
	return wifiInit_lib();
}

/**
 * [Function]       wifiClose_lib
 * [Description]    关闭WIFI模块
 * [param]          无
 * [return]         0      成功
 * [modify]              
 */
int wifiClose_lib(void)
{
	int i32Ret = 0;
	sysLOG(APIWIFI_LOG_LEVEL_4, "\r\n");
	i32Ret = hal_sysSetSleepMode(1);
	sysLOG(APIWIFI_LOG_LEVEL_4, "hal_sysSetSleepMode(1) i32Ret=%d\r\n", i32Ret);
	if(OPEN_SUCC == g_stWifiState.cOpenState)
	{
		DR_Wifi_Pwr_EN(FALSE);
	}
	//fibo_mutex_delete(g_ui32ApiWiFiSendMutex);
	fibo_mutex_unlock(g_ui32ApiWiFiSendMutex);
	g_stWifiState.cOpenState = NO_OPEN;
	sysLOG(APIWIFI_LOG_LEVEL_1, "wifi close, wifistate is %d\r\n", g_stWifiState.cOpenState);
	if((g_ui8CreateSocketID & 0x1F) != 0x1F)
	{
		wifiResourceRelease();
	}
	DR_Wifi_Pwr_init();
	
	return 0;
}

/*
* Description: WIFI模块重启
* Input:       N
* Output:N
* Return:      N
*/
int wifiReset_lib(void)
{
	int i32Ret = 0;
	
	g_stWifiState.cOpenState = NO_OPEN;
	sysLOG(APIWIFI_LOG_LEVEL_1, "wifi open rst, wifistate is %d\r\n", g_stWifiState.cOpenState);
	i32Ret = hal_wifiReset();
	if(i32Ret < 0)
	{
		return i32Ret;
	}
	
	return wifiInit_lib();
}

/*
* Description: 扫描周围热点
* Input:       iApCount             期望扫描到的热点数，
* Output:	   pstApList            扫描到的热点列表,结果已经按照信号强度RSSI值由大到小排序
* Return:      >= 0           实际扫描到的热点数目
			   < 0            见返回值列表
*/
#define SCAN_BUF_SIZE (8192)
int wifiScan_lib(ST_AP_LIST *pstApList, int iApCount)
{
	unsigned char *aucBuff = (uint8_t *)fibo_malloc(SCAN_BUF_SIZE);//[2048];
	int i32Ret = -1;
	int i = 0;
	int j = 0;
	int i32ApCnt = 0;
	int i32SsidLen = 0;
	//char *pcStr = NULL;
	char *pcStrH = NULL;
	char *pcStrT = NULL;
	char *pcStrOK = NULL;
	char *pcStrPra = NULL;
	int i32Lenth;
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		sysLOG(APIWIFI_LOG_LEVEL_2, "<ERR> WIFI_NOT_OPEN_ERR\r\n");
		fibo_free(aucBuff);
		return WIFI_NOT_OPEN_ERR;
	}

	if((iApCount <= 0) || (pstApList == NULL))
	{
		fibo_free(aucBuff);
		return WIFI_PRAM_ERR;
	}

	memset(aucBuff, 0x00, SCAN_BUF_SIZE);
	i32Ret = hal_espAPScan((char *)aucBuff, SCAN_BUF_SIZE);
	sysLOG(APIWIFI_LOG_LEVEL_4, "espAPScan i32Ret is%d\r\n", i32Ret);
	if(i32Ret < 0)
	{
		memset(aucBuff, 0x00, SCAN_BUF_SIZE);
		i32Ret = hal_espAPScan((char *)aucBuff, SCAN_BUF_SIZE);
		sysLOG(APIWIFI_LOG_LEVEL_2, "espAPScan retry i32Ret is%d\r\n", i32Ret);
		if(i32Ret < 0)
		{
			fibo_free(aucBuff);
			return WIFI_SCAN_ERR;
		}
	}
	
	pcStrOK = strstr((char *)aucBuff, "\r\nOK\r\n");
	if(pcStrOK == NULL)
	{
		i32Lenth = strlen(aucBuff);
		sysLOG(APIWIFI_LOG_LEVEL_4, "pcStrOK is NULL,NO OK found strlen=%d\r\n",i32Lenth);
	}
	else
	{
		sysLOG(APIWIFI_LOG_LEVEL_4, "pcStrOK is %p\r\n",pcStrOK);

	}
	pcStrPra = (char *)(&aucBuff[0]);
    while (1)
    {
    	pcStrH = strstr(&pcStrPra[0], "+CWLAP:");
		pcStrT = strstr(&pcStrPra[0], ")");
 		if((pcStrH != NULL) && (pcStrT != NULL) && (pcStrH < pcStrOK))
		{
/*获取<ecn>*/		
			pstApList[i32ApCnt].iEcn = (pcStrH[8] - '0');				/*加密方式*/
			pcStrH += 10;

			if((pcStrH[0] == '\"')&&(pcStrH[0] == pcStrH[1]))
			{
				pcStrPra = strstr(&pcStrH[0], ")");
				pcStrPra += 3;			
			}
			else
			{
				pcStrH++;
/*获取<ssid>*/
				pcStrPra = strstr(&pcStrH[0], "\"");

				memset(pstApList[i32ApCnt].cSsid, 0x00, 64);

				i32SsidLen = (pcStrPra - pcStrH);
				if(i32SsidLen > 64)
				{
					memcpy(pstApList[i32ApCnt].cSsid, &pcStrH[0], 64);
				}
				else
				{
					memcpy(pstApList[i32ApCnt].cSsid, &pcStrH[0], i32SsidLen);
				}
				
/**<ssid>查重**/
				i = 0;
				while((i < i32ApCnt) && (i >= 0))
				{ 
	                if((strlen(pstApList[i].cSsid) == i32SsidLen) && (0 == memcmp(pstApList[i].cSsid, pstApList[i32ApCnt].cSsid, i32SsidLen)))
	                {
	                    i = (-1);						/*存在重复的SSID*/
	                }
	                else
	                {
						i++;
	                }
				}				

				if(i >= 0)
				{
					pcStrH = (pcStrPra+3);
/*获取<rssi>*/
					pstApList[i32ApCnt].iRssi = 0;
					pcStrPra = strstr(&pcStrH[0], ",");
					for (j = 0; j < (pcStrPra - pcStrH); j++)
					{
						pstApList[i32ApCnt].iRssi *= 10;
						pstApList[i32ApCnt].iRssi += (pcStrH[j] - '0');
					}
					pstApList[i32ApCnt].iRssi *= (-1);

					pcStrH = (pcStrPra+2);
				
/*获取<MAC>*/
					pcStrPra = strstr(&pcStrH[0], "\"");
					memset(pstApList[i32ApCnt].cBssid, 0x00, 20);
					memcpy(pstApList[i32ApCnt].cBssid, &pcStrH[0], (pcStrPra - pcStrH));

					pcStrH = (pcStrPra+2);
				
/*获取<channel>*/				
					pstApList[i32ApCnt].iChannel = 0;
					pcStrPra = strstr(&pcStrH[0], ",");
					for (j = 0; j < (pcStrPra - pcStrH); j++)
					{
						pstApList[i32ApCnt].iChannel *= 10;
						pstApList[i32ApCnt].iChannel += (pcStrH[j] - '0');
					}

					pcStrH = (pcStrPra+1);

/*获取<freq offset>*/
					pstApList[i32ApCnt].iFreqOffset = 0;
					pcStrPra = strstr(&pcStrH[0], ")");
					if('-' == pcStrH[0])
					{
						pcStrH++;
						for (j = 0; j < (pcStrPra - pcStrH); j++)
						{
							pstApList[i32ApCnt].iFreqOffset *= 10;
							pstApList[i32ApCnt].iFreqOffset += (pcStrH[j] - '0');
						}
						pstApList[i32ApCnt].iFreqOffset *= (-1);
					}
					else
					{
						for (j = 0; j < (pcStrPra - pcStrH); j++)
						{
							pstApList[i32ApCnt].iFreqOffset *= 10;
							pstApList[i32ApCnt].iFreqOffset += (pcStrH[j] - '0');
						}					
					}

					i32ApCnt++;
					if(i32ApCnt >= iApCount)
					{
						fibo_free(aucBuff);
						return i32ApCnt;
					}

					pcStrPra += 3;
				}
				else
				{
					pcStrPra = strstr(&pcStrH[0], ")");
					pcStrPra += 3;
				}
			}
		}
		else
		{
			fibo_free(aucBuff);
			return i32ApCnt;
		}
    }	
	fibo_free(aucBuff);
	return 0;
}


 /**
 * [Function]       api_wifiConfigParam
 * [Description]    配置热点的参数: IP、子网掩码、网关、DHCP使能,仅能在未连接AP时调用
 * [param]          pstWifiParam	
 * [return]         0      成功
 * [modify]              
 */
 int wifiConfigConnectParam_lib(ST_WIFI_PARAM *pstWifiParam)
 {
 	int i32Ret = -1;

	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}
	
	i32Ret = hal_espWifiStatus();								/*未连接AP时，允许调用*/
	if(i32Ret != 5)
	{
		return WIFI_AP_CONNECTED;
	}

	if(pstWifiParam == NULL)
	{
		return WIFI_PRAM_ERR;
	}
	
/*仅允许在未连接热点的情况下调用*/
	i32Ret = hal_espStationSetDHCP(pstWifiParam->iDHCPEnable);
	if(i32Ret < 0)
	{
		return WIFI_ENABLE_DHCP_ERR;
	}
	
	if(pstWifiParam->iDHCPEnable == 1)						/*开启DHCP, 无须设置IP参数了*/
	{
		i32Ret = hal_espConfigDNSEnable(0);
		if(i32Ret < 0)
		{
			return WIFI_DNS_DSIABLE_ERR;
		}
		
		return 0;
	}

/*设置静态IP、网关、子网掩码*/	
	i32Ret = hal_espStationSetIP(pstWifiParam->cIp, pstWifiParam->cGateWay, pstWifiParam->cNetMask);
	if(i32Ret < 0)
	{
		return WIFI_SET_IP_ERR;
	}
	
 	return 0;
 }

/**
 * [Function]       api_wifiConfigParam
 * [Description]    获取连接参数
 * [param]          pstWifiParam	
 * [return]         0      成功
 * [modify]              
 */
int wifiGetConnectParam_lib(ST_WIFI_PARAM *pstWifiParam)
{
	int i32Ret = -1;

	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}
	
	i32Ret = hal_espStationGetDHCP();
	if(i32Ret < 0)
	{
		return WIFI_GETDHCP_ERR;
	}

	memset(pstWifiParam, 0x00, sizeof(ST_WIFI_PARAM));
	
	if(1 == i32Ret)												/*DHCP开启情况下，连接AP后才能获取IP*/
	{
		pstWifiParam->iDHCPEnable = 1;

		i32Ret = hal_espWifiStatus();
		if(i32Ret == 5)
		{
			return WIFI_NoAP_NOTIP;
		}
	
		i32Ret = hal_espGetIPAndMac(pstWifiParam->cIp, NULL);
		if(i32Ret < 0)
		{
			return WIFI_GETIP_ERR;
		}
		i32Ret = hal_espStationGetIP(pstWifiParam->cIp, pstWifiParam->cGateWay, pstWifiParam->cNetMask);
		if(i32Ret < 0)
		{
			return WIFI_GETIP_ERR;
		}
#if 0
		memcpy(pstWifiParam->cGateWay, "0.0.0.0", strlen("0.0.0.0"));
		memcpy(pstWifiParam->cNetMask, "0.0.0.0", strlen("0.0.0.0"));
		memcpy(pstWifiParam->cDnsServer0, "0.0.0.0", strlen("0.0.0.0"));
		memcpy(pstWifiParam->cDnsServer1, "0.0.0.0", strlen("0.0.0.0"));
#endif		
	}
	else
	{
		pstWifiParam->iDHCPEnable = 0;
		
		i32Ret = hal_espStationGetIP(pstWifiParam->cIp, pstWifiParam->cGateWay, pstWifiParam->cNetMask);
		if(i32Ret < 0)
		{
			return WIFI_GETIP_ERR;
		}
#if 0
		i32Ret = hal_espGetDns(pstWifiParam->cDnsServer0, pstWifiParam->cDnsServer1);
		if(i32Ret < 0)
		{
			return WIFI_GETDNS_ERR;
		}
#endif		
	}
	
	return 0;
}

/**
* [Function]	   wifiConfigDNS_lib
* [Description]    设置DNS地址
* [param]		    pcDnsServer0  第一个DNS服务器
					pcDnsServer1  第二个DNS服务器
* [return]		   0	  成功
* [modify]				
*/
int wifiConfigDNS_lib(char *pcDnsServer0, char *pcDnsServer1)
{
	int i32Ret = -1;
	
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}

	i32Ret = hal_espConfigDNS(pcDnsServer0, pcDnsServer1);
	if(i32Ret < 0)
	{
		return WIFI_DNS_CONFIG_ERR;
	}
	
	return 0;
}

/**
* [Function]	   wifiGetDNS_lib
* [Description]    获取DNS信息
* [param]		    pcDnsServer0  第一个DNS服务器
					pcDnsServer1  第二个DNS服务器
* [return]		   0	  成功
* [modify]				
*/
int wifiGetDNS_lib(char *pcDnsServer0, char *pcDnsServer1)
{
	int i32Ret = 0;

	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}

	if((pcDnsServer0 == NULL) || (pcDnsServer1 == NULL))
	{
		return WIFI_PRAM_ERR;
	}
	
	i32Ret = hal_espGetDns(pcDnsServer0, pcDnsServer1);
	if(i32Ret < 0)
	{
		return WIFI_GETDNS_ERR;
	}

	return 0;
}

/*
* Description: 设置本地MAC地址
* Input:       MAC地址，字符串  如："10:24:f0:34:e5:12"  
* Output:	N
* Return:   0     成功	<0    见返回值列表
*/
int wifiSetMac_lib(unsigned char *pcMacBuf)
{
	int i32Ret = 0;

	if((NULL == pcMacBuf) || (strlen(pcMacBuf)<17))
	{
		return WIFI_PRAM_ERR;
	}
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}
	i32Ret = hal_espStationSetMac((unsigned char*)pcMacBuf);
	if(i32Ret < 0)
	{
		return WIFI_SETMAC_ERR;
	}

	return 0;
}

/*
* Description: 获取本地MAC地址
* Input:       
* Output:	N
* Return:   0     成功
			<0    见返回值列表
*/
int wifiGetMac_lib(char *pcMacBuf)
{
	int i32Ret = 0;

	//char defaultMAC[]={"ff:ff:ff:ff:ff:ff"};
	//char defaultMAC1[]={"88:88:88:88:88:88"};
	if(NULL == pcMacBuf)
	{
		return WIFI_PRAM_ERR;
	}

	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}

#if 0	
	i32Ret = hal_espGetIPAndMac(NULL, pcMacBuf);
	if(i32Ret < 0)
	{
		return WIFI_GETMAC_ERR;
	}
#else

	i32Ret = hal_espStationGetMac((unsigned char*)pcMacBuf);
	if(i32Ret < 0)
	{
		return WIFI_GETMAC_ERR;
	}
	/*if((strcmp(defaultMAC,pcMacBuf) == 0) || (strcmp(defaultMAC1,pcMacBuf) == 0))
	{
		i32Ret = hal_espStationGetMacCur((unsigned char*)pcMacBuf);
		if(i32Ret < 0)
		{
			return WIFI_GETMAC_ERR;
		}	

	}*/
#endif
	return 0;
}

/*
* Description: WIFI热点连接
* Input:       N
* Output:N
* Return:      N
*/
int wifiAPConnect_lib(unsigned char *pucSsid, unsigned char *pucPassword)
{
	int i32Ret = 0;
	ST_AP_INFO *pstAp = &g_stApAsyInfo.stApinfo;
	ST_AP_MAC stApMac;
	
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}

	if((pucSsid == NULL) || (strlen(pucSsid) == 0))
	{
		return WIFI_PRAM_ERR;
	}
	sysLOG(APIWIFI_LOG_LEVEL_4, "i32Ret = %d\r\n",i32Ret);
/*1.检查是否已经连接AP,如果已连接相同的AP,直接返回成功；
    否则，先断开AP,再去连接*/
	memset(pstAp, 0x00, sizeof(ST_AP_INFO));
	g_stApAsyInfo.apErrFlag = hal_espCheckAp(pstAp);
	sysLOG(APIWIFI_LOG_LEVEL_4, "i32Ret = %d\r\n",g_stApAsyInfo.apErrFlag);
	i32Ret = g_stApAsyInfo.apErrFlag;
	if(i32Ret >= 0)
	{
		if((0 == memcmp(pstAp->cSsid, pucSsid, strlen(pstAp->cSsid))) && (strlen(pstAp->cSsid) == strlen(pucSsid)))
		{
			return 0;
		}
		else
		{
			hal_espAPClose();
		}
	}
	sysLOG(APIWIFI_LOG_LEVEL_4, "i32Ret = %d\r\n",i32Ret);
	memset(&stApMac, 0x00, sizeof(stApMac));
/*2.扫描要连接的AP, 获取MAC*/		
	i32Ret = hal_espScanAp(pucSsid, &stApMac);
	if(i32Ret < 0)
	{
		return WIFI_AP_CONNECT_NOTFINDAP;
	}
	sysLOG(APIWIFI_LOG_LEVEL_4, "i32Ret = %d\r\n",i32Ret);
/*3.连接AP*/
	i32Ret = hal_espAPConnect(pucSsid, pucPassword, &stApMac);
	if(i32Ret < 0)
	{
		switch(i32Ret)
		{
			case (-1):
				return WIFI_AP_CONNECT_TIMEOUT;/*AP连接超时*/
			case (-2):
				return WIFI_AP_CONNECT_PWERR;/*密码错误*/
			case (-3):
				return WIFI_AP_CONNECT_NOTFINDAP;/*找不到目标AP*/
		}
		return WIFI_APCONNECT_FAIL;
	}		
	//已经连上的 更新一下连接状态
	//sysDelayMs(10);
	sysLOG(APIWIFI_LOG_LEVEL_1, " i32Ret = %d\r\n",i32Ret);
	memset(pstAp, 0x00, sizeof(ST_AP_INFO));
	g_stApAsyInfo.apErrFlag = hal_espCheckAp(pstAp);
	sysLOG(APIWIFI_LOG_LEVEL_4, " i32Ret = %d\r\n",i32Ret);
	
    return 0;
}

/**
 * [Function]       wifiAPDisconnect_lib
 * [Description]    断开与AP热点的连接
 * [param]          无
 * [return]         0  		成功
 					<0      失败
 * [modify]              
 */
int wifiAPDisconnect_lib(void)
{
	//int i32Ret = 0;
	
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}
	if((g_ui8CreateSocketID & 0x1F) != 0x1F)
	{
		wifiResourceRelease();
	}
    hal_espAPClose();

    return 0;
}

/*
* Description: 查询已配置的AP参数
* Input:       
* Output:N
* Return:      0:断开成功，-1:断开失败
*/
int wifiAPCheck_lib(unsigned char *pucSsid, unsigned char *pucPassword)
{
	int i32Ret = -1;
	APINFO stApinfotmp;

	memset(stApinfotmp.ssid, 0, sizeof(stApinfotmp.ssid));
	memset(stApinfotmp.pwd, 0, sizeof(stApinfotmp.pwd));
	stApinfotmp.chl = 0;
	stApinfotmp.ecn = 0;
	stApinfotmp.max_conn = 0;
	stApinfotmp.ssid_hidden = 0;
	
	i32Ret = hal_espAPCheck(&stApinfotmp);
	if(i32Ret < 0)
		return i32Ret;

	memcpy(pucSsid, stApinfotmp.ssid, strlen(stApinfotmp.ssid));
	memcpy(pucPassword, stApinfotmp.pwd, strlen(stApinfotmp.pwd));

	return i32Ret;
	
	
}

/*
*@Brief:		创建一个socket
*@Param IN:		NULL
*@Param OUT:	NULL
*@Return:		<0:失败; >=0:成功，该值为创建的socket ID
*/
int DR_WifiSockCreate(void)
{	
	uint8 i = 0;

	for(i=0; i<5; i++)
	{
		if((g_ui8CreateSocketID >> i) & 0x01)
		{
			g_ui8CreateSocketID &= ~(1 << i);

			if(i == 0)
			{
				g_stWifiUart.IPD_zero_uart_buff = malloc(IPDUARTBUFF_LEN);
				if(g_stWifiUart.IPD_zero_uart_buff == NULL)
				{
					return WIFI_IPD_RAM_ERR;
				}
				memset(g_stWifiUart.IPD_zero_uart_buff, 0x00, IPDUARTBUFF_LEN);
				sysLOG(APIWIFI_LOG_LEVEL_4, "g_ui8CreateSocketID = %x\r\n",g_ui8CreateSocketID);
			}
			else if(i == 1)
			{
				g_stWifiUart.IPD_one_uart_buff = malloc(IPDUARTBUFF_LEN);
				if(g_stWifiUart.IPD_one_uart_buff == NULL)
				{
					return WIFI_IPD_RAM_ERR;
				}
				memset(g_stWifiUart.IPD_one_uart_buff, 0x00, IPDUARTBUFF_LEN);
				sysLOG(APIWIFI_LOG_LEVEL_4, "g_ui8CreateSocketID = %x\r\n",g_ui8CreateSocketID);
			}
			else if(i == 2)
			{
				g_stWifiUart.IPD_two_uart_buff = malloc(IPDUARTBUFF_LEN);
				if(g_stWifiUart.IPD_two_uart_buff == NULL)
				{
					return WIFI_IPD_RAM_ERR;
				}
				memset(g_stWifiUart.IPD_two_uart_buff, 0x00, IPDUARTBUFF_LEN);
				sysLOG(APIWIFI_LOG_LEVEL_4, "g_ui8CreateSocketID = %x\r\n",g_ui8CreateSocketID);
			}
			else if(i == 3)
			{
				g_stWifiUart.IPD_three_uart_buff = malloc(IPDUARTBUFF_LEN);
				if(g_stWifiUart.IPD_three_uart_buff == NULL)
				{
					return WIFI_IPD_RAM_ERR;
				}
				memset(g_stWifiUart.IPD_three_uart_buff, 0x00, IPDUARTBUFF_LEN);
				sysLOG(APIWIFI_LOG_LEVEL_4, "g_ui8CreateSocketID = %x\r\n",g_ui8CreateSocketID);
			}
			else if(i == 4)
			{
				g_stWifiUart.IPD_four_uart_buff = malloc(IPDUARTBUFF_LEN);
				if(g_stWifiUart.IPD_four_uart_buff == NULL)
				{
					return WIFI_IPD_RAM_ERR;
				}
				memset(g_stWifiUart.IPD_four_uart_buff, 0x00, IPDUARTBUFF_LEN);
				sysLOG(APIWIFI_LOG_LEVEL_4, "g_ui8CreateSocketID = %x\r\n",g_ui8CreateSocketID);
			}
			return i;
		}
	}

	return -2;
}

/*
*@Brief:		关闭已经打开的socket
*@Param IN:		sockid: socket ID
*@Param OUT:	NULL
*@Return:		0: 成功; <0: 失败
*/
int DR_WifiSockClose(int sockid)
{
	int i32Ret =-1;
	uint8 i = 0;

	if(sockid < 0 || sockid > 4)
	{
		return WIFI_PRAM_ERR;//参数失败
	}
    
	if((sockid == 0) && ((g_ui8CreateSocketID & 0x01) == 0))
	{
       memset(g_stWifiUart.IPD_zero_uart_buff, 0x00, IPDUARTBUFF_LEN);
	   free(g_stWifiUart.IPD_zero_uart_buff);
	   g_stWifiUart.IPD_zero_uart_buff = NULL;
	   g_ui8CreateSocketID |= (1<<sockid);
	   sysLOG(APIWIFI_LOG_LEVEL_4, "g_ui8CreateSocketID = %x\r\n",g_ui8CreateSocketID);
	}
	else if((sockid == 1) && ((g_ui8CreateSocketID & 0x02) == 0))
	{
		memset(g_stWifiUart.IPD_one_uart_buff, 0x00, IPDUARTBUFF_LEN);
		free(g_stWifiUart.IPD_one_uart_buff);
		g_stWifiUart.IPD_one_uart_buff = NULL;
		g_ui8CreateSocketID |= (1<<sockid);
		sysLOG(APIWIFI_LOG_LEVEL_4, "g_ui8CreateSocketID = %x\r\n",g_ui8CreateSocketID);
	}
	else if((sockid == 2) && ((g_ui8CreateSocketID & 0x04) == 0))
	{
		memset(g_stWifiUart.IPD_two_uart_buff, 0x00, IPDUARTBUFF_LEN);
		free(g_stWifiUart.IPD_two_uart_buff);
		g_stWifiUart.IPD_two_uart_buff = NULL;
		g_ui8CreateSocketID |= (1<<sockid);
		sysLOG(APIWIFI_LOG_LEVEL_4, "g_ui8CreateSocketID = %x\r\n",g_ui8CreateSocketID);
	}
	else if((sockid == 3) && ((g_ui8CreateSocketID & 0x08) == 0))
	{
		memset(g_stWifiUart.IPD_three_uart_buff, 0x00, IPDUARTBUFF_LEN);
		free(g_stWifiUart.IPD_three_uart_buff);
		g_stWifiUart.IPD_three_uart_buff = NULL;
		g_ui8CreateSocketID |= (1<<sockid);
		sysLOG(APIWIFI_LOG_LEVEL_4, "g_ui8CreateSocketID = %x\r\n",g_ui8CreateSocketID);
	}
	else if((sockid == 4) && ((g_ui8CreateSocketID & 0x10) == 0))
	{
		memset(g_stWifiUart.IPD_four_uart_buff, 0x00, IPDUARTBUFF_LEN);
		free(g_stWifiUart.IPD_four_uart_buff);
		g_stWifiUart.IPD_four_uart_buff = NULL;
		g_ui8CreateSocketID |= (1<<sockid);
		sysLOG(APIWIFI_LOG_LEVEL_4, "g_ui8CreateSocketID = %x\r\n",g_ui8CreateSocketID);
	}

	return 0;
}


/*
*@Brief:		create一个socket
*@Param IN:		type:0-TCP；1-UDP
*@Param OUT:	NULL
*@Return:		>0:成功，返回值为socketID，<0:失败
*/
int wifiSocketCreate_lib(int type)
{
	int i32Ret = -1;

	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		Wifi_wkup(FALSE);
		return WIFI_NOT_OPEN_ERR;
	}
	if(type != 0)
	{
		return WIFI_PRAM_ERR;
	}
	i32Ret = DR_WifiSockCreate();
	if(i32Ret < 0)
	{
		return WIFI_SOCKETCREATE_ERR;
	}

	return i32Ret;
}


/* brief  	:关闭已经打开的socket
 * param		:无
 * retval	:无
 * author	:
*/
int wifiSocketClose_lib(int sockid)
{
	int i32Ret = 0;
	sysLOG(APIWIFI_LOG_LEVEL_4, "<START>\r\n");

	i32Ret = wifiTCPClose_lib(sockid);
	/*if(i32Ret < 0)
	{
		return i32Ret;
	}*/
	/*if(g_ui8CreateSocketID & (0x01<<sockid))
	{
		return WIFI_SOCKET_CLOSE_PARAA_ERR;
	}*/

	return DR_WifiSockClose(sockid);
}

/*
*@Brief:		create一个SSL socket
*@Param IN:		NULL
*@Param OUT:	NULL
*@Return:		>0:成功，返回值为socketID，<0:失败
*/
int wifiSSLSocketCreate_lib(void)
{
	int i32Ret = -1;
	
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		Wifi_wkup(FALSE);
		return WIFI_NOT_OPEN_ERR;
	}
	
	if(g_ui8SSLSocketCreateFlag == 1)
	{
		return WIFI_SOCKETCREATE_ERR;
	}

	i32Ret = DR_WifiSockCreate();
	if(i32Ret < 0)
	{
		return WIFI_SOCKETCREATE_ERR;
	}
	g_ui8SSLCreateSocketID = i32Ret;
	return i32Ret;
}


/* brief  	:关闭已经打开的SSL socket
 * param		:无
 * retval	:无
 * author	:
*/
int wifiSSLSocketClose_lib(int sockid)
{
	int i32Ret = 0;
	if(g_ui8SSLCreateSocketID != sockid)
	{
		return WIFI_SSLSOCKETCLOSE_ERR;
	}

	if(g_ui8CreateSocketID & (0x01<<sockid))
	{
		return WIFI_SOCKET_CLOSE_PARAA_ERR;
	}
	
	g_ui8SSLSocketCreateFlag = 0;
	//sysLOG(APIWIFI_LOG_LEVEL_2, "[%s] -%s- <%d>:<START>\r\n");
	i32Ret = wifiSSLClose_lib(sockid);
	/*if(i32Ret < 0)
	{
		return 0;
	}*/
	return DR_WifiSockClose(sockid);
}


#if WIFI_ATTYPE

/*
* Description: 服务器连接
* Input:       pcTcpUdp:TCP-建立TCP连接；SSL-建立SSL连接
* Output:N
* Return:      N
*/
int wifiCommConnect_lib(int sockid, char *pcTcpUdp,char *pcServeraddr,char *port,int timeout)
{
	int i32Ret = 0;
	char acCmd[100];
	char acBuf[100];
	Wifi_wkup(TRUE);

    if(timeout <= 0)
    {
    	Wifi_wkup(FALSE);
        return WIFI_PRAM_ERR;
    }

	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		Wifi_wkup(FALSE);
		return WIFI_NOT_OPEN_ERR;
	}

    if((g_ui8CreateSocketID >> sockid) & 0x01)
    {
        return WIFI_SOCKE_NOTCREATE_ERR;
    }

    i32Ret=hal_espTCPConnect(sockid, pcTcpUdp, pcServeraddr, port, timeout);
	if(i32Ret==0)
	{
		/*if((memcmp(pcTcpUdp,"SSL",3)!=0) && (g_cWifiVersionFlag == NOSDKVERSION))
		{
			sysLOG(APIWIFI_LOG_LEVEL_1, "start send AT+CIPCLOSEMODE\r\n");
			memset(acBuf, 0x00, sizeof(acBuf));
			memset(acCmd, 0x00, sizeof(acCmd));
			sprintf(acCmd,"AT+CIPCLOSEMODE=%d,1", sockid);
			ESP_SendAndWaitCmd(acCmd, strlen(acCmd), (char *)acBuf, 100, 5000, 3, "\r\nOK\r\n");
		}*/
	}
	Wifi_wkup(FALSE);
	return i32Ret;
}

#endif


/*
* Description: 服务器断开
* Input:       N
* Output:N
* Return:      N
*/
int wifiCommClose_lib(int sockid)
{
	int i32Ret=-1;
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}

	//if(hal_espWifiStatus() == 3)
	//{
		
		//cldsd_closemode();
		//sysDelayMs(10000);
		
		/*if(dev_wifiRead_CLOSED()==-2)//后台已经主动断开
		{
			return 0;
		}
		sysDelayMs(100);//存在第一次在CMD_buf没找到CLOSED，然后在uart_buf收到了CLOSED，做一个延时在查一次
		if(dev_wifiRead_CLOSED()==-2)//后台已经主动断开
		{
			return 0;
		}*/
		//g_ui8WifiConnectClosed=1;//终端主动通信挂断
		DR_IPDmutex_lock(g_ui32IPDMutexHandle);
		g_stWifiUart.CMD_read_P=g_stWifiUart.CMD_write_P=0;
		memset(g_stWifiUart.CMD_uart_buff,0,sizeof(g_stWifiUart.CMD_uart_buff));
		g_ui8CldsdClosemodeFlag=0;

		//g_stWifiUart.invailddatalen=0;      
		//g_stWifiUart.read_P=g_stWifiUart.write_P=0;
		//g_stWifiUart.uart_buff_count=0;
		//memset(g_stWifiUart.uart_buff,0,sizeof(g_stWifiUart.uart_buff));
		i32Ret=hal_espTCPClose(sockid);
#if 1		
		/*重复清除一边的目的是挂断之后可能还会有缓存的串口数据到来，需要清掉*/
		//g_ui8WifiConnectClosed=1;//终端主动通信挂断
		sysDelayMs(100);
		g_stWifiUart.CMD_read_P=g_stWifiUart.CMD_write_P=0;
		memset(g_stWifiUart.CMD_uart_buff,0,sizeof(g_stWifiUart.CMD_uart_buff));
		g_ui8CldsdClosemodeFlag=0;
		
		//g_stWifiUart.invailddatalen=0;
		//g_stWifiUart.read_P=g_stWifiUart.write_P=0;
		//g_stWifiUart.uart_buff_count=0;
		//memset(g_stWifiUart.uart_buff,0,sizeof(g_stWifiUart.uart_buff));
#endif		
		DR_IPDmutex_unlock(g_ui32IPDMutexHandle);
	//}

	if(i32Ret < 0)
	{
		i32Ret = WIFI_TCPCLOSE_FAIL;
	}
	return i32Ret;
}
//
//
///*
//* Description: SSL连接
//* Input:       N
//* Output:N
//* Return:      N
//*/
//int wifiSSLConnect_lib(char *ssl,char *pcServeraddr,char *port,int timeout)
//{
//	if(NO_OPEN == g_stWifiState.cOpenState)
//	{
//		return WIFI_NOT_OPEN_ERR;
//	}
//    
//    if(timeout <= 0)
//    {
//        return WIFI_PRAM_ERR;
//    }
//	
//    return ESP_SSLConnect(ssl,pcServeraddr,port,timeout);
//}


/*
* Description: 数据发送
* Input:       N
* Output:N
* Return:      N
*/
int wifiCommSendData_lib(int sockid, char *data, int i32Datalen, int timeout, int i32Trytime)
{
	int i32Ret = 0;
	
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}

    if((timeout <= 0) || (i32Trytime <= 0))
    {
        return WIFI_PRAM_ERR;
    }
	g_stWifiUart.CMD_read_P=g_stWifiUart.CMD_write_P=0;
	memset(g_stWifiUart.CMD_uart_buff,0,sizeof(g_stWifiUart.CMD_uart_buff));
	
	if(g_ui8CreateSocketID & (0x01<<sockid))
	{
		return -2;
	}

    i32Ret =  hal_espSendData(sockid, data, i32Datalen, timeout, i32Trytime);
	sysLOG(APIWIFI_LOG_LEVEL_1, "hal_espSendData, i32Ret:%d\r\n", i32Ret);
	return i32Ret;
}

/*
* Description: 等待服务器数据
* Input:       N
* Output:N
* Return:      N
*/
//uint8 wifirecvdatatemp[UARTBUFF_LEN];
int wifiWaitData_lib(int sockid, char *pcBuf,int i32Buflen,int timeout)
{
	int i32Ret = 0;
	
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}

	if((NULL == pcBuf) || (timeout <= 0))
	{
		return -1;
	}


	if(g_ui8CreateSocketID & (0x01<<sockid))
	{
		return -2;
	}
	
	i32Ret = hal_espWaitSeverData(sockid, pcBuf,i32Buflen,timeout);
	if(i32Ret==0)
	{
		return 0;//超时
	}
	sysLOG(APIWIFI_LOG_LEVEL_1, "wifiWaitData_lib i32Ret is %d\r\n", i32Ret);
#if 0
	if(i32Ret < 0)
	{
		switch(i32Ret)
		{
			case (-1): 
				return WIFI_PRAM_ERR;		/*参数错误*/

			case (-2):
				return WIFI_WAITDATA_TIMEOUT;     /*没有接收到服务器数据，等待数据超时*/

			case (-3):
				return WIFI_WAITDATA_INCOMPLETE_1;		/*接收数据错误，没有接收到数据包头*/

			case (-4):
				return WIFI_WAITDATA_INCOMPLETE_2;		/*接收数据错误，接收数据长度超出范围*/

			case (-5):
				return WIFI_WAITDATA_INCOMPLETE_3;		/*接收数据错误，接收数据包不全*/

			case (-6):
				return WIFI_AP_LINK_ERR;

			default:
				return WIFI_ERRCODE_NOTDEFINE;			/*错误码未定义*/
		}
	}
#endif
	return i32Ret;
}


/*
*@Brief:		建立TCP服务连接
*@Param IN:		sockid-socket id; serveraddr-服务端地址; port-服务端端口; timeout-超时时间
*@Param OUT:	NULL
*@Return:		0-成功; <0-失败
*/
int wifiTCPConnect_lib(int sockid,char *serveraddr,char *port,int timeout)
{
	int i32Ret = -1;
	
	if((sockid > 4) || (sockid < 0))
	{
		return WIFI_PRAM_ERR;
	}
	if(serveraddr == NULL)return WIFI_PRAM_ERR;
	if(port == NULL)return WIFI_PRAM_ERR;
	if(timeout <= 0)return WIFI_PRAM_ERR;
	i32Ret = wifiCommConnect_lib(sockid, "TCP", serveraddr, port, timeout);
	return i32Ret;
}

/*
*@Brief:		TCP服务端断开
*@Param IN:		sockid-socket id
*@Param OUT:	NULL
*@Return:		0-成功; <0-失败
*/
int wifiTCPClose_lib(int sockid)
{
	if((sockid > 5) || (sockid < 0))return WIFI_PRAM_ERR;
	return wifiCommClose_lib(sockid);
}
/*
*@Brief:		wifi发送数据
*@Param IN：		sockid-socket id; *data-数据指针; datalen-数据长度; timeout-超时时间
*@Param OUT:	NULL
*@Return:		0-成功; <0-失败
*/
int wifiSend_lib(int sockid,char *data, int datalen, int timeout)
{
	if((sockid > 4) || (sockid < 0))
	{
		return WIFI_PRAM_ERR;
	}
	if(data == NULL)return WIFI_PRAM_ERR;
	if(datalen <= 0)return WIFI_PRAM_ERR;
	if(timeout <= 0)return WIFI_PRAM_ERR;
	return wifiCommSendData_lib(sockid, data, datalen, timeout, 1);
}

/*
*@Brief:		接收数据
*@Param IN:		sockid-socket id; *pucdata-接收数据缓存指针; iLen-期望接收最大长度; uiTimeOut-超时时间单位ms
*@Return：		NULL
*/
int wifiRecv_lib(int sockid, unsigned char *pucdata, unsigned short iLen, unsigned int uiTimeOut)
{
	if((sockid > 4) || (sockid < 0))return WIFI_PRAM_ERR;
	if(pucdata == NULL)return WIFI_PRAM_ERR;
	if(iLen <= 0)return WIFI_PRAM_ERR;
	if(uiTimeOut <= 0)return WIFI_PRAM_ERR;
	return wifiWaitData_lib(sockid, pucdata, iLen, uiTimeOut);
}

/*
*@Brief:		建立SSL服务连接
*@Param IN:		sockid-socket id; *pcServeraddr-服务端地址; *port-服务端端口; timeout-超时时间
*@Param OUT:	NULL
*@Return:		0-成功; <0-失败
*/
int wifiSSLConnect_lib(int sockid,char *serveraddr,char *port,int timeout)
{
	int i32Ret = -1;
	//sysLOG(APIWIFI_LOG_LEVEL_1, "<START>\r\n");
	if((sockid > 4) || (sockid < 0))
	{
		i32Ret = WIFI_PRAM_ERR;
		goto exit;
	}
	if(serveraddr == NULL)
	{
		i32Ret = WIFI_PRAM_ERR;
		goto exit;
	}
	if(port == NULL)
	{
		i32Ret = WIFI_PRAM_ERR;
		goto exit;
	}
	if(timeout <= 0)
	{
		i32Ret = WIFI_PRAM_ERR;
		goto exit;
	}
	i32Ret = wifiCommConnect_lib(sockid, "SSL", serveraddr, port, timeout);

exit:
	sysLOG(APIWIFI_LOG_LEVEL_1, "<END>, i32Ret=%d\r\n", i32Ret);
	return i32Ret;
}

/*
*@Brief:		SSL服务端断开
*@Param IN:		sockid-socket id
*@Param OUT:	NULL
*@Return:		0-成功; <0-失败
*/
int wifiSSLClose_lib(int sockid)
{
	int i32Ret = -1;
	//sysLOG(APIWIFI_LOG_LEVEL_1, "<START>\r\n");
	if((sockid > 5) || (sockid < 0))
	{
		i32Ret = WIFI_PRAM_ERR;
		goto exit;
	}
	i32Ret = wifiCommClose_lib(sockid);
exit:
	sysLOG(APIWIFI_LOG_LEVEL_1, "<END>, i32Ret=%d\r\n", i32Ret);
	return i32Ret;

}
/*
*@Brief:		wifi SSL 发送数据
*@Param IN：		sockid-socket id; *data-数据指针; datalen-数据长度; timeout-超时时间
*@Param OUT:	NULL
*@Return:		0-成功; <0-失败
*/
int wifiSSLSend_lib(int sockid, char *data, int datalen, int timeout)
{
	int i32Ret = -1;
	//sysLOG(APIWIFI_LOG_LEVEL_1, "<START>\r\n");
	if((sockid > 4) || (sockid < 0))
	{
		i32Ret = WIFI_PRAM_ERR;
		goto exit;
	}
	if(data == NULL)
	{
		i32Ret = WIFI_PRAM_ERR;
		goto exit;
	}
	if(datalen <= 0)
	{
		i32Ret = WIFI_PRAM_ERR;
		goto exit;
	}
	if(timeout <= 0)
	{
		i32Ret = WIFI_PRAM_ERR;
		goto exit;
	}
	i32Ret =  wifiCommSendData_lib(sockid, data, datalen, timeout, 1);
exit:
	sysLOG(APIWIFI_LOG_LEVEL_1, "<END>, i32Ret=%d\r\n", i32Ret);
	return i32Ret;
}

/*
*@Brief:		SSL接收数据
*@Param IN:		sockid-socket id; *pucdata-接收数据缓存指针; iLen-期望接收最大长度; uiTimeOut-超时时间单位ms
*@Return：		NULL
*/
int wifiSSLRecv_lib(int sockid, unsigned char *pucdata, unsigned short iLen, unsigned int uiTimeOut)
{
	int i32Ret = -1;
	sysLOG(APIWIFI_LOG_LEVEL_4, "<START>\r\n");
	if((sockid > 4) || (sockid < 0))
	{
		i32Ret = WIFI_PRAM_ERR;
		goto exit;
	}
	if(pucdata == NULL)
	{
		i32Ret = WIFI_PRAM_ERR;
		goto exit;
	}
	if(iLen <= 0)
	{
		i32Ret = WIFI_PRAM_ERR;
		goto exit;
	}
	if(uiTimeOut <= 0)
	{
		i32Ret = WIFI_PRAM_ERR;
		goto exit;
	}
	i32Ret = wifiWaitData_lib(sockid, pucdata, iLen, uiTimeOut);
exit:
	sysLOG(APIWIFI_LOG_LEVEL_1, "<END>, i32Ret=%d\r\n", i32Ret);
	sysDelayMs(50);
	return i32Ret;
}



/*
* Description: 读取WIFI模块软件版本信息
* Input:       buf:接收缓存(应比实际期望的最长数据+10字节) 
*              buflen:缓存长度
*              timeout:超时时间
* Output:N
* Return:      -1:超时，>0:数据包解析得到的长度。
*/
int wifiReadVersion_lib(char *buf,int buflen,int timeout)
{
	char acBuff[256];
	int i32Ret = 0;
	
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}

	if((NULL == buf) || (buflen < 128) || (timeout <= 0))
	{
		return WIFI_PRAM_ERR;
	}
	
	memset(acBuff, 0x00, sizeof(acBuff));

	i32Ret = hal_espReadVersion(acBuff, sizeof(acBuff), timeout);
	if(i32Ret < 0)
	{
		return WIFI_GETVERSION_ERR;
	}

	memcpy(buf, acBuff, i32Ret - 2);
	
    return  0;
}

/*
* Description: 查询当前网络连接状态
* Input: N
* Output:N
* Return: <0:通信错误，无响应。 
*         2:已连接AP，获得IP地址。 3:已建立TCP或UDP传输 
*         4:断开网络连接          5:未连接AP 
*/
//extern ST_AP_INFO gstApInfo;
int wifiGetLinkStatus_lib(void)
{
	sysLOG(APIWIFI_LOG_LEVEL_4, "\r\n");
	
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		sysLOG(APIWIFI_LOG_LEVEL_2, "<ERR> WIFI_NOT_OPEN_ERR\r\n");
		
		return WIFI_NOT_OPEN_ERR;
	}

	g_stApAsyInfo.apErrFlag = hal_espCheckAp(&g_stApAsyInfo.stApinfo);

	return hal_espWifiStatus();
}

/*
* Description: 查询当前模块AP连接状态，可获取到ssid.rssi/bssid/channel信息
* Input: N
* Output: pstApInfo  不为空指针时返回已连接的热点信息,具体参见ST_AP_INFO结构体,NULL时则只返回信号强度；
* Return: > 0   连接成功的信号强度等级
				1:   <-75dB
				2:   >=-75dB && <-65dB
				3:   >=-65dB
		  < 0   见返回值列表
*/
int wifiCheck_lib(ST_AP_INFO *pstApInfo)
{
	sysLOG(APIWIFI_LOG_LEVEL_4, "\r\n");
		
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		sysLOG(APIWIFI_LOG_LEVEL_2, "<ERR> WIFI_NOT_OPEN_ERR\r\n");
		return WIFI_NOT_OPEN_ERR;
	}

	if(pstApInfo == NULL)
	{
		//ST_AP_INFO stAp;
		
		g_stApAsyInfo.apErrFlag = hal_espCheckAp(&g_stApAsyInfo.stApinfo);//hal_espCheckApAsync(&stAp);//
	}
	else
	{
		g_stApAsyInfo.apErrFlag = hal_espCheckAp(&g_stApAsyInfo.stApinfo);//pstApInfo);//hal_espCheckApAsync(pstApInfo);//
		memcpy((uint8_t *)pstApInfo,(uint8_t *)&g_stApAsyInfo.stApinfo,sizeof(ST_AP_INFO));

	}
	
	return g_stApAsyInfo.apErrFlag;
}

/*
* Description: 
* Input: 
* Output: 
* Return: 
*/
int wifiSendCmd_lib(char *pcAtCmd, int iLen)
{
	//int i32Ret = -1;

	if((NULL == pcAtCmd) || (0 == iLen))
	{
		return WIFI_PRAM_ERR;
	}

	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}
	
	hal_wifiSend(pcAtCmd, iLen);

	return 0;
}

/*
* Description: 
* Input: 
* Output: 
* Return: 
*/
int wifiWaitResponse_lib(char *pcExpString, char *pcBuffOut, int iSizeOut)
{
	int i32Ret = -1;

	if((NULL == pcExpString) || (NULL == pcBuffOut) || (iSizeOut <= 0))
	{
		return WIFI_PRAM_ERR;
	}

	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}
	
	i32Ret = hal_wifiWaitString(pcExpString, pcBuffOut, iSizeOut);
	if(i32Ret < 0)
	{
		if(i32Ret == (-1))
		{
			return WIFI_WAITSTR_NOTEXIST;
		}

		return i32Ret;
	}

	return 0;
}

int wifiCtrl_lib(unsigned int iCmd, void *pArgIn, unsigned int iSizeIn, void *pArgOut, unsigned int iSizeOut)
{
	int i32Ret = -1;
//	unsigned char ucTempBuff[64];
//	int iGmTx = 0;
	
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}

	switch(iCmd)
	{
		case eCmdDomainToIP:
		{
			if((pArgIn == NULL) || (pArgOut == NULL))
			{
				return WIFI_PRAM_ERR;
			}
			
			i32Ret = hal_espWifiStatus();						/*需要连接AP*/
			if((i32Ret < 0) || (5 == i32Ret))
			{
				return WIFI_NOT_APCONNECT_ERR;
			}

			i32Ret = hal_wifiAtCIPDOMAIN((char *)pArgIn, (char *)pArgOut);
			if(i32Ret < 0)
			{
				return WIFI_ATCIPDOMAIN_ERR;
			}
		}
		break;

		case eCmdNetTime:
		{
			if(hal_espWifiStatus() == 5)
			{
				return WIFI_NOT_APCONNECT_ERR;
			}
		
			i32Ret = hal_espUpdateSysTime();
			if(i32Ret < 0)
			{
				return i32Ret;
			}			
		}
		break;
		
		default:
			break;
	}
	
	return 0;
}


int wifiSetTime_lib(void)
{
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		sysLOG(APIWIFI_LOG_LEVEL_2, "<ERR> WIFI_NOT_OPEN_ERR\r\n");
		return WIFI_NOT_OPEN_ERR;
	}
	
	return hal_espUpdateSysTime();
}

int wifiGetApNum_lib(void)
{
	sysLOG(APIWIFI_LOG_LEVEL_4, "\r\n");
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		sysLOG(APIWIFI_LOG_LEVEL_2, "<ERR> WIFI_NOT_OPEN_ERR\r\n");
		return WIFI_NOT_OPEN_ERR;
	}
	
	return hal_espGetApNum();
}

int wifiPing_lib(char *pcIP, int iIpLen)
{
	sysLOG(APIWIFI_LOG_LEVEL_4, "\r\n");	
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		sysLOG(APIWIFI_LOG_LEVEL_2, "<ERR> WIFI_NOT_OPEN_ERR\r\n");
		return WIFI_NOT_OPEN_ERR;
	}
		
	return hal_espPing(pcIP,iIpLen);
}

int wifiGetPingResult_lib(void)
{
	sysLOG(APIWIFI_LOG_LEVEL_4, "\r\n");	
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		sysLOG(APIWIFI_LOG_LEVEL_2, "<ERR> WIFI_NOT_OPEN_ERR\r\n");
		return WIFI_NOT_OPEN_ERR;
	}
	
	return hal_getPingResult();
}

/*
*@brief:读取User Version版本号
*@param1:版本号存储指针；param2:buf长度；param3:超时时间
*@return:>0-读取到的版本号字符串长度;<0-读取失败，具体参考ERR定义
*/
int wifiGetUserVersion_lib(char *buf, int buflen)
{
	int8 i8UversionbuffU[256];
	int i32Ret = -1;
	char *pcRp=NULL;
	char *pcRp1=NULL;
		
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}
	
	memset(i8UversionbuffU, 0, sizeof(i8UversionbuffU));
	i32Ret = hal_espReadVersion(i8UversionbuffU, 256, 1000);
	if(i32Ret < 0)
	{
		return WIFI_GETVERSION_ERR;
	}

	pcRp = myStrStr(i8UversionbuffU, "User Version:", 0, 255);
	if(pcRp == NULL)
	{
		return WIFI_GETVERSION_ERR;
	}

	pcRp1 = myStrStr(i8UversionbuffU, "compile time", 0, 255);
	if(pcRp1 == NULL)
	{
		return WIFI_GETVERSION_ERR;
	}
	i32Ret = pcRp1-pcRp-13-2;
	if(i32Ret < 0)
	{
		return WIFI_GETVERSION_ERR;
	}
	memcpy(buf, pcRp+13, i32Ret);
	
	return i32Ret;
	
	
}

/*
*@Brief: 		读取wifi用户程序版本号，返回hex
*@Param IN:		NULL
*@Param OUT:	NULL
*@Return:		wifi用户程序版本号hex值
*/
int32 wifiGetUserVersionHex_lib(void)
{
	int32 i32Ret =-1;
	int i32Hextmp1 = 0, i32Hextmp2 = 0, i32Hextmp3 = 0;
	char *pcRp=NULL;
	uint8 ui8Offsettmp2 = 0, ui8Offsettmp3 = 0;
	char acBuftmp[256];
	
	memset(acBuftmp, 0, sizeof(acBuftmp));
	i32Ret = wifiGetUserVersion_lib(acBuftmp, 256);
	//sysLOG(APIWIFI_LOG_LEVEL_1, "wifiGetUserVersion_lib i32Ret:%d,%s\r\n", i32Ret, acBuftmp);
	if(i32Ret < 0)
	{
		sysLOG(APIWIFI_LOG_LEVEL_2, "<ERR> wifiGetUserVersion_lib, i32Ret = %d\r\n", i32Ret);
		return WIFI_GETVERSION_ERR;
	}

	pcRp = myStrStr(acBuftmp, ".", 0, i32Ret);
	if(pcRp == NULL)
	{
		sysLOG(APIWIFI_LOG_LEVEL_2, "<ERR> myStrStr1\r\n");
		return WIFI_GETVERSION_ERR;
	}
	ui8Offsettmp3 = pcRp - acBuftmp;
	sysLOG(APIWIFI_LOG_LEVEL_4, "ui8Offsettmp3 = %d\r\n", ui8Offsettmp3);
	if(ui8Offsettmp3 == 2)i32Hextmp3 = *(acBuftmp+1)-0x30;
	else if(ui8Offsettmp3 == 3)i32Hextmp3 = (*(acBuftmp+1)-0x30)*10 + (*(acBuftmp+2)-0x30);
	else return WIFI_GETVERSION_ERR;

	pcRp = myStrStr(acBuftmp+ui8Offsettmp3+1, ".", 0+ui8Offsettmp3+1, i32Ret);
	if(pcRp == NULL)
	{
		sysLOG(APIWIFI_LOG_LEVEL_2, "<ERR> myStrStr1\r\n");
		return WIFI_GETVERSION_ERR;
	}
	ui8Offsettmp2 = pcRp - acBuftmp - ui8Offsettmp3;
	sysLOG(APIWIFI_LOG_LEVEL_4, "ui8Offsettmp2 = %d\r\n", ui8Offsettmp2);
	if(ui8Offsettmp2 == 2)i32Hextmp2 = *(acBuftmp+ui8Offsettmp3+1)-0x30;
	else if(ui8Offsettmp2 == 3)i32Hextmp2 = (*(acBuftmp+ui8Offsettmp3+1)-0x30)*10 + (*(acBuftmp+ui8Offsettmp3+2)-0x30);
	else return WIFI_GETVERSION_ERR;
	
	sysLOG(APIWIFI_LOG_LEVEL_4, "buflen-(ui8Offsettmp2+ui8Offsettmp3) = %d\r\n", i32Ret-(ui8Offsettmp2+ui8Offsettmp3));
	if(i32Ret-(ui8Offsettmp2+ui8Offsettmp3) == 2)i32Hextmp1 = *(acBuftmp+ui8Offsettmp2+ui8Offsettmp3+1)-0x30;
	else if(i32Ret-(ui8Offsettmp2+ui8Offsettmp3) == 3)i32Hextmp1 = (*(acBuftmp+ui8Offsettmp2+ui8Offsettmp3+1)-0x30)*10 + (*(acBuftmp+ui8Offsettmp2+ui8Offsettmp3+2)-0x30);
	else return WIFI_GETVERSION_ERR;

	i32Ret = i32Hextmp1+i32Hextmp2*100+i32Hextmp3*10000;
	return i32Ret;
	
}

/*
*@brief:查询更新状态
*@param1:超时时间
*@return:(-6401)-获取WiFi更新状态失败;-1-升级失败;0-未升级;1、2-准备升级;3-升级中;4-升级完成;5-升级成功
*/
int wifiGetUpdateState_lib(void)
{
	int i32Ret = -1;
	char *pcRp=NULL;

	char acRecvbuf[128];
	memset(acRecvbuf, 0, sizeof(acRecvbuf));
	
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}
	
	i32Ret = hal_espGetUpdateState(acRecvbuf, sizeof(acRecvbuf), 1000);
	if(i32Ret < 0)
	{
		return WIFI_GETUPDATESTA_ERR;
	}

	pcRp = myStrStr(acRecvbuf, "+CIPUPDATE", 0, 127);
	if(pcRp == NULL)
	{
		return WIFI_GETUPDATESTA_ERR;
	}
	if(*(pcRp+10) == ':')
	{
		if(*(pcRp+12) >= 0x30 && *(pcRp+12) < 0x39)
		{
			i32Ret = *(pcRp+12) - 0x30;
			return i32Ret;
		}
		else
		{
			return WIFI_GETUPDATESTA_ERR;
		}
	}
	
	pcRp = NULL;
	pcRp = myStrStr(acRecvbuf, "ERROR", 0, 127);
	if(pcRp == NULL)
	{
		return WIFI_GETUPDATESTA_ERR;
	}

	i32Ret =-1;

	return i32Ret;
}

int URL_analysis(char *pcUrl, char *pcServeraddr, char *pcPath, char *port)
{
	char *pcRpSer = NULL;
	char *pcRpPath = NULL;
	char *pcRpUser = NULL;
	char *pcRpPort = NULL;
	uint32 ui32SerOffset = 0;
	uint32 ui32PathOffset = 0;
	uint32 ui32UserOffset = 0;
	uint32 ui32PortOffset = 0;
	
	if(wifiGetUserVersionHex_lib() >= WIFIUPDATE_1_01_04)//wifi固件版本高于V1.01.04则传完整的URL
	{
		pcRpSer = myStrStr(pcUrl, "://", 0, strlen(pcUrl)-1);
		if(pcRpSer == NULL)
		{
			return -1;
		}
		ui32SerOffset = pcRpSer - pcUrl + 3;
		
		pcRpPort = myStrStr(pcUrl+ui32SerOffset, ":", ui32SerOffset, strlen(pcUrl)-1);
		if(pcRpPort != NULL)
		{
			ui32PortOffset = pcRpPort -pcUrl + 1;
			pcRpPath = myStrStr(pcUrl+ui32PortOffset, "/", ui32PortOffset, strlen(pcUrl)-1);
			if(pcRpPath == NULL)
			{
				return -3;
			}
			ui32PathOffset = pcRpPath - pcUrl;
			
			memcpy(pcServeraddr, pcUrl+ui32SerOffset, ui32PortOffset-1-ui32SerOffset);
			memcpy(port, pcUrl+ui32PortOffset, ui32PathOffset - ui32PortOffset);
			memcpy(pcPath, pcUrl+ui32PathOffset, strlen(pcUrl)-ui32PathOffset);
			
			sysLOG(APIWIFI_LOG_LEVEL_4, "pcUrl:%s, pcServeraddr:%s, port:%s, pcPath:%s\r\n", pcUrl, pcServeraddr, port, pcPath);
			
		}
		else
		{
			pcRpPath = myStrStr(pcUrl+ui32SerOffset, "/", ui32SerOffset, strlen(pcUrl)-1);
			if(pcRpPath == NULL)
			{
				return -3;
			}
			ui32PathOffset = pcRpPath - pcUrl;

			memcpy(pcServeraddr, pcUrl+ui32SerOffset, ui32PathOffset-ui32SerOffset);
			memcpy(pcPath, pcUrl+ui32PathOffset, strlen(pcUrl)-ui32PathOffset);
			sysLOG(APIWIFI_LOG_LEVEL_4, "pcUrl:%s, pcServeraddr:%s, pcPath:%s\r\n", pcUrl, pcServeraddr, pcPath);
		}
		
		
		return 1;
	}
	else
	{
		pcRpSer = myStrStr(pcUrl, "://", 0, strlen(pcUrl)-1);
		if(pcRpSer == NULL)
		{
			return -1;
		}
		ui32SerOffset = pcRpSer - pcUrl + 3;
		
		pcRpPort = myStrStr(pcUrl+ui32SerOffset, ":", ui32SerOffset, strlen(pcUrl)-1);
		if(pcRpPort != NULL)
		{
			ui32PortOffset = pcRpPort -pcUrl + 1;
			pcRpPath = myStrStr(pcUrl+ui32PortOffset, "/", ui32PortOffset, strlen(pcUrl)-1);
			if(pcRpPath == NULL)
			{
				return -3;
			}
			ui32PathOffset = pcRpPath - pcUrl;

			pcRpUser = myStrStr(pcUrl+ui32PathOffset, "user", ui32PathOffset, strlen(pcUrl)-1);
			if(pcRpUser == NULL)
			{
				return -4;
			}
			ui32UserOffset = pcRpUser - pcUrl;

			
			memcpy(pcServeraddr, pcUrl+ui32SerOffset, ui32PortOffset-1-ui32SerOffset);
			memcpy(port, pcUrl+ui32PortOffset, ui32PathOffset - ui32PortOffset);
			memcpy(pcPath, pcUrl+ui32PathOffset, ui32UserOffset - ui32PathOffset);
			
			sysLOG(APIWIFI_LOG_LEVEL_4, "pcUrl:%s, pcServeraddr:%s, port:%s, pcPath:%s\r\n", pcUrl, pcServeraddr, port, pcPath);
			
		}
		else
		{
			pcRpPath = myStrStr(pcUrl+ui32SerOffset, "/", ui32SerOffset, strlen(pcUrl)-1);
			if(pcRpPath == NULL)
			{
				return -3;
			}
			ui32PathOffset = pcRpPath - pcUrl;

			pcRpUser = myStrStr(pcUrl+ui32PathOffset, "user", ui32PathOffset, strlen(pcUrl)-1);
			if(pcRpUser == NULL)
			{
				return -4;
			}
			ui32UserOffset = pcRpUser - pcUrl;

			memcpy(pcServeraddr, pcUrl+ui32SerOffset, ui32PathOffset-ui32SerOffset);
			memcpy(pcPath, pcUrl+ui32PathOffset, ui32UserOffset - ui32PathOffset);

			sysLOG(APIWIFI_LOG_LEVEL_4, "pcUrl:%s, pcServeraddr:%s, pcPath:%s\r\n", pcUrl, pcServeraddr, pcPath);
		}
		
		
		return 1;
	}
	
	
}


/*
*@brief:更新WiFi固件
*@param1:0-serveraddr为域名；1-serveraddr为IP;param2:url;param3:超时时间
*@return:>0-成功;<0-失败
*/
int wifiUpdate_lib(char mode, char *url)
{
	int i32Ret = -1;

	char acServeraddrTemp[128];
	char acPathTemp[128];
	char acPortTemp[16];
	
	memset(acServeraddrTemp, 0, sizeof(acServeraddrTemp));
	memset(acPathTemp, 0, sizeof(acPathTemp));
	memset(acPortTemp, 0, sizeof(acPortTemp));
	
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}

	i32Ret = URL_analysis(url, acServeraddrTemp, acPathTemp, acPortTemp);
	if(i32Ret < 0)
	{
		return i32Ret;
	}
	
	i32Ret = hal_espUpdate(mode, acServeraddrTemp, acPathTemp, 1000);
	if(i32Ret < 0)
	{
		return WIFI_UPDATE_ERR;
	}

	return i32Ret;
}


/*
*@brief:重启wifi
*@param1:超时时间
*@return:>0-成功;<0-失败
*/
int wifiReboot_lib(int timeout)
{
	int i32Ret = -1;

	char acRecvbuf[128];
	memset(acRecvbuf, 0, sizeof(acRecvbuf));
	
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}
	
	i32Ret = hal_espReboot(acRecvbuf, sizeof(acRecvbuf), timeout);
	if(i32Ret < 0)
	{
		return WIFI_REBOOT_ERR;
	}
	return i32Ret;
}


/*
*@brief:查询触发状态
*@param1:超时时间
*@return:(-6403)wifi获取触发状态失败; <0-失败；bit0-bit3:触发状态,0-未触发，1-已触发；bit4-bit7:是否使能触发标志位，0-未开启；1-已开启
*/
int wifiGetTamperStatus_lib(int timeout)
{
	int i32Ret = -1;
	char *pcRp=NULL;
	char cStatus_t = 0;
	char aEnable_t = 0;
	char acRecvbuf[128];
	memset(acRecvbuf, 0, sizeof(acRecvbuf));
	
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}
	
	i32Ret = hal_espGetTamperStatus(acRecvbuf, sizeof(acRecvbuf), timeout);
	if(i32Ret < 0)
	{
		return WIFI_GETTAMPERSTA_ERR;
	}

	pcRp = myStrStr(acRecvbuf, "+TAMPER:", 0, 127);
	if(pcRp == NULL)
	{
		return WIFI_GETTAMPERSTA_ERR;
	}

	cStatus_t = *(pcRp+8);
	if(cStatus_t < 0x30 || cStatus_t > 0x39)
	{
		return WIFI_GETTAMPERSTA_ERR;
	}
	cStatus_t -= 0x30;

	aEnable_t = *(pcRp+10);
	if(aEnable_t < 0x30 || aEnable_t > 0x39)
	{
		return WIFI_GETTAMPERSTA_ERR;
	}
	aEnable_t -= 0x30;

	i32Ret = aEnable_t << 4 | cStatus_t;
	


	return i32Ret;
}


/*
*@brief:设置触发模式
*@param1:0-关闭触发；1-开启触发；2-清除触发；param2:超时时间
*@return:>0-成功;<0-失败
*/
int wifiTamper_lib(char mode, int timeout)
{
	int i32Ret = -1;

	char acRecvbuf[128];
	memset(acRecvbuf, 0, sizeof(acRecvbuf));
	
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}
	
	i32Ret = hal_espTamper(mode, acRecvbuf, sizeof(acRecvbuf), timeout);
	if(i32Ret < 0)
	{
		return WIFI_TAMPER_ERR;
	}
	return i32Ret;
}


/*
*@brief:wifi恢复出厂设置
*@return:0-成功；<0-失败
*/
int wifiRestore_lib(void)
{
	int i32Ret = 0;
	
	if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}
	
    i32Ret = hal_wifiAtRESTORE();
	if(i32Ret < 0)
	{
		return i32Ret;
	}
	//sysDelayMs(2000);
    return wifiInit_lib();
}

/*
*@Brief:		升级Wifi固件
*@Param IN:		data:发送数据；len:发送数据长度<=4096；flag: 0:后续还有数据发送; 1:最后一包数据; 
*@Param OUT:	NULL
*@Return:		0-成功；其它-失败
*/
int wifiUpgradeSendData_lib(uint8_t *pui8Data, int i32Len, uint8_t ui8Flag)
{
	int i =0;
	int i32Ret = 0;

    if(NO_OPEN == g_stWifiState.cOpenState)
	{
		return WIFI_NOT_OPEN_ERR;
	}

	if(i32Len > 4096)
	{
		return WIFI_UPDATE_SEND_LEN_ERR;
	}

	i32Ret = hal_wifiUpgradeSendData(pui8Data, i32Len, ui8Flag);
	if(i32Ret != 0 )
	{
		g_ui8Lrc = 0;
		wifiInit_lib();/////////////
		return WIFI_UPDATE_SEND_ERR;
	}

	return 0;
}

/*
*@Brief:		发送升级程序数据
*@Param IN:		0:关闭自动休眠 1:开启自动休眠
*@Param OUT:	NULL
*@Return:		0-成功；其它-失败
*/
int wifiAutoSleep_lib(int mode)
{
#if 0//关闭应用上对wifi休眠控制，默认为自动休眠，如需开启应用上对wifi休眠控制，放开此处即可
	if(mode == 1)
	{
		g_wifiAutoSleepMode = mode;		}
	else if(mode == 0)
	{
		wifi_setWkupTrue();
		g_wifiAutoSleepMode = mode;
	}
	else
	{
		return WIFI_PRAM_ERR;
	}
#endif
	return 0;
}

/*
*@Brief: 		开启web配网，配网前关闭TCP或SSL连接，开启配网至配网完成，只能调用wifiWebNetworkQue_lib查询配网状态或取消配网，不能调用WIFI的其他接口
*@Param IN:		ssid：wifi的AP名称；password：wifi的AP密码；timeout：配网超时时间
*@Param OUT:	NULL
*@Return:		0:配网成功；<0:配网失败
*/
int wifiWebNetwork_lib(uint8_t *pui8Ssid,  uint8_t *pui8Password, unsigned int ui32Timeout)
{
	int i32Ret = 0;
    
	if((g_ui8CreateSocketID & 0x1F) != 0x1F)
	{
		wifiResourceRelease();
	}
	wifiRestore_lib();
	i32Ret = hal_wifiWebNetwork(pui8Ssid, pui8Password, ui32Timeout);
	if(i32Ret < 0)
	{
		wifiRestore_lib();
		return WIFI_WEB_NETWORK_ERR;
	}
	return 0;
}

/*
*@Brief: 		查询web配网状态或取消配网
*@Param IN:		cancelFlag：0：查询配网状态；1：取消配网
*@Param OUT:	NULL
*@Return:		4-等待进入配网；0-准备配网，应用语音播报配网；1-正在联网；2-已经联网成功；3-超时并退出；
*/
int wifiWebNetworkQue_lib(uint8_t ui8CancelFlag)
{
	int i32Ret = 0;
	i32Ret = hal_wifiWebNetworkQue(ui8CancelFlag);
	if(i32Ret < 0)
	{
		return WIFI_WEB_NETWORKQUE_ERR;
	}
	//sysLOG(APIWIFI_LOG_LEVEL_1, "i32Ret:%d\r\n", i32Ret);
	return i32Ret;
}

/*
*@Brief: 		查询web本地升级Wifi状态
*@Param IN:		cancelFlag：0：查询升级状态；1：取消升级
*@Param OUT:	NULL
*@Return:		1：等待接收升级数据；2：开始升级；3：升级成功；<0:升级失败
*/
int wifiWebUpdateQue_lib(char ui8CancelFlag)
{
	int i32Ret = 0;
	sysLOG(APIWIFI_LOG_LEVEL_4, "\r\n");
	i32Ret = hal_wifiWebUpdateQue(ui8CancelFlag);
	if(i32Ret < 0)
	{
		return WIFI_WEB_UPDATE_ERR;
	}
	//sysLOG(APIWIFI_LOG_LEVEL_1, "i32Ret:%d\r\n", i32Ret);
	if(i32Ret == 3)
	{
		sysDelayMs(100);
		wifiRestore_lib();
	}
	return i32Ret;
}

/*
*@Brief: 		开启airkiss配网，配网前关闭TCP或SSL连接，开启配网至配网完成，只能调用wifiAirkissNetworkQue_lib查询配网状态或取消配网，不能调用WIFI的其他接口
*@Param IN:		timeout:配网超时时间
*@Param OUT:	NULL
*@Return:		0:配网成功；<0:配网失败
*/
int wifiAirkissNetwork_lib(unsigned int ui32Timeout)
{
	int i32Ret = 0;

	if((g_ui8CreateSocketID & 0x1F) != 0x1F)
	{
		wifiResourceRelease();
	}
	wifiRestore_lib();
	i32Ret = hal_wifiAirkissNetwork(ui32Timeout);
	if(i32Ret < 0)
	{
		sysLOG(API_LOG_LEVEL_0, "  wifiAirkissNetwork=%d\r\n",i32Ret);
		wifiRestore_lib();
		return WIFI_AIRKISS_ERR;
	}
	return 0;
}

/*
*@Brief: 		查询airkiss配网状态或取消配网
*@Param IN:		cancelFlag：0：查询配网状态；1：取消配网
*@Param OUT:	NULL
*@Return:		0：无配网；1：等待接收配网信息；2：启动配网；3：正在连接；4：连接成功并获取IP；5：释放配网资源,完成配网
*/
int wifiAirkissNetworkQue_lib(uint8_t ui8CancelFlag)
{
	int i32Ret = 0;
	i32Ret = hal_wifiAirkissNetworkQue(ui8CancelFlag);
	if(i32Ret < 0)
	{
		return WIFI_AIRKISSQUE_ERR;
	}
	return i32Ret;
}

/*
*@Brief:		airkiss和web配网中查状态，启动配网后生效
*@Param IN:		NULL
*@Param OUT:	NULL
*@Return:		4-等待进入配网；0-准备配网，应用语音播报配网；1-正在联网；2-已经联网成功；3-超时并退出；
*/
int wifiAPConnectCheck_lib(void)
{
	if(g_cWifiVersionFlag == NOSDKVERSION)
	{
		return AP_connect_check();
	}else{
		if(g_ui8NetFlag == 1)
		{
			return wifiWebNetworkQue_lib(0);
		}
		else if(g_ui8NetFlag == 2)
		{
			return wifiAirkissNetworkQue_lib(0);
		}
	}
}

/*
*@Brief:		配置热点方式
*@Param IN:		connect_type:AP_AIRKISS_ID,AP_WEB_ID,AP_BT_ID,timeout:超时时间，单位秒
*@Param OUT:	NULL
*@Return:		>=0：成功；<0:失败
*/
int wifiAPConnectType_lib(APCTYPE connect_type, unsigned int timeout)
{
	if(g_cWifiVersionFlag == NOSDKVERSION)
	{
		return APconnect_type(connect_type, timeout);
	}else{
		if(connect_type == AP_WEB_ID)
		{
			g_ui8NetFlag = 1;
			return wifiWebNetwork_lib("vanstone", "12345678", timeout);
		}else{
			g_ui8NetFlag = 2;
			return wifiAirkissNetwork_lib(timeout);
		}
	}
}

/*
*@Brief:		退出配网
*@Param IN:		NULL
*@Param OUT:	NULL
*@Return:		>=0-成功；<0-失败
*/
int wifiAPConnectQuit_lib(void)
{
	if(g_cWifiVersionFlag == NOSDKVERSION)
	{
		return APconnect_quit();
	}else{
		if(g_ui8NetFlag == 1)
		{
			g_ui8NetFlag = 0;
			return wifiWebNetworkQue_lib(1);
		}
		else if(g_ui8NetFlag == 2)
		{
			g_ui8NetFlag = 0;
			return wifiAirkissNetworkQue_lib(1);
		}
	}
}

/*
*@Breif:		域名解析
*@Param IN：		*pcDomain：域名；*pcIP：解析后的ip
*@Return:		0-succ;<0-failed
*/
int wifiGetHostByName_lib(char *pcDomain, char *pcIP)
{
	return hal_wifiAtCIPDOMAIN(pcDomain, pcIP);
}

/*
*@Breif:		本地升级WIFi固件
*@Param IN：	IP：本地服务器IP；len：ip长度
*@Return:		0-succ;<0-failed
*/
int WifiLocalDown_lib(char *pcIP, int i32Len)
{
	return hal_WifiLocalDown(pcIP, i32Len);
}

/*
* Description: 证书下载,如果下载之前连接热点，下载完成重连接热点
* Input:       cType:0：下载CA证书；1：下载客户端证书；2：下载客户端私钥
* Output:N
* Return: <0:初始化失败； 0：成功
*/
int WifiespDownloadCrt_lib(char cType, char *data, int i32Len)
{
	int i32Ret = -1;
	
	i32Ret = hal_espDownloadCrt(cType, data, i32Len);
	if(i32Ret == 0)
	{
		wifiInit_lib();
	}
	return i32Ret;
}

/*
* Description: 设置SSL客户端配置，重启Wifi后生效，
* Input:       sockid:套接字ID；mode:0:不认证；1：提供客户端证书；2：验证服务器；3：双向认证
* Output:N
* Return: <0:初始化失败； 0：配置成功
*/
int WifiespSetSSLConfig_lib(int sockid, uint8_t ui8Mode)
{
	if((sockid > 4) || (sockid < 0) || (ui8Mode >3))
	{
		return WIFI_SSL_CONFIG_PARA_ERR;
	}

	return hal_espSetSSLConfig(sockid, ui8Mode);
}

/*
* Description: 查询SSL客户端配置
* Input:       sockid:套接字ID；
* Output:N
* Return: <0:初始化失败 成功：0:不认证；1：提供客户端证书；2：验证服务器；3：双向认证
*/
int WifiespQuerySSLConfig_lib(int sockid)
{
	if((sockid > 4) || (sockid < 0))
	{
		return WIFI_SSL_GET_CONFIG_PARA_ERR;
	}
	return hal_espQuerySSLConfig(sockid);
}

/***************************************************************************************************
*
*                                       测试部分
*
****************************************************************************************************/

#if MAINTEST_FLAG


int api_wifiTest_Open(void)
{
    int i32Ret = 0;
    
    //api_scrCls(LCD_COLOR_WHITE);
    
    //hal_scrSetMenuTitle("WIFI OPEN");
    
    i32Ret = wifiOpen_lib();
    if(i32Ret)
    {
        sysLOG(2, "Wifi Open Err:%d", i32Ret);
    }
    else
    {
        sysLOG(2, "Wifi Open Success");
    }
    
//    while(1)
//    {
//        if((0 == api_kbHit()) && (KEYCANCEL == api_kbGetKey()))
//        {
//            return 0;
//        }
//    } 
    
    return 0;
}


void url_test(void)
{
	char acUrlTemp[256];

	char acServeraddrTemp[128];
	char acPathTemp[128];
	char acPortTemp[16];
	
	memset(acServeraddrTemp, 0, sizeof(acServeraddrTemp));
	memset(acPathTemp, 0, sizeof(acPathTemp));
	memset(acPortTemp, 0, sizeof(acPortTemp));
	memset(acUrlTemp, 0, 256);
	sprintf(acUrlTemp, "http://sys00.jiewen.com.cn:80/csms/AppFile/user1.bin");
	URL_analysis(acUrlTemp, acServeraddrTemp, acPathTemp, acPortTemp);

	memset(acServeraddrTemp, 0, sizeof(acServeraddrTemp));
	memset(acPathTemp, 0, sizeof(acPathTemp));
	memset(acPortTemp, 0, sizeof(acPortTemp));
	memset(acUrlTemp, 0, 256);

	sprintf(acUrlTemp, "http://sys00.jiewen.com.cn/csms/AppFile/user1.bin");
	URL_analysis(acUrlTemp, acServeraddrTemp, acPathTemp, acPortTemp);

	
}


void wifiupdate_test(void)
{
	int i32Ret = -1;
	char acBuftest[256];
	unsigned char ucKey = 0;
	scrCls_lib();

	scrPrint_lib(0,2, 0, "等待连接服务器...");
	scrPrint_lib(0,3, 0, "若无升级操作请重启机器!");

	if(g_cWifiVersionFlag == 0)
	{
		wifiOpen_lib();
		sysDelayMs(3000);
		
		memset(acBuftest, 0, 256);
		i32Ret = wifiGetUserVersion_lib(acBuftest, 256);
		//sysLOG(APIWIFI_LOG_LEVEL_1, "wifiGetUserVersion_lib i32Ret:%d,%s\r\n", i32Ret, acBuftest);
		i32Ret = wifiGetUserVersionHex_lib();
		sysLOG(APIWIFI_LOG_LEVEL_1, "wifiGetUserVersionHex_lib, i32Ret = %d\r\n", i32Ret);
		//return;
		
		i32Ret = wifiGetUpdateState_lib();
		sysLOG(APIWIFI_LOG_LEVEL_1, "wifiGetUpdateState_lib i32Ret:%d\r\n", i32Ret);

		memset(acBuftest, 0, 256);
		
		//sprintf(acBuftest,"http://sys00.jiewen.com.cn:80/csms/AppFile/user1.bin");

		sprintf(acBuftest,"http://ipos-n.vanstone.com.cn:80/romfiles/other/appfiles/hbyx/dev.wifi.url/V1.01.22/v1.01.22.bin");
		//sprintf(acBuftest,"http://speaker-f.vanstone.com.cn:80/AppFile/Vanstone/20210702/user2_v1.02.06.bin");
		
		i32Ret = wifiUpdate_lib(0, acBuftest);
		sysLOG(APIWIFI_LOG_LEVEL_1, "wifiUpdate_lib i32Ret:%d\r\n", i32Ret);

		do
		{
			i32Ret = wifiGetUpdateState_lib();
			sysLOG(APIWIFI_LOG_LEVEL_1, "wifiGetUpdateState_lib i32Ret:%d\r\n", i32Ret);
			scrPrint_lib(0,4, 0, "升级状态 %d",i32Ret);
			sysDelayMs(2000);
		}
		while (i32Ret<5);

		//scrPrint_lib(0,4, 0, "升级状态 %d",i32Ret);

		i32Ret = wifiReboot_lib(1000);
		sysLOG(APIWIFI_LOG_LEVEL_1, "wifiReboot_lib i32Ret:%d\r\n", i32Ret);
		
	}
	else{
		scrPrint_lib(0,4, 0, "Wifi版本不支持 %d", i32Ret);
		while(1)
		{
			ucKey = kbGetKey_lib();
			if(ucKey == KEYCANCEL)
			{
				return;
			}
			sysDelayMs(50);
		}
	}
	
}


void wifitamper_test(void)
{
	int i32Ret =-1;
	wifiOpen_lib();
	sysDelayMs(30000);

	for(char i = 0; i < 3; i++)
	{
		i32Ret = wifiGetTamperStatus_lib(500);
		sysLOG(APIWIFI_LOG_LEVEL_1, "start wifiGetTamperStatus_lib i32Ret=%x\r\n", i32Ret);
		sysDelayMs(2000);
		i32Ret = wifiTamper_lib(i, 500);
		sysLOG(APIWIFI_LOG_LEVEL_1, "wifiTamper_lib ,set mode %x, i32Ret=%d\r\n", i, i32Ret);
		sysDelayMs(2000);
		i32Ret = wifiGetTamperStatus_lib(500);
		sysLOG(APIWIFI_LOG_LEVEL_1, "end wifiGetTamperStatus_lib i32Ret=%x\r\n", i32Ret);
		sysDelayMs(2000);
	}
	i32Ret = wifiTamper_lib(0, 500);
	sysLOG(APIWIFI_LOG_LEVEL_1, "wifiTamper_lib ,set mode %x, i32Ret=%d\r\n", 0, i32Ret);
	sysDelayMs(2000);
	i32Ret = wifiGetTamperStatus_lib(500);
	sysLOG(APIWIFI_LOG_LEVEL_1, "wifiGetTamperStatus_lib i32Ret=%x\r\n", i32Ret);
}


#if 0
int api_wifiTest_Connect(void)
{
    unsigned char ucKey = 0xFF;
    unsigned char aucPassWord[32];
    unsigned char aucReceBuf[2048];
    unsigned char aucSendBuf[1024];
    unsigned int uiStartTime = 0;
    unsigned int uiEndTime = 0;
    int i32Ret = 0;
    int i = 0;
    int j = 0;
    unsigned int uiCnt = 0;
	ST_AP_LIST stAp[30];
    ST_AP_INFO stApInfo;
	ST_AP_MAC stApMac;
	ST_WIFI_PARAM stWifiParam;
    //api_scrCls(LCD_COLOR_WHITE);
    
    //hal_scrSetMenuTitle("WIFI Connect");

    i32Ret = wifiOpen_lib();
    if(i32Ret)
    {
        sysLOG(2, "Wifi Open Err:%d", i32Ret);
    }
    else
    {
        sysLOG(2, "Wifi Open Success");
    }

    i32Ret = wifiScan_lib(stAp, 30);
	

	if(i32Ret <= 0)
	{
		sysLOG(2, "Wifi Scan err %d", i32Ret);
		//api_kbWaitOneKey();
		return 0;
	}
#if 0
    while(1)
    {

	    for(i = 0; i < 6; i++)
	    {
			sysLOG(1, "%d.%-16.16s  %ddBm", i+1, stAp[j+i].cSsid, stAp[j+i].iRssi);
	        if((j+i+1) >= i32Ret)
	        {
	            break;
	        }
	    }
    
            
        while(1)
        {
            ucKey = api_kbGetKey();
            
            if(KEYENTER == ucKey)
            {
                if(j >= (i32Ret-6))
                {
                    j = 0;
                }
                else
                {
                    j++;
                }
                api_scrClrLine(2,7);
                break;
            }

			if(KEYCANCEL == ucKey)
            {		
                return 0;
            }

			if(ucKey >= '1' && ucKey <= ('0'+ i+1))
            {
                api_scrClrLine(2,7);
                
                api_scrPrint(0, 2, 0x02, "%s", stAp[j+ ucKey -'0'- 1].cSsid);

				memset(aucPassWord, 0x00, sizeof(aucPassWord));
				if(0 == memcmp(stAp[j+ ucKey -'0'- 1].cSsid, "JW-2.4G", strlen("JW-2.4G")))
				{
	                memcpy(aucPassWord+1, "jiewen-2017", strlen("jiewen-2017"));					
				}
				else
				{
					api_scrPrint(0, 3, 0x02, "Please Input Password:");
	                api_scrClrLine(4,4);
					api_scrGotoxyLine(0, 4);
	                while(1)
	                {
	                    i32Ret = api_kbGetString(aucPassWord, 0x25, 1, sizeof(aucPassWord), 300);
	                    if(0 == i32Ret)
	                    {
	                        break;
	                    }
	                    else if(ERR_KBD_USR_CANCEL == i32Ret)
	                    {
							wifiClose_lib();
							
	                        return -1;
	                    }                    
	                }
				}                
                api_scrClrLine(3,4);
                api_scrPrint(0, 4, 0x02, "Connect ...");
                
                i32Ret = wifiAPConnect_lib(stAp[j+ ucKey -'0'- 1].cSsid, (char*)aucPassWord+1);
                api_scrClrLine(2,7);
                if(0 == i32Ret)
                {
                    api_scrClrLine(3,4);
                    api_scrPrint(0, 4, 0x02, "%s Connect OK", stAp[j+ ucKey -'0'- 1].cSsid);

					while(1);
                }
			}


        }

    }
#endif
#if 0

            if(KEYCANCEL == ucKey)
            {
                return 0;
            }
            
            if(ucKey >= '1' && ucKey <= ('0'+ i+1))
            {
                api_scrClrLine(2,7);
                
                api_scrPrint(0, 2, 0x02, "%s", ap_t[j+ ucKey -'0'- 1].ssid);

				memset(aucPassWord, 0x00, sizeof(aucPassWord));
				if(0 == memcmp(stAp[j+ ucKey -'0'- 1].acSsid, "JW-2.4G", strlen("JW-2.4G")))
				{
	                memcpy(aucPassWord+1, "jiewen-2017", strlen("jiewen-2017"));					
				}
				else
				{
					api_scrPrint(0, 3, 0x02, "Please Input Password:");
	                api_scrClrLine(4,4);
					api_scrGotoxyLine(0, 4);
	                while(1)
	                {
	                    i32Ret = api_kbGetString(aucPassWord, 0x25, 1, sizeof(aucPassWord), 300);
	                    if(0 == i32Ret)
	                    {
	                        break;
	                    }
	                    else if(ERR_KBD_USR_CANCEL == i32Ret)
	                    {
							wifiClose_lib();
							
	                        return -1;
	                    }                    
	                }
				}                
                api_scrClrLine(3,4);
                api_scrPrint(0, 4, 0x02, "Connect ...");
                
                i32Ret = wifiAPConnect_lib(ap_t[j+ ucKey -'0'- 1].ssid, (char*)aucPassWord+1);
                api_scrClrLine(2,7);
                if(0 == i32Ret)
                {
                    api_scrClrLine(3,4);
                    api_scrPrint(0, 4, 0x02, "%s Connect OK", ap_t[j+ ucKey -'0'- 1].ssid);
                    delay_ms(5000);
                    api_scrClrLine(2,7); 
                    api_scrPrint(0, 3, 0x02, "IP:103.235.231.22");
                    api_scrPrint(0, 4, 0x02, "Port:5000");
                    while(1)
                    {
                        ucKey = api_kbGetKey();

                        if(KEYCANCEL == ucKey)
                        {
                            return 0;
                        }
            
                        if(KEYENTER == ucKey)
                        {
                            i32Ret = wifiCommConnect_lib("TCP", "103.235.231.22", "5000", 3000);
                            if(0 == i32Ret)
                            {
                                api_scrClrLine(3,4);
                                api_scrPrint(0, 3, 0x02, "TCP Connect OK");
                                memset(aucSendBuf, 0x5A, sizeof(aucReceBuf));
                                
                             	while(1)
                                {
									i32Ret = wifiCommSendData_lib((char *)aucSendBuf, 100, 1000, 1);
									if(i32Ret < 0)
									{
										api_scrClrLine(3,4);
										api_scrPrint(0, 4, 0x02, "Send %d",i32Ret);
						                while(1)
						                {
						                    if((0 == api_kbHit()) && (KEYCANCEL == api_kbGetKey()))
						                    {
						                        return 0;
						                    }
						                }
									}
									
                                	i32Ret = wifiWaitData_lib((char*)(aucReceBuf), 100+14, 5000);
									if(i32Ret < 0)
									{
										api_scrClrLine(3,4);
										api_scrPrint(0, 4, 0x02, "Recv %d", i32Ret);
						                while(1)
						                {
						                    if((0 == api_kbHit()) && (KEYCANCEL == api_kbGetKey()))
						                    {
						                        return 0;
						                    }
						                }										
									}
									
                                	api_scrPrint(0, 4, 0x02, "i32Ret = %d",i32Ret);

									if((0 == api_kbHit()) && (KEYCANCEL == api_kbGetKey()))
				                    {
				                        return 0;
				                    }
                             	}
                            }
                            else
                            {
                                api_scrClrLine(3,4);
                                api_scrPrint(0, 3, 0x02, "TCP Connect Failed"); 
                                delay_ms(3000);
                                
                                api_scrClrLine(3,4);
                                api_scrPrint(0, 3, 0x02, "Continue ?");
                            }
                        }
                    }                     
                }
                else
                {
                    api_scrPrint(0, 4, 0x02, "%s Connect Fail", ap_t[j+ ucKey -'0'- 1].ssid);
                }
                
                while(1)
                {
                    if((0 == api_kbHit()) && (KEYCANCEL == api_kbGetKey()))
                    {
                        return 0;
                    }
                } 
            }
        }
       
    }
	#endif
}
#endif

#if 0

void api_wifiTest_Version(void)
{
	char acBuff[128];
	int i32Ret = 0;
	
	memset(acBuff, 0x00, sizeof(acBuff));
	api_scrClrLine(1,7);
    hal_scrSetMenuTitle("Version");
	
	i32Ret = wifiOpen_lib();
	if(i32Ret < 0)
	{
		 api_scrPrint(0, 7, 0x02, "Open Fail %d", i32Ret);
	}

	i32Ret = wifiReadVersion_lib(acBuff, sizeof(acBuff), 3000);
	if(i32Ret < 0)
	{
		api_scrPrint(0, 7, 0x02, "GetVersion Fail %d", i32Ret);
	}
	else
	{
		api_scrPrint(0, 2, 0x00, "%s", acBuff);
	}

	while(1)
    {
        if((0 == api_kbHit()) && (KEYCANCEL == api_kbGetKey()))
        {
            return;
        }
    } 
}

void api_MenuWifi_Scan_ConnectAp(void)
{
	int i32Ret = -1;
	ST_AP_LIST stAplist[30];
	int i = 0;
	int j = 0;
	unsigned char ucKey = 0xFF;
	unsigned char aucPassWord[32];
	int iLoopOut = 0;
	while(1)	
	{
		api_scrClrLine(2,9);
	
	    i32Ret = wifiScan_lib(stAplist, 30);
		if(i32Ret <= 0)
		{
			api_scrPrint(0, 9, 0x02, "Wifi Scan err %d", i32Ret);
			api_kbWaitOneKey();
			return ;
		}
		
		iLoopOut = 1;
	    while(1)
	    {
			if(iLoopOut != 1)
			{
				break;
			}
			
	        for(i = 0; i < 8; i++)
	        {
				api_scrPrint(0, 2+i, 0x00, "%d.%-16.16s  %ddBm", i+1, stAplist[j+i].cSsid, stAplist[j+i].iRssi);
	            if((j+i+1) >= i32Ret)
	            {
	                break;
	            }
	        }
            iLoopOut = 2;
	        while(1)
	        {
				if(iLoopOut != 2)
				{
					break;
				}
							
	            ucKey = api_kbGetKey();
	            
	            if(KEYENTER == ucKey)
	            {
	                if(j >= (i32Ret-8))
	                {
	                    j = 0;
	                }
	                else
	                {
	                    j++;
	                }
	                api_scrClrLine(2,9);
					iLoopOut = 1;
	                break;
	            }

				if(KEYCANCEL == ucKey)
	            {		
	                return ;
	            }

				if(ucKey >= '1' && ucKey <= ('0'+ i+1))
	            {
	                api_scrClrLine(2,9);
	                
	                api_scrPrint(0, 2, 0x02, "%s", stAplist[j+ ucKey -'0'- 1].cSsid);

					memset(aucPassWord, 0x00, sizeof(aucPassWord));
					if(0 == memcmp(stAplist[j+ ucKey -'0'- 1].cSsid, "JW-2.4G", strlen("JW-2.4G")))
					{
		                memcpy(aucPassWord+1, "jiewen-2017", strlen("jiewen-2017"));					
					}
					else if(0 == memcmp(stAplist[j+ ucKey -'0'- 1].cSsid, "VANSTONE-RD", strlen("VANSTONE-RD")))
					{
		                memcpy(aucPassWord+1, "van12345", strlen("van12345"));					
					}
					else
					{
						api_scrPrint(0, 3, 0x02, "Need Password?");
						while(1)
						{
							i32Ret = api_kbGetKey();
							if(i32Ret == KEYCANCEL)
							{
								break;
							}
							
							if(i32Ret == KEYENTER)
							{
								break;
							}
						}

						if(i32Ret == KEYENTER)
						{
							api_scrClrLine(3,4);
							api_scrPrint(0, 3, 0x02, "Please Input Password:");
							api_scrGotoxyLine(0, 4);
			                while(1)
			                {
			                    i32Ret = api_kbGetString(aucPassWord, 0x25, 1, sizeof(aucPassWord), 300);
			                    if(0 == i32Ret)
			                    {
			                        break;
			                    }
			                    else if(ERR_KBD_USR_CANCEL == i32Ret)
			                    {
	//								wifiClose_lib();
									return;
			                    }                    
			                }							
						}
					}
		
	                api_scrClrLine(3,4);
	                api_scrPrint(0, 4, 0x02, "Connect ...");
	                
	                i32Ret = wifiAPConnect_lib(stAplist[j+ ucKey -'0'- 1].cSsid, (char*)aucPassWord+1);
	                if(0 == i32Ret)
	                {
	                    api_scrClrLine(2,9);
	                    api_scrPrint(0, 4, 0x02, "%s Connect OK", stAplist[j+ ucKey -'0'- 1].cSsid);
						api_kbWaitOneKey();
						return ;
	                }
					else

					{
	                    api_scrClrLine(2,9);
	                    api_scrPrint(0, 4, 0x02, "%s Connect Fail", stAplist[j+ ucKey -'0'- 1].cSsid);

						iLoopOut = 0;
						api_kbWaitOneKey();
					}
				}
			}
        }
    }
}


void api_MenuWifi_AutoJoin(void)
{
	int i32Ret = -1;
	unsigned char ucKey = 0xFF;
	
	api_scrClrLine(3,9);
	api_scrPrint(0, 3, 0x02, "1.Auto-join Yes");				
	api_scrPrint(0, 4, 0x02, "2.Auto-join No ");
	
	api_kbFlush();

	while(1)
	{
		ucKey = api_kbGetKey();
		switch(ucKey)
		{
			case KEY1:										
				i32Ret = hal_espAutoConnect(1);
				if(0 == i32Ret)
				{
					api_scrPrint(0, 7, 0x02, "OK");
					api_kbWaitOneKey();
					return ;
				}
				else
				{
					api_scrPrint(0, 7, 0x02, "err: %d", i32Ret);
				}
				break;
			case KEY2:										
				i32Ret = hal_espAutoConnect(0);
				if(0 == i32Ret)
				{
					api_scrPrint(0, 7, 0x02, "OK");
					api_kbWaitOneKey();
					return ;
				}
				else
				{
					api_scrPrint(0, 7, 0x02, "err: %d", i32Ret);
				}
				break;

			case KEYCANCEL:
				return ;
			default:
				break;
		}
	}
}

void api_MenuWifi_ConfigIP(void)
{
	int i32Ret = -1;
	unsigned char ucKey = 0xFF;
	char cIpBuf[20];
	char cMacBuf[20];
	char cGateWay[20];
	char cNetMask[20];

	ST_WIFI_PARAM stWifiParam;

	int iLoopOut = 0;
	
	api_scrClrLine(2,9);
	while(1)
	{
		memset(&stWifiParam, 0x00, sizeof(ST_WIFI_PARAM));
		
		i32Ret = wifiGetConnectParam_lib(&stWifiParam);
		if(i32Ret < 0)
		{
			if(WIFI_NoAP_NOTIP == i32Ret)
			{
				api_scrPrint(0, 9, 0x02, "No AP");
			}
			else
			{
				api_scrPrint(0, 9, 0x02, "1.err: %d", i32Ret);
							
			}
			
			api_kbWaitOneKey(); 
			
			return ;			
		}

		i32Ret = wifiGetMac_lib(cMacBuf);
		if(i32Ret < 0)
		{
			api_scrPrint(0, 9, 0x02, "2.err: %d", i32Ret);
			api_kbWaitOneKey();
			return ;			
		}

		if(stWifiParam.iDHCPEnable == 0)
		{
			api_scrPrint(0, 2, 0x00, "Manual");
		}
		else
		{
			api_scrPrint(0, 2, 0x00, "Automatic");
		}
		api_scrPrint(0, 4, 0x00, "IP:%s", stWifiParam.cIp);
		api_scrPrint(0, 5, 0x00, "GateWay:%s", stWifiParam.cGateWay);
		api_scrPrint(0, 6, 0x00, "NetMask:%s", stWifiParam.cNetMask);
		api_scrPrint(0, 7, 0x00, "Mac:%s", cMacBuf);

		api_scrPrint(0, 3, 0x02, "1.Manual  2.Automatic");
		
		iLoopOut = 1;
		api_kbFlush();
		while(1)
		{
			if(iLoopOut != 1)
			{
				break;
			}
			
			ucKey = api_kbGetKey();
			switch(ucKey)
			{
				case KEY1:
					break;
					
				case KEY2:
					
					i32Ret = wifiGetLinkStatus_lib();
					if(i32Ret < 0)
					{
						api_scrPrint(0, 9, 0x02, "3.err: %d", i32Ret);
						api_kbWaitOneKey();
						return ;
					}
					if(5 != i32Ret)
					{
						i32Ret = wifiAPDisconnect_lib();
						if(i32Ret < 0)
						{
							api_scrPrint(0, 9, 0x02, "4.err: %d", i32Ret);
							api_kbWaitOneKey();
							return ;
						}						
					}
					
					memset(&stWifiParam, 0x00, sizeof(stWifiParam));
					stWifiParam.iDHCPEnable = 1;
					i32Ret = wifiConfigConnectParam_lib(&stWifiParam);
					if(i32Ret < 0)
					{
						api_scrPrint(0, 9, 0x02, "5.err: %d", i32Ret);
						api_kbWaitOneKey();
						return ;
					}
					iLoopOut = 0;
					break;
					
				case KEYCANCEL:
					return ;
				default:
					break;					
			}
		}
	}
}


void api_MenuWifi_TCP(void)
{
	int i32Ret = -1;
	char cSendBuff[1024];
	char cRecvBuff[1024];
	int iSuccT = 0;
	int iSuccR = 0;
	int iSum = 0;
	unsigned char ucKey = 0xFF;
	
	memset(cSendBuff, 'A', sizeof(cSendBuff));
	memset(cRecvBuff, 0x00, sizeof(cRecvBuff));

/*建立TCP连接*/
	api_scrClrLine(2,9);
	api_scrPrint(0, 3, 0x02, "IP:103.235.231.21");
	api_scrPrint(0, 4, 0x02, "Port:3000");
	api_scrPrint(0, 5, 0x02, "Connect...."); 	
	i32Ret = wifiCommConnect_lib("TCP", "103.235.231.21", "3000", 3000);
	if(i32Ret < 0)
	{
		if(i32Ret == WIFI_TCP_CONNECTED)
		{
			wifiCommClose_lib();
		}
		api_scrPrint(0, 6, 0x00, "TCP Connect Err: %d", i32Ret);
		api_scrPrint(0, 7, 0x02, "AnyKey Exit");
		api_kbWaitOneKey();	
		
		return ;
	}
	
	api_scrClrLine(5,5);
	api_scrPrint(0, 5, 0x02, "Connect OK"); 
/*循环发送、接收数据*/
	while(1)
	{
		i32Ret = wifiGetLinkStatus_lib();
		if(3 == i32Ret)
		{
			iSum += 1;
			
			i32Ret = wifiCommSendData_lib(cSendBuff, 1024, 1000, 1);
			if(i32Ret == 0)
			{
				iSuccT += 1;
			}
			
			memset(cRecvBuff, 0x00, sizeof(cRecvBuff));
			i32Ret = wifiWaitData_lib(cRecvBuff, 1024, 10000);
			if(i32Ret == 1024)
			{
				if(0 == memcmp(cSendBuff, cRecvBuff, 1024))
				{
					iSuccR += 1;
				}
			}

			api_scrPrint(0, 6, 0x00, "S:%d T:%d R:%d", iSum, iSuccT, iSuccR);

//			api_scrPrint(0, 7, 0x02, "Enter Continue");
//			while(1)
			{
				if(0 == api_kbHit())
				{
					ucKey = api_kbGetKey();
					if(KEYCANCEL == ucKey)
					{
						wifiCommClose_lib();
						return ;
					}
					else
					{
						break;
					}
				}
			}
			api_scrClrLine(7,7);
		
		}
		else
		{
			api_scrClrLine(3,7);
			switch(i32Ret)
			{
				case 4:
					api_scrPrint(0, 4, 0x00, "TCP DisConnect");
				break;
				
				case 5:
					api_scrPrint(0, 4, 0x00, "AP DisConnect");
				break;
				default:
					api_scrPrint(0, 4, 0x00, "Err: %d", i32Ret);
					break;
			}
			
			api_scrPrint(0, 7, 0x02, "AnyKey Exit");
			api_kbWaitOneKey();
			break;				
		}
	}
	
//	return 0;
}


void api_MenuWifi_SendRate(void)
{
	int i32Ret = -1;
	char cSendBuff[1024];
	char cRecvBuff[1024];
	int iSuccT = 0;
	int iSuccR = 0;
	int iSum = 0;
	unsigned char ucKey = 0xFF;
	unsigned int uiTimeStart = 0;
	unsigned int uiTimeStart1 = 0;
	unsigned int uiTimeEnd = 0;
	
	
	memset(cSendBuff, 'A', sizeof(cSendBuff));
	memset(cRecvBuff, 0x00, sizeof(cRecvBuff));

/*建立TCP连接*/
	api_scrClrLine(3,9);
	api_scrPrint(0, 3, 0x02, "IP:192.168.65.56");
	api_scrPrint(0, 4, 0x02, "Port:60000");
	api_scrPrint(0, 5, 0x02, "Connect...."); 	
	i32Ret = wifiCommConnect_lib("TCP", "192.168.65.56", "60000", 10000);
	if(i32Ret < 0)
	{
		if(i32Ret == WIFI_TCP_CONNECTED)
		{
			wifiCommClose_lib();
		}
		api_scrPrint(0, 6, 0x00, "TCP Connect Err: %d", i32Ret);
		api_scrPrint(0, 7, 0x02, "AnyKey Exit");
		api_kbWaitOneKey();	
		
		return ;
	}
	
	api_scrClrLine(5,5);
	api_scrPrint(0, 5, 0x02, "Connect OK"); 
	
	while(1)
	{
		uiTimeStart = dev_getSysTicks();
		
		for(iSum = 0; iSum < (2048); iSum++)
		{
			i32Ret = wifiCommSendData_lib(cSendBuff, 1024, 1000, 1);
			if(i32Ret == 0)
			{
				iSuccT += 1;
			}		
		}
		
		uiTimeEnd = dev_getSysTicks();
		
		api_scrPrint(0, 6, 0x00, "Rate: %d B/s", ((2048*1024)*1000)/(uiTimeEnd - uiTimeStart));
		api_scrPrint(0, 7, 0x02, "Enter Continue");
		while(1)
		{
			if(0 == api_kbHit())
			{
				ucKey = api_kbGetKey();
				if(KEYCANCEL == ucKey)
				{
					wifiCommClose_lib();
					return ;
				}
				else
				{
					break;
				}
			}
		}		
	}
	
//	return 0;
}


void api_MenuWifi_RecvRate(void)
{
	int i32Ret = -1;
	char cSendBuff[1024];
	char cRecvBuff[1024];
	int iSuccT = 0;
	int iSuccR = 0;
	int iSum = 0;
	unsigned char ucKey = 0xFF;
	unsigned int uiTimeStart = 0;
	unsigned int uiTime = 0;
	unsigned int uiTimeEnd = 0;
	
	memset(cSendBuff, 'A', sizeof(cSendBuff));
	memset(cRecvBuff, 0x00, sizeof(cRecvBuff));

/*建立TCP连接*/
	api_scrClrLine(3,9);
	api_scrPrint(0, 3, 0x02, "IP:103.235.231.21");
	api_scrPrint(0, 4, 0x02, "Port:3000");
	api_scrPrint(0, 5, 0x02, "Connect...."); 	
	i32Ret = wifiCommConnect_lib("TCP", "103.235.231.21", "3000", 10000);
	if(i32Ret < 0)
	{
		if(i32Ret == WIFI_TCP_CONNECTED)
		{
			wifiCommClose_lib();
		}
		api_scrPrint(0, 6, 0x00, "TCP Connect Err: %d", i32Ret);
		api_scrPrint(0, 7, 0x02, "AnyKey Exit");
		api_kbWaitOneKey();	
		
		return ;
	}
	
	api_scrClrLine(5,5);
	api_scrPrint(0, 5, 0x02, "Connect OK"); 
	
	while(1)
	{
		for(iSum = 0; iSum < (2048); iSum++)
		{
			i32Ret = wifiCommSendData_lib(cSendBuff, 1024, 3000, 1);

			uiTimeStart = dev_getSysTicks();
			
			i32Ret = wifiWaitData_lib((char*)(cRecvBuff), 1024, 3000);
			if(i32Ret < 0)
			{
				api_scrClrLine(3,4);
				api_scrPrint(0, 4, 0x02, "Recv %d", i32Ret);
				while(1)
				{
					if((0 == api_kbHit()) && (KEYCANCEL == api_kbGetKey()))
					{
						return ;
					}
				}										
			}
			
			uiTimeEnd = dev_getSysTicks();
			api_scrClrLine(6,6);
			api_scrPrint(0, 6, 0x00, "Rate: %d B/s", ((1024)*1000)/(uiTimeEnd - uiTimeStart));
		}
		
		api_scrPrint(0, 7, 0x02, "Enter Continue");
		while(1)
		{
			if(0 == api_kbHit())
			{
				ucKey = api_kbGetKey();
				if(KEYCANCEL == ucKey)
				{
					wifiCommClose_lib();
					return ;
				}
				else
				{
					break;
				}
			}
		}		
	}
	
//	return 0;
}

void api_MenuWifi_Version(void)
{
	char acBuff[256];
	int i32Ret = 0;
	 
	memset(acBuff, 0x00, sizeof(acBuff));
	
	api_scrClrLine(2,9);
	
	i32Ret = wifiReadVersion_lib(acBuff, sizeof(acBuff), 3000);
	if(i32Ret < 0)
	{
		api_scrPrint(0, 7, 0x02, "GetVersion Fail %d", i32Ret);
	}
	else
	{
		api_scrPrint(0, 2, 0x00, "%s", acBuff);
	}	

	api_kbWaitOneKey();	

//	return 0;
}

void api_MenuWifi_Ap(void)
{
	int i32Ret = -1;
	ST_AP_INFO stAp;
	api_scrClrLine(2,9);
	
	api_scrPrint(0, 3, 0x02, "Scan And Connect AP");
	i32Ret = 30;
    hal_userTimerSet(TIMER_EVENT_WIFI, 300);  
	while(0 != hal_userTimerCheck(TIMER_EVENT_WIFI))	
	{
		if((2 == wifiGetLinkStatus_lib()) || (4 == wifiGetLinkStatus_lib()))
		{
			break;
		}

		api_scrClrLine(5,5);
		api_scrPrint(0, 5, 0x02, "%ds", i32Ret--);

		delay_ms(1000);
	}

	api_scrClrLine(3,5);
	memset(&stAp, 0x00, sizeof(stAp));
	i32Ret = wifiCheck_lib(&stAp);
	if(i32Ret > 0)
	{
		api_scrPrint(0, 4, 0x02, "Ap: %s", stAp.cSsid);

		hal_scrSelectIcon(WIFI_ICON, i32Ret);
	}
	else
	{
		api_scrPrint(0, 4, 0x02, "No Ap");
	}

	api_kbWaitOneKey();	

//	return 0;
}

void api_MenuWifi_Domain(void)
{
	int i32Ret = -1;
	char cRecvBuff[20];
	
	api_scrClrLine(2, 9);
	api_scrPrint(0, 4, 0x02, "www.baidu.com");

	memset(cRecvBuff, 0x00, sizeof(cRecvBuff));
	
	i32Ret = wifiCtrl_lib(eCmdDomainToIP, "www.baidu.com", strlen("www.baidu.com"), cRecvBuff, sizeof(cRecvBuff));

//	memset(cRecvBuff, 0x00, sizeof(cRecvBuff));

	api_scrPrint(0, 6, 0x02, "%s", cRecvBuff);

	api_kbWaitOneKey();	
}

void api_MenuWifi_NetTime(void)
{

	unsigned char ucKey = 0xFF;	
	unsigned char iGmtx = 8;
	int i32Ret = 0;
	unsigned char timeAsc[16];
	unsigned char aucTime[16];
	char ucNtp[64];
	api_scrClrLine(2, 9);
	
	api_sCLcdPrint(0, 2, 0, "1.时区", "1.The Time Zone");
	api_scrPrint(0,2,4,"%d", iGmtx);

	
	api_sCLcdPrint(0, 3, 0, "2.时间服务器", "2.NTP");
	api_scrPrint(0,3,4,"ntp.ntsc.ac.cn");

	memset(ucNtp, 0x00,  sizeof(ucNtp));

	ucNtp[0] = 14;
	memcpy(ucNtp+1, "ntp.ntsc.ac.cn", 14);
	ucNtp[15] = iGmtx;
	
	memset(timeAsc, 0x00,  sizeof(timeAsc));
	memset(aucTime, 0x00,  sizeof(aucTime));
	
	api_sysGetTime(aucTime, 8);
	timeAsc[0] = BcdToLong(&aucTime[0] , 1);
	timeAsc[1] = BcdToLong(&aucTime[1] , 1);
	timeAsc[2] = BcdToLong(&aucTime[2] , 1);
	timeAsc[3] = BcdToLong(&aucTime[3] , 1);
	timeAsc[4] = BcdToLong(&aucTime[4] , 1);
    timeAsc[5] = BcdToLong(&aucTime[5] , 1);

	api_scrPrint(0,4,0x00,"Before:");
	api_scrPrint(0,5,0x00|LCD_LEFT_ALIGN,"20%02d-%02d-%02d %02d:%02d:%02d\n",timeAsc[0],timeAsc[1],timeAsc[2],timeAsc[3],timeAsc[4],timeAsc[5]);
	
//	i32Ret = wifiCtrl_lib(eCmdNetTime, ucNtp,sizeof(ucNtp),NULL,0);
	i32Ret = wifiCtrl_lib(eCmdNetTime, NULL,0,NULL,0);
	if(i32Ret < 0)
	{
		api_scrPrint(0,8,0x00,"ERR: %d",i32Ret);
		api_kbWaitOneKey();	
		return;
	}

	memset(timeAsc, 0x00,  sizeof(timeAsc));
	memset(aucTime, 0x00,  sizeof(aucTime));

	api_sysGetTime(aucTime, 8);
	timeAsc[0] = BcdToLong(&aucTime[0] , 1);
	timeAsc[1] = BcdToLong(&aucTime[1] , 1);
	timeAsc[2] = BcdToLong(&aucTime[2] , 1);
	timeAsc[3] = BcdToLong(&aucTime[3] , 1);
	timeAsc[4] = BcdToLong(&aucTime[4] , 1);
	timeAsc[5] = BcdToLong(&aucTime[5] , 1);

	api_scrPrint(0,7,0x00,"After:");
	api_scrPrint(0,8,0x00|LCD_LEFT_ALIGN,"20%02d-%02d-%02d %02d:%02d:%02d\n",timeAsc[0],timeAsc[1],timeAsc[2],timeAsc[3],timeAsc[4],timeAsc[5]);

	api_kbWaitOneKey();	
}

void api_MenuWifi_ClearSetting(void)
{
	unsigned char ucKey = 0xFF;
	int i32Ret = 0;
	
	api_scrClrLine(2, 9);
	
	api_sCLcdPrint(0, 2, 2, "请再次确认?", "Please confirm again ?");
	
	while(1)
	{
		ucKey = api_kbGetKey();
		if(ucKey == KEYENTER)
		{
			break;
		}
	}
	
	api_scrClrLine(2, 2);
	i32Ret = hal_wifiAtRESTORE();
	if(i32Ret == 0)
	{
		wifiClose_lib();
		
		delay_ms(3000);
		
		i32Ret = wifiOpen_lib();

		api_scrClrLine(2, 4);
		
		if(0 == i32Ret)
		{
			api_sCLcdPrint(0, 3, 2, "恢复出厂设置成功", "Restore Succ");
		}
		else
		{
			api_sCLcdPrint(0, 3, 0, "重新打开失败", "Open FAIL");
			
			api_scrPrint(0, 4, 0,"2.ERR: %d",i32Ret);
		}	
	}
	else
	{
		api_sCLcdPrint(0, 3, 0, "恢复出厂设置失败", "Restore FAIL");
		api_scrPrint(0, 4, 0,"1. ERR: %d",i32Ret);
	}
	
	api_kbWaitOneKey();	
}

int api_MenuWifi(void)
{
	int i32Ret = -1;
	ST_AP_INFO stAp;
	unsigned char ucKey = 0xFF;
	int iLoopOut = 0;
	char ucDns0[20];
	char ucDns1[20];
	int iSize = 0xFF;
	ST_WIFI_PARAM stWifiParam;

    api_scrCls(LCD_COLOR_WHITE);
    
    hal_scrSetMenuTitle("WLAN");

	char English[100];
	memset(English, 0x00, sizeof(English));
	
	memcpy(English, "ESP8266", 7);
	
	STMENUNODE astMenu[] = {
		{ English,	English, NoFun },
		{ "选取网络    ", "Choose a network", api_MenuWifi_Scan_ConnectAp},
		{ "TCP通讯测试 ", "TCP             ", api_MenuWifi_TCP},
		{ "固件版本    ", "Version         ", api_MenuWifi_Version},
		{ "已连接热点  ", "Ap              ", api_MenuWifi_Ap},
		{ "域名解析    ", "Domain          ", api_MenuWifi_Domain},
		{ "网络时间同步", "Net Time        ", api_MenuWifi_NetTime},
//		{ "网络配置   ", "IP			  ", api_MenuWifi_ConfigIP}
		{ "恢复出厂设置", "Clear Setting   ",  api_MenuWifi_ClearSetting},
	};

	iSize = sizeof(astMenu) / sizeof(STMENUNODE);
	
	api_scrPrint(0, 3, 0x02, "Open...");
	
    i32Ret = wifiOpen_lib();
    if(0 == i32Ret)
    {
		Menu_ShowHiddenMenu(astMenu, iSize, (iSize-1)-3);
    }
	else
	{
		api_scrPrint(0, 3, 0x02, "Wifi Open Err:%d", i32Ret);

		api_kbWaitOneKey();
	}

	wifiClose_lib();
/*
	1.上电自动连接
	2.IP设置方式(手动或者自动)
	3.DNS配置方式(默认或者自定义)
*/	
	return 0;
}

#endif

#if 0    //amazon

const unsigned char client_ca[0x4B0] = {
  0xF1, 0xF1, 0x01, 0x00, 0xA8, 0x04, 0x00, 0x00, 0x02, 0x00, 0xA3, 0x04, 0x2D, 0x2D, 0x2D, 0x2D,
  0x2D, 0x42, 0x45, 0x47, 0x49, 0x4E, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46, 0x49, 0x43, 0x41,
  0x54, 0x45, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x0A, 0x4D, 0x49, 0x49, 0x44, 0x51, 0x54, 0x43, 0x43,
  0x41, 0x69, 0x6D, 0x67, 0x41, 0x77, 0x49, 0x42, 0x41, 0x67, 0x49, 0x54, 0x42, 0x6D, 0x79, 0x66,
  0x7A, 0x35, 0x6D, 0x2F, 0x6A, 0x41, 0x6F, 0x35, 0x34, 0x76, 0x42, 0x34, 0x69, 0x6B, 0x50, 0x6D,
  0x6C, 0x6A, 0x5A, 0x62, 0x79, 0x6A, 0x41, 0x4E, 0x42, 0x67, 0x6B, 0x71, 0x68, 0x6B, 0x69, 0x47,
  0x39, 0x77, 0x30, 0x42, 0x41, 0x51, 0x73, 0x46, 0x0A, 0x41, 0x44, 0x41, 0x35, 0x4D, 0x51, 0x73,
  0x77, 0x43, 0x51, 0x59, 0x44, 0x56, 0x51, 0x51, 0x47, 0x45, 0x77, 0x4A, 0x56, 0x55, 0x7A, 0x45,
  0x50, 0x4D, 0x41, 0x30, 0x47, 0x41, 0x31, 0x55, 0x45, 0x43, 0x68, 0x4D, 0x47, 0x51, 0x57, 0x31,
  0x68, 0x65, 0x6D, 0x39, 0x75, 0x4D, 0x52, 0x6B, 0x77, 0x46, 0x77, 0x59, 0x44, 0x56, 0x51, 0x51,
  0x44, 0x45, 0x78, 0x42, 0x42, 0x62, 0x57, 0x46, 0x36, 0x0A, 0x62, 0x32, 0x34, 0x67, 0x55, 0x6D,
  0x39, 0x76, 0x64, 0x43, 0x42, 0x44, 0x51, 0x53, 0x41, 0x78, 0x4D, 0x42, 0x34, 0x58, 0x44, 0x54,
  0x45, 0x31, 0x4D, 0x44, 0x55, 0x79, 0x4E, 0x6A, 0x41, 0x77, 0x4D, 0x44, 0x41, 0x77, 0x4D, 0x46,
  0x6F, 0x58, 0x44, 0x54, 0x4D, 0x34, 0x4D, 0x44, 0x45, 0x78, 0x4E, 0x7A, 0x41, 0x77, 0x4D, 0x44,
  0x41, 0x77, 0x4D, 0x46, 0x6F, 0x77, 0x4F, 0x54, 0x45, 0x4C, 0x0A, 0x4D, 0x41, 0x6B, 0x47, 0x41,
  0x31, 0x55, 0x45, 0x42, 0x68, 0x4D, 0x43, 0x56, 0x56, 0x4D, 0x78, 0x44, 0x7A, 0x41, 0x4E, 0x42,
  0x67, 0x4E, 0x56, 0x42, 0x41, 0x6F, 0x54, 0x42, 0x6B, 0x46, 0x74, 0x59, 0x58, 0x70, 0x76, 0x62,
  0x6A, 0x45, 0x5A, 0x4D, 0x42, 0x63, 0x47, 0x41, 0x31, 0x55, 0x45, 0x41, 0x78, 0x4D, 0x51, 0x51,
  0x57, 0x31, 0x68, 0x65, 0x6D, 0x39, 0x75, 0x49, 0x46, 0x4A, 0x76, 0x0A, 0x62, 0x33, 0x51, 0x67,
  0x51, 0x30, 0x45, 0x67, 0x4D, 0x54, 0x43, 0x43, 0x41, 0x53, 0x49, 0x77, 0x44, 0x51, 0x59, 0x4A,
  0x4B, 0x6F, 0x5A, 0x49, 0x68, 0x76, 0x63, 0x4E, 0x41, 0x51, 0x45, 0x42, 0x42, 0x51, 0x41, 0x44,
  0x67, 0x67, 0x45, 0x50, 0x41, 0x44, 0x43, 0x43, 0x41, 0x51, 0x6F, 0x43, 0x67, 0x67, 0x45, 0x42,
  0x41, 0x4C, 0x4A, 0x34, 0x67, 0x48, 0x48, 0x4B, 0x65, 0x4E, 0x58, 0x6A, 0x0A, 0x63, 0x61, 0x39,
  0x48, 0x67, 0x46, 0x42, 0x30, 0x66, 0x57, 0x37, 0x59, 0x31, 0x34, 0x68, 0x32, 0x39, 0x4A, 0x6C,
  0x6F, 0x39, 0x31, 0x67, 0x68, 0x59, 0x50, 0x6C, 0x30, 0x68, 0x41, 0x45, 0x76, 0x72, 0x41, 0x49,
  0x74, 0x68, 0x74, 0x4F, 0x67, 0x51, 0x33, 0x70, 0x4F, 0x73, 0x71, 0x54, 0x51, 0x4E, 0x72, 0x6F,
  0x42, 0x76, 0x6F, 0x33, 0x62, 0x53, 0x4D, 0x67, 0x48, 0x46, 0x7A, 0x5A, 0x4D, 0x0A, 0x39, 0x4F,
  0x36, 0x49, 0x49, 0x38, 0x63, 0x2B, 0x36, 0x7A, 0x66, 0x31, 0x74, 0x52, 0x6E, 0x34, 0x53, 0x57,
  0x69, 0x77, 0x33, 0x74, 0x65, 0x35, 0x64, 0x6A, 0x67, 0x64, 0x59, 0x5A, 0x36, 0x6B, 0x2F, 0x6F,
  0x49, 0x32, 0x70, 0x65, 0x56, 0x4B, 0x56, 0x75, 0x52, 0x46, 0x34, 0x66, 0x6E, 0x39, 0x74, 0x42,
  0x62, 0x36, 0x64, 0x4E, 0x71, 0x63, 0x6D, 0x7A, 0x55, 0x35, 0x4C, 0x2F, 0x71, 0x77, 0x0A, 0x49,
  0x46, 0x41, 0x47, 0x62, 0x48, 0x72, 0x51, 0x67, 0x4C, 0x4B, 0x6D, 0x2B, 0x61, 0x2F, 0x73, 0x52,
  0x78, 0x6D, 0x50, 0x55, 0x44, 0x67, 0x48, 0x33, 0x4B, 0x4B, 0x48, 0x4F, 0x56, 0x6A, 0x34, 0x75,
  0x74, 0x57, 0x70, 0x2B, 0x55, 0x68, 0x6E, 0x4D, 0x4A, 0x62, 0x75, 0x6C, 0x48, 0x68, 0x65, 0x62,
  0x34, 0x6D, 0x6A, 0x55, 0x63, 0x41, 0x77, 0x68, 0x6D, 0x61, 0x68, 0x52, 0x57, 0x61, 0x36, 0x0A,
  0x56, 0x4F, 0x75, 0x6A, 0x77, 0x35, 0x48, 0x35, 0x53, 0x4E, 0x7A, 0x2F, 0x30, 0x65, 0x67, 0x77,
  0x4C, 0x58, 0x30, 0x74, 0x64, 0x48, 0x41, 0x31, 0x31, 0x34, 0x67, 0x6B, 0x39, 0x35, 0x37, 0x45,
  0x57, 0x57, 0x36, 0x37, 0x63, 0x34, 0x63, 0x58, 0x38, 0x6A, 0x4A, 0x47, 0x4B, 0x4C, 0x68, 0x44,
  0x2B, 0x72, 0x63, 0x64, 0x71, 0x73, 0x71, 0x30, 0x38, 0x70, 0x38, 0x6B, 0x44, 0x69, 0x31, 0x4C,
  0x0A, 0x39, 0x33, 0x46, 0x63, 0x58, 0x6D, 0x6E, 0x2F, 0x36, 0x70, 0x55, 0x43, 0x79, 0x7A, 0x69,
  0x4B, 0x72, 0x6C, 0x41, 0x34, 0x62, 0x39, 0x76, 0x37, 0x4C, 0x57, 0x49, 0x62, 0x78, 0x63, 0x63,
  0x65, 0x56, 0x4F, 0x46, 0x33, 0x34, 0x47, 0x66, 0x49, 0x44, 0x35, 0x79, 0x48, 0x49, 0x39, 0x59,
  0x2F, 0x51, 0x43, 0x42, 0x2F, 0x49, 0x49, 0x44, 0x45, 0x67, 0x45, 0x77, 0x2B, 0x4F, 0x79, 0x51,
  0x6D, 0x0A, 0x6A, 0x67, 0x53, 0x75, 0x62, 0x4A, 0x72, 0x49, 0x71, 0x67, 0x30, 0x43, 0x41, 0x77,
  0x45, 0x41, 0x41, 0x61, 0x4E, 0x43, 0x4D, 0x45, 0x41, 0x77, 0x44, 0x77, 0x59, 0x44, 0x56, 0x52,
  0x30, 0x54, 0x41, 0x51, 0x48, 0x2F, 0x42, 0x41, 0x55, 0x77, 0x41, 0x77, 0x45, 0x42, 0x2F, 0x7A,
  0x41, 0x4F, 0x42, 0x67, 0x4E, 0x56, 0x48, 0x51, 0x38, 0x42, 0x41, 0x66, 0x38, 0x45, 0x42, 0x41,
  0x4D, 0x43, 0x0A, 0x41, 0x59, 0x59, 0x77, 0x48, 0x51, 0x59, 0x44, 0x56, 0x52, 0x30, 0x4F, 0x42,
  0x42, 0x59, 0x45, 0x46, 0x49, 0x51, 0x59, 0x7A, 0x49, 0x55, 0x30, 0x37, 0x4C, 0x77, 0x4D, 0x6C,
  0x4A, 0x51, 0x75, 0x43, 0x46, 0x6D, 0x63, 0x78, 0x37, 0x49, 0x51, 0x54, 0x67, 0x6F, 0x49, 0x4D,
  0x41, 0x30, 0x47, 0x43, 0x53, 0x71, 0x47, 0x53, 0x49, 0x62, 0x33, 0x44, 0x51, 0x45, 0x42, 0x43,
  0x77, 0x55, 0x41, 0x0A, 0x41, 0x34, 0x49, 0x42, 0x41, 0x51, 0x43, 0x59, 0x38, 0x6A, 0x64, 0x61,
  0x51, 0x5A, 0x43, 0x68, 0x47, 0x73, 0x56, 0x32, 0x55, 0x53, 0x67, 0x67, 0x4E, 0x69, 0x4D, 0x4F,
  0x72, 0x75, 0x59, 0x6F, 0x75, 0x36, 0x72, 0x34, 0x6C, 0x4B, 0x35, 0x49, 0x70, 0x44, 0x42, 0x2F,
  0x47, 0x2F, 0x77, 0x6B, 0x6A, 0x55, 0x75, 0x30, 0x79, 0x4B, 0x47, 0x58, 0x39, 0x72, 0x62, 0x78,
  0x65, 0x6E, 0x44, 0x49, 0x0A, 0x55, 0x35, 0x50, 0x4D, 0x43, 0x43, 0x6A, 0x6A, 0x6D, 0x43, 0x58,
  0x50, 0x49, 0x36, 0x54, 0x35, 0x33, 0x69, 0x48, 0x54, 0x66, 0x49, 0x55, 0x4A, 0x72, 0x55, 0x36,
  0x61, 0x64, 0x54, 0x72, 0x43, 0x43, 0x32, 0x71, 0x4A, 0x65, 0x48, 0x5A, 0x45, 0x52, 0x78, 0x68,
  0x6C, 0x62, 0x49, 0x31, 0x42, 0x6A, 0x6A, 0x74, 0x2F, 0x6D, 0x73, 0x76, 0x30, 0x74, 0x61, 0x64,
  0x51, 0x31, 0x77, 0x55, 0x73, 0x0A, 0x4E, 0x2B, 0x67, 0x44, 0x53, 0x36, 0x33, 0x70, 0x59, 0x61,
  0x41, 0x43, 0x62, 0x76, 0x58, 0x79, 0x38, 0x4D, 0x57, 0x79, 0x37, 0x56, 0x75, 0x33, 0x33, 0x50,
  0x71, 0x55, 0x58, 0x48, 0x65, 0x65, 0x45, 0x36, 0x56, 0x2F, 0x55, 0x71, 0x32, 0x56, 0x38, 0x76,
  0x69, 0x54, 0x4F, 0x39, 0x36, 0x4C, 0x58, 0x46, 0x76, 0x4B, 0x57, 0x6C, 0x4A, 0x62, 0x59, 0x4B,
  0x38, 0x55, 0x39, 0x30, 0x76, 0x76, 0x0A, 0x6F, 0x2F, 0x75, 0x66, 0x51, 0x4A, 0x56, 0x74, 0x4D,
  0x56, 0x54, 0x38, 0x51, 0x74, 0x50, 0x48, 0x52, 0x68, 0x38, 0x6A, 0x72, 0x64, 0x6B, 0x50, 0x53,
  0x48, 0x43, 0x61, 0x32, 0x58, 0x56, 0x34, 0x63, 0x64, 0x46, 0x79, 0x51, 0x7A, 0x52, 0x31, 0x62,
  0x6C, 0x64, 0x5A, 0x77, 0x67, 0x4A, 0x63, 0x4A, 0x6D, 0x41, 0x70, 0x7A, 0x79, 0x4D, 0x5A, 0x46,
  0x6F, 0x36, 0x49, 0x51, 0x36, 0x58, 0x55, 0x0A, 0x35, 0x4D, 0x73, 0x49, 0x2B, 0x79, 0x4D, 0x52,
  0x51, 0x2B, 0x68, 0x44, 0x4B, 0x58, 0x4A, 0x69, 0x6F, 0x61, 0x6C, 0x64, 0x58, 0x67, 0x6A, 0x55,
  0x6B, 0x4B, 0x36, 0x34, 0x32, 0x4D, 0x34, 0x55, 0x77, 0x74, 0x42, 0x56, 0x38, 0x6F, 0x62, 0x32,
  0x78, 0x4A, 0x4E, 0x44, 0x64, 0x32, 0x5A, 0x68, 0x77, 0x4C, 0x6E, 0x6F, 0x51, 0x64, 0x65, 0x58,
  0x65, 0x47, 0x41, 0x44, 0x62, 0x6B, 0x70, 0x79, 0x0A, 0x72, 0x71, 0x58, 0x52, 0x66, 0x62, 0x6F,
  0x51, 0x6E, 0x6F, 0x5A, 0x73, 0x47, 0x34, 0x71, 0x35, 0x57, 0x54, 0x50, 0x34, 0x36, 0x38, 0x53,
  0x51, 0x76, 0x76, 0x47, 0x35, 0x0A, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x45, 0x4E, 0x44, 0x20, 0x43,
  0x45, 0x52, 0x54, 0x49, 0x46, 0x49, 0x43, 0x41, 0x54, 0x45, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0xFF
};

const unsigned char client_cert[0x4D4] = {
  0xF1, 0xF1, 0x01, 0x00, 0xCC, 0x04, 0x00, 0x00, 0x02, 0x00, 0xC8, 0x04, 0x2D, 0x2D, 0x2D, 0x2D,
  0x2D, 0x42, 0x45, 0x47, 0x49, 0x4E, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46, 0x49, 0x43, 0x41,
  0x54, 0x45, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x0A, 0x4D, 0x49, 0x49, 0x44, 0x57, 0x6A, 0x43, 0x43,
  0x41, 0x6B, 0x4B, 0x67, 0x41, 0x77, 0x49, 0x42, 0x41, 0x67, 0x49, 0x56, 0x41, 0x49, 0x49, 0x48,
  0x75, 0x37, 0x62, 0x6E, 0x6B, 0x61, 0x52, 0x4F, 0x58, 0x6A, 0x61, 0x36, 0x49, 0x50, 0x58, 0x61,
  0x75, 0x65, 0x65, 0x34, 0x47, 0x32, 0x69, 0x72, 0x4D, 0x41, 0x30, 0x47, 0x43, 0x53, 0x71, 0x47,
  0x53, 0x49, 0x62, 0x33, 0x44, 0x51, 0x45, 0x42, 0x0A, 0x43, 0x77, 0x55, 0x41, 0x4D, 0x45, 0x30,
  0x78, 0x53, 0x7A, 0x42, 0x4A, 0x42, 0x67, 0x4E, 0x56, 0x42, 0x41, 0x73, 0x4D, 0x51, 0x6B, 0x46,
  0x74, 0x59, 0x58, 0x70, 0x76, 0x62, 0x69, 0x42, 0x58, 0x5A, 0x57, 0x49, 0x67, 0x55, 0x32, 0x56,
  0x79, 0x64, 0x6D, 0x6C, 0x6A, 0x5A, 0x58, 0x4D, 0x67, 0x54, 0x7A, 0x31, 0x42, 0x62, 0x57, 0x46,
  0x36, 0x62, 0x32, 0x34, 0x75, 0x59, 0x32, 0x39, 0x74, 0x0A, 0x49, 0x45, 0x6C, 0x75, 0x59, 0x79,
  0x34, 0x67, 0x54, 0x44, 0x31, 0x54, 0x5A, 0x57, 0x46, 0x30, 0x64, 0x47, 0x78, 0x6C, 0x49, 0x46,
  0x4E, 0x55, 0x50, 0x56, 0x64, 0x68, 0x63, 0x32, 0x68, 0x70, 0x62, 0x6D, 0x64, 0x30, 0x62, 0x32,
  0x34, 0x67, 0x51, 0x7A, 0x31, 0x56, 0x55, 0x7A, 0x41, 0x65, 0x46, 0x77, 0x30, 0x79, 0x4D, 0x54,
  0x45, 0x78, 0x4D, 0x44, 0x6B, 0x78, 0x4D, 0x44, 0x45, 0x32, 0x0A, 0x4D, 0x54, 0x6C, 0x61, 0x46,
  0x77, 0x30, 0x30, 0x4F, 0x54, 0x45, 0x79, 0x4D, 0x7A, 0x45, 0x79, 0x4D, 0x7A, 0x55, 0x35, 0x4E,
  0x54, 0x6C, 0x61, 0x4D, 0x42, 0x34, 0x78, 0x48, 0x44, 0x41, 0x61, 0x42, 0x67, 0x4E, 0x56, 0x42,
  0x41, 0x4D, 0x4D, 0x45, 0x30, 0x46, 0x58, 0x55, 0x79, 0x42, 0x4A, 0x62, 0x31, 0x51, 0x67, 0x51,
  0x32, 0x56, 0x79, 0x64, 0x47, 0x6C, 0x6D, 0x61, 0x57, 0x4E, 0x68, 0x0A, 0x64, 0x47, 0x55, 0x77,
  0x67, 0x67, 0x45, 0x69, 0x4D, 0x41, 0x30, 0x47, 0x43, 0x53, 0x71, 0x47, 0x53, 0x49, 0x62, 0x33,
  0x44, 0x51, 0x45, 0x42, 0x41, 0x51, 0x55, 0x41, 0x41, 0x34, 0x49, 0x42, 0x44, 0x77, 0x41, 0x77,
  0x67, 0x67, 0x45, 0x4B, 0x41, 0x6F, 0x49, 0x42, 0x41, 0x51, 0x44, 0x46, 0x49, 0x4A, 0x6D, 0x46,
  0x62, 0x76, 0x77, 0x6F, 0x79, 0x75, 0x6A, 0x4D, 0x50, 0x36, 0x6E, 0x44, 0x0A, 0x47, 0x65, 0x55,
  0x48, 0x52, 0x66, 0x43, 0x64, 0x44, 0x63, 0x68, 0x2B, 0x4C, 0x6D, 0x6D, 0x68, 0x79, 0x78, 0x51,
  0x49, 0x65, 0x32, 0x70, 0x41, 0x2F, 0x55, 0x69, 0x4E, 0x4B, 0x59, 0x44, 0x6E, 0x6E, 0x4F, 0x6D,
  0x4D, 0x63, 0x74, 0x4C, 0x31, 0x37, 0x57, 0x77, 0x6A, 0x69, 0x45, 0x62, 0x45, 0x38, 0x59, 0x6F,
  0x62, 0x6A, 0x76, 0x70, 0x6C, 0x34, 0x58, 0x76, 0x44, 0x57, 0x44, 0x6A, 0x52, 0x0A, 0x58, 0x52,
  0x4F, 0x61, 0x6B, 0x44, 0x62, 0x68, 0x31, 0x6E, 0x6D, 0x64, 0x73, 0x4E, 0x67, 0x4F, 0x50, 0x58,
  0x71, 0x4F, 0x52, 0x79, 0x78, 0x76, 0x7A, 0x61, 0x31, 0x30, 0x6F, 0x75, 0x65, 0x56, 0x56, 0x61,
  0x44, 0x79, 0x39, 0x38, 0x5A, 0x41, 0x4A, 0x64, 0x31, 0x6E, 0x30, 0x31, 0x51, 0x6F, 0x63, 0x61,
  0x51, 0x41, 0x52, 0x38, 0x6C, 0x38, 0x4B, 0x35, 0x70, 0x33, 0x78, 0x76, 0x70, 0x37, 0x0A, 0x59,
  0x65, 0x7A, 0x62, 0x30, 0x58, 0x5A, 0x51, 0x66, 0x46, 0x39, 0x67, 0x41, 0x56, 0x79, 0x61, 0x64,
  0x37, 0x62, 0x57, 0x44, 0x2B, 0x36, 0x55, 0x6F, 0x52, 0x45, 0x6E, 0x52, 0x52, 0x4F, 0x53, 0x46,
  0x6E, 0x79, 0x64, 0x32, 0x61, 0x76, 0x2B, 0x4D, 0x39, 0x32, 0x72, 0x55, 0x75, 0x34, 0x56, 0x35,
  0x51, 0x71, 0x32, 0x38, 0x2F, 0x4A, 0x79, 0x42, 0x6A, 0x74, 0x36, 0x6D, 0x31, 0x2B, 0x51, 0x0A,
  0x5A, 0x57, 0x65, 0x50, 0x53, 0x6E, 0x2F, 0x6F, 0x75, 0x56, 0x32, 0x42, 0x4D, 0x58, 0x64, 0x4C,
  0x36, 0x7A, 0x47, 0x64, 0x55, 0x78, 0x75, 0x6C, 0x67, 0x30, 0x2F, 0x41, 0x34, 0x55, 0x4F, 0x70,
  0x79, 0x4E, 0x45, 0x4F, 0x6C, 0x44, 0x77, 0x76, 0x62, 0x43, 0x70, 0x57, 0x43, 0x33, 0x67, 0x51,
  0x56, 0x36, 0x6B, 0x58, 0x6D, 0x76, 0x70, 0x71, 0x34, 0x4C, 0x54, 0x68, 0x53, 0x4A, 0x55, 0x57,
  0x0A, 0x79, 0x47, 0x32, 0x35, 0x6B, 0x65, 0x33, 0x38, 0x35, 0x69, 0x52, 0x6C, 0x67, 0x6C, 0x6D,
  0x69, 0x57, 0x59, 0x75, 0x4B, 0x44, 0x6C, 0x59, 0x39, 0x68, 0x59, 0x50, 0x4A, 0x32, 0x2B, 0x71,
  0x6D, 0x48, 0x53, 0x52, 0x34, 0x41, 0x4F, 0x75, 0x53, 0x66, 0x39, 0x76, 0x65, 0x57, 0x69, 0x71,
  0x6F, 0x6B, 0x50, 0x5A, 0x54, 0x30, 0x6A, 0x55, 0x46, 0x4D, 0x66, 0x51, 0x61, 0x72, 0x6E, 0x39,
  0x31, 0x0A, 0x47, 0x58, 0x70, 0x44, 0x41, 0x67, 0x4D, 0x42, 0x41, 0x41, 0x47, 0x6A, 0x59, 0x44,
  0x42, 0x65, 0x4D, 0x42, 0x38, 0x47, 0x41, 0x31, 0x55, 0x64, 0x49, 0x77, 0x51, 0x59, 0x4D, 0x42,
  0x61, 0x41, 0x46, 0x4D, 0x74, 0x63, 0x2B, 0x33, 0x62, 0x4D, 0x51, 0x46, 0x64, 0x58, 0x4D, 0x2B,
  0x6E, 0x6A, 0x42, 0x33, 0x37, 0x78, 0x35, 0x47, 0x34, 0x36, 0x33, 0x77, 0x4B, 0x2F, 0x4D, 0x42,
  0x30, 0x47, 0x0A, 0x41, 0x31, 0x55, 0x64, 0x44, 0x67, 0x51, 0x57, 0x42, 0x42, 0x51, 0x63, 0x2B,
  0x32, 0x76, 0x31, 0x33, 0x57, 0x31, 0x43, 0x79, 0x7A, 0x6F, 0x33, 0x34, 0x6C, 0x58, 0x41, 0x33,
  0x32, 0x33, 0x6A, 0x30, 0x59, 0x2B, 0x55, 0x46, 0x44, 0x41, 0x4D, 0x42, 0x67, 0x4E, 0x56, 0x48,
  0x52, 0x4D, 0x42, 0x41, 0x66, 0x38, 0x45, 0x41, 0x6A, 0x41, 0x41, 0x4D, 0x41, 0x34, 0x47, 0x41,
  0x31, 0x55, 0x64, 0x0A, 0x44, 0x77, 0x45, 0x42, 0x2F, 0x77, 0x51, 0x45, 0x41, 0x77, 0x49, 0x48,
  0x67, 0x44, 0x41, 0x4E, 0x42, 0x67, 0x6B, 0x71, 0x68, 0x6B, 0x69, 0x47, 0x39, 0x77, 0x30, 0x42,
  0x41, 0x51, 0x73, 0x46, 0x41, 0x41, 0x4F, 0x43, 0x41, 0x51, 0x45, 0x41, 0x4E, 0x50, 0x68, 0x32,
  0x76, 0x7A, 0x5A, 0x59, 0x58, 0x41, 0x4F, 0x53, 0x50, 0x67, 0x54, 0x2B, 0x62, 0x44, 0x4C, 0x39,
  0x6C, 0x42, 0x55, 0x46, 0x0A, 0x69, 0x37, 0x76, 0x69, 0x67, 0x53, 0x70, 0x6A, 0x30, 0x69, 0x53,
  0x54, 0x66, 0x35, 0x32, 0x65, 0x61, 0x4E, 0x5A, 0x63, 0x6E, 0x7A, 0x79, 0x71, 0x76, 0x43, 0x56,
  0x37, 0x38, 0x6C, 0x54, 0x54, 0x50, 0x36, 0x77, 0x74, 0x48, 0x64, 0x67, 0x31, 0x70, 0x78, 0x6B,
  0x50, 0x37, 0x52, 0x62, 0x48, 0x50, 0x46, 0x77, 0x4E, 0x32, 0x59, 0x6C, 0x65, 0x6E, 0x46, 0x65,
  0x59, 0x50, 0x41, 0x4F, 0x42, 0x0A, 0x5A, 0x69, 0x31, 0x57, 0x4D, 0x79, 0x34, 0x44, 0x76, 0x47,
  0x57, 0x44, 0x32, 0x55, 0x71, 0x51, 0x56, 0x2B, 0x42, 0x34, 0x38, 0x61, 0x58, 0x5A, 0x74, 0x32,
  0x61, 0x45, 0x6B, 0x65, 0x33, 0x4A, 0x6B, 0x51, 0x33, 0x70, 0x33, 0x32, 0x48, 0x4D, 0x78, 0x78,
  0x39, 0x78, 0x68, 0x49, 0x56, 0x4D, 0x61, 0x59, 0x57, 0x68, 0x48, 0x57, 0x62, 0x77, 0x44, 0x55,
  0x54, 0x47, 0x45, 0x2F, 0x42, 0x57, 0x0A, 0x72, 0x58, 0x67, 0x4A, 0x68, 0x4D, 0x30, 0x6A, 0x75,
  0x39, 0x42, 0x6B, 0x2B, 0x6E, 0x5A, 0x6F, 0x2F, 0x74, 0x74, 0x50, 0x50, 0x39, 0x70, 0x73, 0x42,
  0x31, 0x78, 0x5A, 0x55, 0x78, 0x70, 0x64, 0x6A, 0x65, 0x30, 0x32, 0x78, 0x78, 0x38, 0x59, 0x78,
  0x35, 0x57, 0x6E, 0x4E, 0x75, 0x45, 0x4E, 0x4E, 0x61, 0x51, 0x6D, 0x5A, 0x4B, 0x57, 0x47, 0x36,
  0x4B, 0x47, 0x66, 0x79, 0x7A, 0x4C, 0x6C, 0x0A, 0x44, 0x68, 0x4A, 0x6C, 0x31, 0x70, 0x4C, 0x41,
  0x4E, 0x73, 0x30, 0x50, 0x76, 0x35, 0x70, 0x7A, 0x68, 0x55, 0x4E, 0x71, 0x36, 0x57, 0x52, 0x43,
  0x44, 0x48, 0x61, 0x6A, 0x47, 0x6C, 0x64, 0x6F, 0x56, 0x76, 0x6D, 0x6C, 0x4D, 0x61, 0x62, 0x78,
  0x6C, 0x2B, 0x53, 0x32, 0x63, 0x49, 0x36, 0x35, 0x54, 0x34, 0x31, 0x4B, 0x44, 0x4F, 0x74, 0x78,
  0x52, 0x41, 0x76, 0x48, 0x72, 0x2F, 0x44, 0x53, 0x0A, 0x56, 0x62, 0x75, 0x52, 0x37, 0x48, 0x33,
  0x37, 0x64, 0x32, 0x72, 0x4D, 0x74, 0x62, 0x35, 0x54, 0x70, 0x78, 0x64, 0x55, 0x6D, 0x50, 0x6A,
  0x62, 0x34, 0x79, 0x36, 0x69, 0x32, 0x68, 0x6D, 0x62, 0x66, 0x58, 0x64, 0x5A, 0x77, 0x71, 0x51,
  0x65, 0x56, 0x47, 0x61, 0x7A, 0x67, 0x67, 0x44, 0x6D, 0x4A, 0x5A, 0x52, 0x5A, 0x2F, 0x6E, 0x68,
  0x75, 0x78, 0x62, 0x6B, 0x2F, 0x56, 0x77, 0x3D, 0x3D, 0x0A, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x45,
  0x4E, 0x44, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46, 0x49, 0x43, 0x41, 0x54, 0x45, 0x2D, 0x2D,
  0x2D, 0x2D, 0x2D, 0x0A
};

const unsigned char client_key[0x698] = {
  0xF1, 0xF1, 0x01, 0x00, 0x90, 0x06, 0x00, 0x00, 0x02, 0x00, 0x8B, 0x06, 0x2D, 0x2D, 0x2D, 0x2D,
  0x2D, 0x42, 0x45, 0x47, 0x49, 0x4E, 0x20, 0x52, 0x53, 0x41, 0x20, 0x50, 0x52, 0x49, 0x56, 0x41,
  0x54, 0x45, 0x20, 0x4B, 0x45, 0x59, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x0A, 0x4D, 0x49, 0x49, 0x45,
  0x6F, 0x67, 0x49, 0x42, 0x41, 0x41, 0x4B, 0x43, 0x41, 0x51, 0x45, 0x41, 0x78, 0x53, 0x43, 0x5A,
  0x68, 0x57, 0x37, 0x38, 0x4B, 0x4D, 0x72, 0x6F, 0x7A, 0x44, 0x2B, 0x70, 0x77, 0x78, 0x6E, 0x6C,
  0x42, 0x30, 0x58, 0x77, 0x6E, 0x51, 0x33, 0x49, 0x66, 0x69, 0x35, 0x70, 0x6F, 0x63, 0x73, 0x55,
  0x43, 0x48, 0x74, 0x71, 0x51, 0x50, 0x31, 0x49, 0x6A, 0x53, 0x6D, 0x41, 0x0A, 0x35, 0x35, 0x7A,
  0x70, 0x6A, 0x48, 0x4C, 0x53, 0x39, 0x65, 0x31, 0x73, 0x49, 0x34, 0x68, 0x47, 0x78, 0x50, 0x47,
  0x4B, 0x47, 0x34, 0x37, 0x36, 0x5A, 0x65, 0x46, 0x37, 0x77, 0x31, 0x67, 0x34, 0x30, 0x56, 0x30,
  0x54, 0x6D, 0x70, 0x41, 0x32, 0x34, 0x64, 0x5A, 0x35, 0x6E, 0x62, 0x44, 0x59, 0x44, 0x6A, 0x31,
  0x36, 0x6A, 0x6B, 0x63, 0x73, 0x62, 0x38, 0x32, 0x74, 0x64, 0x4B, 0x4C, 0x6E, 0x0A, 0x6C, 0x56,
  0x57, 0x67, 0x38, 0x76, 0x66, 0x47, 0x51, 0x43, 0x58, 0x64, 0x5A, 0x39, 0x4E, 0x55, 0x4B, 0x48,
  0x47, 0x6B, 0x41, 0x45, 0x66, 0x4A, 0x66, 0x43, 0x75, 0x61, 0x64, 0x38, 0x62, 0x36, 0x65, 0x32,
  0x48, 0x73, 0x32, 0x39, 0x46, 0x32, 0x55, 0x48, 0x78, 0x66, 0x59, 0x41, 0x46, 0x63, 0x6D, 0x6E,
  0x65, 0x32, 0x31, 0x67, 0x2F, 0x75, 0x6C, 0x4B, 0x45, 0x52, 0x4A, 0x30, 0x55, 0x54, 0x0A, 0x6B,
  0x68, 0x5A, 0x38, 0x6E, 0x64, 0x6D, 0x72, 0x2F, 0x6A, 0x50, 0x64, 0x71, 0x31, 0x4C, 0x75, 0x46,
  0x65, 0x55, 0x4B, 0x74, 0x76, 0x50, 0x79, 0x63, 0x67, 0x59, 0x37, 0x65, 0x70, 0x74, 0x66, 0x6B,
  0x47, 0x56, 0x6E, 0x6A, 0x30, 0x70, 0x2F, 0x36, 0x4C, 0x6C, 0x64, 0x67, 0x54, 0x46, 0x33, 0x53,
  0x2B, 0x73, 0x78, 0x6E, 0x56, 0x4D, 0x62, 0x70, 0x59, 0x4E, 0x50, 0x77, 0x4F, 0x46, 0x44, 0x0A,
  0x71, 0x63, 0x6A, 0x52, 0x44, 0x70, 0x51, 0x38, 0x4C, 0x32, 0x77, 0x71, 0x56, 0x67, 0x74, 0x34,
  0x45, 0x46, 0x65, 0x70, 0x46, 0x35, 0x72, 0x36, 0x61, 0x75, 0x43, 0x30, 0x34, 0x55, 0x69, 0x56,
  0x46, 0x73, 0x68, 0x74, 0x75, 0x5A, 0x48, 0x74, 0x2F, 0x4F, 0x59, 0x6B, 0x5A, 0x59, 0x4A, 0x5A,
  0x6F, 0x6C, 0x6D, 0x4C, 0x69, 0x67, 0x35, 0x57, 0x50, 0x59, 0x57, 0x44, 0x79, 0x64, 0x76, 0x71,
  0x0A, 0x70, 0x68, 0x30, 0x6B, 0x65, 0x41, 0x44, 0x72, 0x6B, 0x6E, 0x2F, 0x62, 0x33, 0x6C, 0x6F,
  0x71, 0x71, 0x4A, 0x44, 0x32, 0x55, 0x39, 0x49, 0x31, 0x42, 0x54, 0x48, 0x30, 0x47, 0x71, 0x35,
  0x2F, 0x64, 0x52, 0x6C, 0x36, 0x51, 0x77, 0x49, 0x44, 0x41, 0x51, 0x41, 0x42, 0x41, 0x6F, 0x49,
  0x42, 0x41, 0x45, 0x34, 0x75, 0x52, 0x37, 0x54, 0x72, 0x39, 0x34, 0x59, 0x57, 0x4D, 0x34, 0x34,
  0x4F, 0x0A, 0x45, 0x62, 0x34, 0x58, 0x48, 0x77, 0x5A, 0x72, 0x62, 0x71, 0x70, 0x62, 0x4E, 0x52,
  0x45, 0x57, 0x52, 0x7A, 0x36, 0x72, 0x31, 0x42, 0x34, 0x70, 0x46, 0x46, 0x4D, 0x43, 0x49, 0x53,
  0x77, 0x62, 0x4D, 0x63, 0x79, 0x71, 0x4A, 0x74, 0x5A, 0x56, 0x45, 0x2B, 0x59, 0x46, 0x61, 0x38,
  0x59, 0x4C, 0x33, 0x6B, 0x56, 0x74, 0x70, 0x6D, 0x43, 0x58, 0x72, 0x43, 0x65, 0x4C, 0x37, 0x68,
  0x48, 0x6A, 0x0A, 0x67, 0x32, 0x56, 0x46, 0x6A, 0x4F, 0x6A, 0x59, 0x47, 0x57, 0x77, 0x6F, 0x4B,
  0x38, 0x4F, 0x6D, 0x78, 0x34, 0x6D, 0x65, 0x53, 0x47, 0x54, 0x31, 0x52, 0x57, 0x4A, 0x79, 0x4B,
  0x45, 0x45, 0x42, 0x2B, 0x75, 0x62, 0x33, 0x4E, 0x77, 0x59, 0x6C, 0x7A, 0x72, 0x4C, 0x53, 0x55,
  0x61, 0x56, 0x44, 0x34, 0x7A, 0x54, 0x48, 0x48, 0x55, 0x77, 0x66, 0x4C, 0x49, 0x48, 0x61, 0x71,
  0x55, 0x43, 0x6E, 0x0A, 0x34, 0x64, 0x2F, 0x64, 0x54, 0x70, 0x73, 0x2F, 0x7A, 0x37, 0x54, 0x4D,
  0x48, 0x75, 0x64, 0x73, 0x6F, 0x74, 0x57, 0x41, 0x64, 0x54, 0x73, 0x67, 0x78, 0x6E, 0x61, 0x62,
  0x57, 0x48, 0x4A, 0x34, 0x53, 0x4B, 0x6E, 0x6D, 0x30, 0x72, 0x78, 0x55, 0x31, 0x48, 0x68, 0x6F,
  0x6E, 0x35, 0x42, 0x69, 0x6B, 0x6C, 0x4C, 0x30, 0x34, 0x79, 0x30, 0x5A, 0x53, 0x58, 0x42, 0x59,
  0x73, 0x55, 0x58, 0x41, 0x0A, 0x2B, 0x73, 0x71, 0x68, 0x5A, 0x53, 0x77, 0x71, 0x35, 0x52, 0x74,
  0x66, 0x33, 0x4B, 0x36, 0x54, 0x48, 0x56, 0x51, 0x55, 0x4D, 0x6F, 0x35, 0x31, 0x44, 0x6E, 0x6C,
  0x63, 0x44, 0x30, 0x55, 0x41, 0x68, 0x33, 0x30, 0x55, 0x49, 0x71, 0x4C, 0x47, 0x30, 0x49, 0x4E,
  0x76, 0x55, 0x73, 0x57, 0x6F, 0x7A, 0x43, 0x49, 0x58, 0x44, 0x4A, 0x6A, 0x6C, 0x69, 0x4C, 0x63,
  0x4A, 0x75, 0x36, 0x4B, 0x66, 0x0A, 0x32, 0x43, 0x73, 0x75, 0x34, 0x64, 0x66, 0x68, 0x66, 0x44,
  0x58, 0x75, 0x4D, 0x71, 0x7A, 0x64, 0x79, 0x39, 0x39, 0x4A, 0x78, 0x34, 0x53, 0x4E, 0x36, 0x6E,
  0x52, 0x30, 0x74, 0x63, 0x77, 0x50, 0x4E, 0x2B, 0x44, 0x54, 0x50, 0x32, 0x5A, 0x73, 0x36, 0x64,
  0x2F, 0x76, 0x63, 0x41, 0x67, 0x4B, 0x4A, 0x44, 0x47, 0x74, 0x5A, 0x6E, 0x7A, 0x45, 0x73, 0x2B,
  0x31, 0x68, 0x4E, 0x38, 0x35, 0x4F, 0x0A, 0x74, 0x64, 0x36, 0x53, 0x35, 0x34, 0x45, 0x43, 0x67,
  0x59, 0x45, 0x41, 0x35, 0x2B, 0x72, 0x6F, 0x76, 0x45, 0x65, 0x72, 0x37, 0x72, 0x36, 0x39, 0x68,
  0x42, 0x49, 0x67, 0x57, 0x2F, 0x57, 0x39, 0x75, 0x38, 0x2F, 0x4B, 0x33, 0x56, 0x69, 0x64, 0x31,
  0x49, 0x70, 0x4E, 0x62, 0x47, 0x64, 0x2F, 0x79, 0x36, 0x4E, 0x36, 0x62, 0x31, 0x56, 0x39, 0x6A,
  0x72, 0x37, 0x74, 0x44, 0x6C, 0x66, 0x44, 0x0A, 0x4B, 0x4B, 0x33, 0x4F, 0x6D, 0x64, 0x49, 0x2F,
  0x69, 0x4C, 0x58, 0x58, 0x31, 0x37, 0x6A, 0x78, 0x39, 0x42, 0x4E, 0x47, 0x4E, 0x7A, 0x6F, 0x41,
  0x45, 0x32, 0x74, 0x2F, 0x2B, 0x6D, 0x6A, 0x54, 0x30, 0x5A, 0x33, 0x51, 0x74, 0x50, 0x71, 0x64,
  0x48, 0x59, 0x53, 0x64, 0x63, 0x78, 0x73, 0x35, 0x37, 0x41, 0x59, 0x53, 0x4A, 0x71, 0x6C, 0x72,
  0x72, 0x42, 0x72, 0x45, 0x51, 0x44, 0x54, 0x44, 0x0A, 0x61, 0x67, 0x31, 0x46, 0x4F, 0x54, 0x31,
  0x47, 0x4B, 0x2F, 0x32, 0x65, 0x5A, 0x68, 0x61, 0x78, 0x35, 0x30, 0x37, 0x2B, 0x7A, 0x73, 0x4F,
  0x79, 0x65, 0x70, 0x78, 0x74, 0x66, 0x53, 0x44, 0x30, 0x30, 0x41, 0x38, 0x41, 0x68, 0x35, 0x56,
  0x78, 0x43, 0x6F, 0x4F, 0x49, 0x6C, 0x53, 0x42, 0x6E, 0x43, 0x50, 0x45, 0x74, 0x50, 0x56, 0x6B,
  0x43, 0x67, 0x59, 0x45, 0x41, 0x32, 0x5A, 0x6A, 0x62, 0x0A, 0x5A, 0x32, 0x76, 0x38, 0x76, 0x38,
  0x75, 0x6D, 0x2B, 0x32, 0x35, 0x5A, 0x74, 0x6B, 0x45, 0x76, 0x44, 0x61, 0x6A, 0x43, 0x61, 0x33,
  0x41, 0x74, 0x74, 0x63, 0x32, 0x4B, 0x6E, 0x72, 0x58, 0x7A, 0x6E, 0x38, 0x6D, 0x6E, 0x36, 0x78,
  0x64, 0x64, 0x2F, 0x50, 0x2F, 0x55, 0x76, 0x56, 0x53, 0x63, 0x6D, 0x57, 0x61, 0x4D, 0x47, 0x57,
  0x48, 0x6B, 0x46, 0x33, 0x75, 0x41, 0x31, 0x64, 0x30, 0x53, 0x0A, 0x75, 0x55, 0x59, 0x47, 0x76,
  0x59, 0x6A, 0x59, 0x43, 0x2F, 0x76, 0x4A, 0x37, 0x67, 0x47, 0x57, 0x2B, 0x50, 0x36, 0x58, 0x4D,
  0x71, 0x30, 0x42, 0x55, 0x46, 0x32, 0x63, 0x57, 0x4A, 0x53, 0x79, 0x77, 0x6E, 0x78, 0x61, 0x62,
  0x77, 0x59, 0x48, 0x39, 0x64, 0x70, 0x33, 0x4E, 0x2F, 0x38, 0x5A, 0x37, 0x31, 0x2F, 0x71, 0x75,
  0x76, 0x51, 0x2B, 0x53, 0x55, 0x56, 0x5A, 0x42, 0x33, 0x6A, 0x33, 0x0A, 0x45, 0x74, 0x79, 0x34,
  0x73, 0x47, 0x45, 0x4F, 0x32, 0x68, 0x70, 0x4E, 0x78, 0x39, 0x73, 0x41, 0x4F, 0x46, 0x32, 0x71,
  0x57, 0x71, 0x46, 0x46, 0x2B, 0x62, 0x5A, 0x37, 0x4F, 0x63, 0x71, 0x7A, 0x31, 0x33, 0x56, 0x43,
  0x64, 0x50, 0x73, 0x43, 0x67, 0x59, 0x41, 0x79, 0x53, 0x66, 0x4C, 0x72, 0x6D, 0x4E, 0x4D, 0x45,
  0x63, 0x79, 0x48, 0x66, 0x4F, 0x4A, 0x73, 0x42, 0x74, 0x64, 0x6A, 0x4E, 0x0A, 0x6C, 0x2F, 0x4A,
  0x53, 0x61, 0x76, 0x76, 0x57, 0x63, 0x61, 0x4C, 0x32, 0x52, 0x62, 0x38, 0x6C, 0x5A, 0x69, 0x36,
  0x50, 0x59, 0x38, 0x64, 0x56, 0x49, 0x37, 0x74, 0x39, 0x70, 0x37, 0x51, 0x75, 0x35, 0x76, 0x6C,
  0x73, 0x79, 0x33, 0x56, 0x78, 0x62, 0x4A, 0x55, 0x41, 0x4E, 0x78, 0x39, 0x6F, 0x49, 0x4B, 0x48,
  0x53, 0x4B, 0x65, 0x61, 0x49, 0x54, 0x34, 0x41, 0x78, 0x79, 0x58, 0x64, 0x63, 0x0A, 0x39, 0x63,
  0x36, 0x69, 0x33, 0x39, 0x45, 0x66, 0x37, 0x48, 0x6A, 0x44, 0x30, 0x2F, 0x79, 0x4D, 0x58, 0x49,
  0x69, 0x6C, 0x44, 0x34, 0x6E, 0x45, 0x69, 0x51, 0x31, 0x54, 0x4B, 0x74, 0x33, 0x51, 0x36, 0x6B,
  0x32, 0x2F, 0x61, 0x72, 0x55, 0x44, 0x70, 0x76, 0x77, 0x70, 0x41, 0x50, 0x54, 0x55, 0x78, 0x6F,
  0x46, 0x6B, 0x54, 0x6E, 0x55, 0x75, 0x4E, 0x79, 0x74, 0x61, 0x76, 0x63, 0x47, 0x34, 0x0A, 0x4E,
  0x2F, 0x69, 0x53, 0x62, 0x65, 0x70, 0x55, 0x4D, 0x45, 0x39, 0x32, 0x6E, 0x73, 0x38, 0x59, 0x31,
  0x6B, 0x74, 0x4D, 0x43, 0x51, 0x4B, 0x42, 0x67, 0x42, 0x55, 0x33, 0x57, 0x44, 0x30, 0x76, 0x52,
  0x45, 0x65, 0x58, 0x48, 0x63, 0x4C, 0x71, 0x4D, 0x59, 0x6B, 0x5A, 0x74, 0x66, 0x4C, 0x49, 0x2F,
  0x35, 0x76, 0x6D, 0x4A, 0x69, 0x37, 0x52, 0x79, 0x62, 0x42, 0x4C, 0x34, 0x57, 0x4D, 0x31, 0x0A,
  0x45, 0x46, 0x42, 0x56, 0x79, 0x4F, 0x35, 0x41, 0x4B, 0x34, 0x67, 0x43, 0x56, 0x66, 0x71, 0x48,
  0x43, 0x79, 0x58, 0x32, 0x61, 0x33, 0x7A, 0x32, 0x70, 0x38, 0x73, 0x79, 0x63, 0x50, 0x37, 0x72,
  0x6D, 0x77, 0x43, 0x6A, 0x39, 0x52, 0x7A, 0x47, 0x41, 0x68, 0x78, 0x59, 0x76, 0x31, 0x57, 0x72,
  0x7A, 0x53, 0x59, 0x39, 0x78, 0x43, 0x45, 0x48, 0x33, 0x35, 0x53, 0x72, 0x65, 0x76, 0x71, 0x48,
  0x0A, 0x6B, 0x58, 0x47, 0x39, 0x7A, 0x73, 0x7A, 0x6A, 0x37, 0x6A, 0x66, 0x68, 0x67, 0x61, 0x2F,
  0x62, 0x56, 0x46, 0x48, 0x43, 0x4F, 0x73, 0x68, 0x2B, 0x49, 0x48, 0x34, 0x67, 0x42, 0x30, 0x63,
  0x70, 0x69, 0x6B, 0x42, 0x34, 0x56, 0x6A, 0x42, 0x68, 0x33, 0x43, 0x2B, 0x65, 0x5A, 0x4E, 0x6B,
  0x61, 0x47, 0x4F, 0x41, 0x5A, 0x56, 0x57, 0x39, 0x52, 0x6F, 0x5A, 0x59, 0x79, 0x38, 0x33, 0x49,
  0x51, 0x0A, 0x6C, 0x74, 0x67, 0x39, 0x41, 0x6F, 0x47, 0x41, 0x44, 0x2B, 0x39, 0x37, 0x4B, 0x2F,
  0x74, 0x54, 0x2F, 0x59, 0x65, 0x4F, 0x54, 0x73, 0x37, 0x77, 0x31, 0x36, 0x35, 0x38, 0x73, 0x57,
  0x42, 0x37, 0x55, 0x75, 0x59, 0x74, 0x2F, 0x53, 0x63, 0x54, 0x6D, 0x4C, 0x55, 0x7A, 0x72, 0x58,
  0x38, 0x78, 0x44, 0x73, 0x47, 0x46, 0x2F, 0x35, 0x69, 0x44, 0x48, 0x44, 0x4B, 0x70, 0x73, 0x4F,
  0x47, 0x58, 0x0A, 0x58, 0x51, 0x69, 0x6C, 0x4B, 0x31, 0x52, 0x78, 0x41, 0x76, 0x4D, 0x36, 0x32,
  0x32, 0x77, 0x49, 0x6A, 0x41, 0x30, 0x56, 0x53, 0x32, 0x74, 0x45, 0x65, 0x42, 0x55, 0x65, 0x59,
  0x75, 0x76, 0x6F, 0x67, 0x30, 0x41, 0x39, 0x2F, 0x57, 0x79, 0x74, 0x71, 0x33, 0x64, 0x59, 0x69,
  0x52, 0x6D, 0x46, 0x33, 0x6C, 0x6C, 0x77, 0x74, 0x79, 0x4C, 0x63, 0x63, 0x48, 0x33, 0x79, 0x4E,
  0x66, 0x79, 0x34, 0x0A, 0x77, 0x59, 0x39, 0x45, 0x4B, 0x49, 0x36, 0x6D, 0x78, 0x6D, 0x41, 0x4C,
  0x31, 0x62, 0x33, 0x72, 0x2B, 0x47, 0x50, 0x72, 0x79, 0x66, 0x63, 0x4F, 0x69, 0x67, 0x62, 0x44,
  0x34, 0x37, 0x5A, 0x65, 0x59, 0x52, 0x35, 0x54, 0x6A, 0x45, 0x71, 0x62, 0x33, 0x5A, 0x66, 0x32,
  0x48, 0x52, 0x49, 0x38, 0x58, 0x38, 0x67, 0x3D, 0x0A, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x45, 0x4E,
  0x44, 0x20, 0x52, 0x53, 0x41, 0x20, 0x50, 0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x20, 0x4B, 0x45,
  0x59, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x0A, 0xFF
};
#else    //zhaoyongkan cert
const unsigned char client_ca[0x588] = {
  0xF1, 0xF1, 0x01, 0x00, 0x80, 0x05, 0x00, 0x00, 0x02, 0x00, 0x7B, 0x05, 0x2D, 0x2D, 0x2D, 0x2D,
  0x2D, 0x42, 0x45, 0x47, 0x49, 0x4E, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46, 0x49, 0x43, 0x41,
  0x54, 0x45, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x0A, 0x4D, 0x49, 0x49, 0x44, 0x33, 0x7A, 0x43, 0x43,
  0x41, 0x73, 0x65, 0x67, 0x41, 0x77, 0x49, 0x42, 0x41, 0x67, 0x49, 0x4A, 0x41, 0x4A, 0x7A, 0x79,
  0x55, 0x6C, 0x31, 0x45, 0x56, 0x32, 0x61, 0x2B, 0x4D, 0x41, 0x30, 0x47, 0x43, 0x53, 0x71, 0x47,
  0x53, 0x49, 0x62, 0x33, 0x44, 0x51, 0x45, 0x42, 0x43, 0x77, 0x55, 0x41, 0x4D, 0x49, 0x47, 0x45,
  0x4D, 0x51, 0x73, 0x77, 0x43, 0x51, 0x59, 0x44, 0x0A, 0x56, 0x51, 0x51, 0x47, 0x45, 0x77, 0x4A,
  0x44, 0x54, 0x6A, 0x45, 0x4F, 0x4D, 0x41, 0x77, 0x47, 0x41, 0x31, 0x55, 0x45, 0x43, 0x41, 0x77,
  0x46, 0x59, 0x32, 0x68, 0x70, 0x62, 0x6D, 0x45, 0x78, 0x45, 0x54, 0x41, 0x50, 0x42, 0x67, 0x4E,
  0x56, 0x42, 0x41, 0x63, 0x4D, 0x43, 0x48, 0x4E, 0x6F, 0x5A, 0x57, 0x35, 0x36, 0x61, 0x47, 0x56,
  0x75, 0x4D, 0x52, 0x45, 0x77, 0x44, 0x77, 0x59, 0x44, 0x0A, 0x56, 0x51, 0x51, 0x4B, 0x44, 0x41,
  0x68, 0x32, 0x59, 0x57, 0x35, 0x7A, 0x64, 0x47, 0x39, 0x75, 0x5A, 0x54, 0x45, 0x52, 0x4D, 0x41,
  0x38, 0x47, 0x41, 0x31, 0x55, 0x45, 0x43, 0x77, 0x77, 0x49, 0x64, 0x6D, 0x46, 0x75, 0x63, 0x33,
  0x52, 0x76, 0x62, 0x6D, 0x55, 0x78, 0x43, 0x7A, 0x41, 0x4A, 0x42, 0x67, 0x4E, 0x56, 0x42, 0x41,
  0x4D, 0x4D, 0x41, 0x6B, 0x4E, 0x42, 0x4D, 0x52, 0x38, 0x77, 0x0A, 0x48, 0x51, 0x59, 0x4A, 0x4B,
  0x6F, 0x5A, 0x49, 0x68, 0x76, 0x63, 0x4E, 0x41, 0x51, 0x6B, 0x42, 0x46, 0x68, 0x42, 0x33, 0x5A,
  0x57, 0x6C, 0x71, 0x61, 0x57, 0x46, 0x72, 0x59, 0x57, 0x6C, 0x41, 0x51, 0x30, 0x45, 0x75, 0x59,
  0x32, 0x39, 0x74, 0x4D, 0x43, 0x41, 0x58, 0x44, 0x54, 0x49, 0x78, 0x4D, 0x44, 0x49, 0x79, 0x4D,
  0x7A, 0x41, 0x79, 0x4D, 0x54, 0x41, 0x78, 0x4F, 0x46, 0x6F, 0x59, 0x0A, 0x44, 0x7A, 0x49, 0x78,
  0x4D, 0x6A, 0x45, 0x77, 0x4D, 0x54, 0x4D, 0x77, 0x4D, 0x44, 0x49, 0x78, 0x4D, 0x44, 0x45, 0x34,
  0x57, 0x6A, 0x43, 0x42, 0x68, 0x44, 0x45, 0x4C, 0x4D, 0x41, 0x6B, 0x47, 0x41, 0x31, 0x55, 0x45,
  0x42, 0x68, 0x4D, 0x43, 0x51, 0x30, 0x34, 0x78, 0x44, 0x6A, 0x41, 0x4D, 0x42, 0x67, 0x4E, 0x56,
  0x42, 0x41, 0x67, 0x4D, 0x42, 0x57, 0x4E, 0x6F, 0x61, 0x57, 0x35, 0x68, 0x0A, 0x4D, 0x52, 0x45,
  0x77, 0x44, 0x77, 0x59, 0x44, 0x56, 0x51, 0x51, 0x48, 0x44, 0x41, 0x68, 0x7A, 0x61, 0x47, 0x56,
  0x75, 0x65, 0x6D, 0x68, 0x6C, 0x62, 0x6A, 0x45, 0x52, 0x4D, 0x41, 0x38, 0x47, 0x41, 0x31, 0x55,
  0x45, 0x43, 0x67, 0x77, 0x49, 0x64, 0x6D, 0x46, 0x75, 0x63, 0x33, 0x52, 0x76, 0x62, 0x6D, 0x55,
  0x78, 0x45, 0x54, 0x41, 0x50, 0x42, 0x67, 0x4E, 0x56, 0x42, 0x41, 0x73, 0x4D, 0x0A, 0x43, 0x48,
  0x5A, 0x68, 0x62, 0x6E, 0x4E, 0x30, 0x62, 0x32, 0x35, 0x6C, 0x4D, 0x51, 0x73, 0x77, 0x43, 0x51,
  0x59, 0x44, 0x56, 0x51, 0x51, 0x44, 0x44, 0x41, 0x4A, 0x44, 0x51, 0x54, 0x45, 0x66, 0x4D, 0x42,
  0x30, 0x47, 0x43, 0x53, 0x71, 0x47, 0x53, 0x49, 0x62, 0x33, 0x44, 0x51, 0x45, 0x4A, 0x41, 0x52,
  0x59, 0x51, 0x64, 0x32, 0x56, 0x70, 0x61, 0x6D, 0x6C, 0x68, 0x61, 0x32, 0x46, 0x70, 0x0A, 0x51,
  0x45, 0x4E, 0x42, 0x4C, 0x6D, 0x4E, 0x76, 0x62, 0x54, 0x43, 0x43, 0x41, 0x53, 0x49, 0x77, 0x44,
  0x51, 0x59, 0x4A, 0x4B, 0x6F, 0x5A, 0x49, 0x68, 0x76, 0x63, 0x4E, 0x41, 0x51, 0x45, 0x42, 0x42,
  0x51, 0x41, 0x44, 0x67, 0x67, 0x45, 0x50, 0x41, 0x44, 0x43, 0x43, 0x41, 0x51, 0x6F, 0x43, 0x67,
  0x67, 0x45, 0x42, 0x41, 0x4C, 0x74, 0x39, 0x32, 0x45, 0x71, 0x70, 0x4B, 0x7A, 0x6B, 0x4E, 0x0A,
  0x44, 0x6B, 0x4A, 0x56, 0x37, 0x72, 0x38, 0x6A, 0x51, 0x52, 0x48, 0x42, 0x50, 0x45, 0x64, 0x58,
  0x71, 0x43, 0x45, 0x56, 0x4F, 0x54, 0x78, 0x6D, 0x31, 0x57, 0x35, 0x59, 0x69, 0x72, 0x41, 0x5A,
  0x34, 0x55, 0x4E, 0x39, 0x75, 0x47, 0x62, 0x32, 0x4D, 0x70, 0x65, 0x78, 0x6F, 0x30, 0x46, 0x79,
  0x48, 0x49, 0x51, 0x34, 0x6A, 0x48, 0x31, 0x63, 0x37, 0x73, 0x36, 0x39, 0x53, 0x38, 0x4A, 0x41,
  0x0A, 0x68, 0x49, 0x6F, 0x6C, 0x69, 0x37, 0x6F, 0x41, 0x74, 0x71, 0x45, 0x55, 0x41, 0x42, 0x30,
  0x63, 0x62, 0x31, 0x56, 0x37, 0x4C, 0x78, 0x6F, 0x66, 0x4A, 0x76, 0x4A, 0x4B, 0x6A, 0x52, 0x43,
  0x2B, 0x79, 0x46, 0x6F, 0x61, 0x6E, 0x2B, 0x76, 0x2F, 0x62, 0x43, 0x61, 0x30, 0x6A, 0x63, 0x2B,
  0x51, 0x57, 0x75, 0x41, 0x68, 0x39, 0x6F, 0x71, 0x4D, 0x5A, 0x4C, 0x65, 0x4F, 0x78, 0x4D, 0x47,
  0x65, 0x0A, 0x73, 0x4A, 0x34, 0x78, 0x68, 0x63, 0x32, 0x48, 0x62, 0x43, 0x6A, 0x6D, 0x56, 0x4B,
  0x31, 0x45, 0x67, 0x67, 0x2F, 0x2F, 0x39, 0x72, 0x4A, 0x67, 0x64, 0x63, 0x55, 0x72, 0x54, 0x50,
  0x44, 0x62, 0x64, 0x53, 0x73, 0x51, 0x2F, 0x33, 0x79, 0x31, 0x2B, 0x5A, 0x56, 0x53, 0x41, 0x32,
  0x4D, 0x36, 0x35, 0x72, 0x49, 0x46, 0x6B, 0x34, 0x64, 0x44, 0x74, 0x63, 0x2F, 0x6B, 0x64, 0x46,
  0x43, 0x6E, 0x0A, 0x45, 0x53, 0x35, 0x6C, 0x4F, 0x75, 0x55, 0x50, 0x44, 0x4A, 0x42, 0x51, 0x46,
  0x7A, 0x77, 0x70, 0x71, 0x79, 0x6A, 0x37, 0x33, 0x58, 0x30, 0x74, 0x67, 0x67, 0x35, 0x4B, 0x65,
  0x5A, 0x31, 0x58, 0x35, 0x49, 0x33, 0x61, 0x75, 0x57, 0x6A, 0x7A, 0x37, 0x65, 0x64, 0x33, 0x52,
  0x33, 0x6D, 0x54, 0x79, 0x47, 0x73, 0x76, 0x39, 0x6D, 0x61, 0x4A, 0x2B, 0x45, 0x77, 0x58, 0x4C,
  0x2F, 0x51, 0x61, 0x0A, 0x36, 0x42, 0x73, 0x6A, 0x78, 0x44, 0x50, 0x54, 0x6A, 0x30, 0x41, 0x74,
  0x70, 0x72, 0x6C, 0x4E, 0x4F, 0x4F, 0x72, 0x4C, 0x6E, 0x2B, 0x56, 0x55, 0x74, 0x47, 0x4A, 0x6A,
  0x6D, 0x79, 0x38, 0x6C, 0x73, 0x74, 0x41, 0x39, 0x61, 0x66, 0x57, 0x65, 0x34, 0x68, 0x71, 0x53,
  0x52, 0x43, 0x6C, 0x33, 0x59, 0x45, 0x6C, 0x36, 0x32, 0x67, 0x70, 0x46, 0x39, 0x62, 0x69, 0x75,
  0x65, 0x36, 0x48, 0x46, 0x0A, 0x59, 0x78, 0x36, 0x44, 0x35, 0x30, 0x48, 0x49, 0x78, 0x6F, 0x73,
  0x43, 0x41, 0x77, 0x45, 0x41, 0x41, 0x61, 0x4E, 0x51, 0x4D, 0x45, 0x34, 0x77, 0x48, 0x51, 0x59,
  0x44, 0x56, 0x52, 0x30, 0x4F, 0x42, 0x42, 0x59, 0x45, 0x46, 0x42, 0x78, 0x70, 0x57, 0x57, 0x73,
  0x39, 0x4B, 0x62, 0x5A, 0x74, 0x2B, 0x56, 0x52, 0x37, 0x47, 0x7A, 0x6C, 0x41, 0x6A, 0x47, 0x43,
  0x56, 0x77, 0x37, 0x61, 0x76, 0x0A, 0x4D, 0x42, 0x38, 0x47, 0x41, 0x31, 0x55, 0x64, 0x49, 0x77,
  0x51, 0x59, 0x4D, 0x42, 0x61, 0x41, 0x46, 0x42, 0x78, 0x70, 0x57, 0x57, 0x73, 0x39, 0x4B, 0x62,
  0x5A, 0x74, 0x2B, 0x56, 0x52, 0x37, 0x47, 0x7A, 0x6C, 0x41, 0x6A, 0x47, 0x43, 0x56, 0x77, 0x37,
  0x61, 0x76, 0x4D, 0x41, 0x77, 0x47, 0x41, 0x31, 0x55, 0x64, 0x45, 0x77, 0x51, 0x46, 0x4D, 0x41,
  0x4D, 0x42, 0x41, 0x66, 0x38, 0x77, 0x0A, 0x44, 0x51, 0x59, 0x4A, 0x4B, 0x6F, 0x5A, 0x49, 0x68,
  0x76, 0x63, 0x4E, 0x41, 0x51, 0x45, 0x4C, 0x42, 0x51, 0x41, 0x44, 0x67, 0x67, 0x45, 0x42, 0x41,
  0x43, 0x36, 0x33, 0x75, 0x45, 0x70, 0x37, 0x70, 0x62, 0x4A, 0x57, 0x52, 0x7A, 0x43, 0x63, 0x68,
  0x64, 0x76, 0x65, 0x42, 0x63, 0x68, 0x79, 0x30, 0x33, 0x47, 0x55, 0x74, 0x4D, 0x4E, 0x6E, 0x4F,
  0x49, 0x72, 0x79, 0x30, 0x49, 0x74, 0x4A, 0x0A, 0x6B, 0x65, 0x2B, 0x4F, 0x68, 0x57, 0x48, 0x2B,
  0x53, 0x5A, 0x71, 0x39, 0x2B, 0x56, 0x4B, 0x75, 0x31, 0x6F, 0x36, 0x63, 0x66, 0x32, 0x74, 0x6F,
  0x79, 0x64, 0x77, 0x6F, 0x54, 0x6A, 0x62, 0x68, 0x45, 0x63, 0x2F, 0x4D, 0x4C, 0x68, 0x55, 0x6E,
  0x30, 0x61, 0x64, 0x79, 0x38, 0x55, 0x64, 0x6E, 0x6E, 0x5A, 0x6F, 0x57, 0x7A, 0x5A, 0x72, 0x71,
  0x70, 0x73, 0x2F, 0x61, 0x42, 0x53, 0x71, 0x52, 0x0A, 0x42, 0x4A, 0x4B, 0x6F, 0x59, 0x6D, 0x48,
  0x42, 0x62, 0x77, 0x66, 0x47, 0x42, 0x73, 0x30, 0x52, 0x42, 0x41, 0x62, 0x61, 0x44, 0x2B, 0x65,
  0x47, 0x6C, 0x59, 0x4F, 0x5A, 0x42, 0x65, 0x42, 0x62, 0x34, 0x77, 0x58, 0x42, 0x68, 0x50, 0x55,
  0x33, 0x43, 0x41, 0x52, 0x54, 0x75, 0x59, 0x73, 0x32, 0x34, 0x74, 0x58, 0x39, 0x4A, 0x56, 0x45,
  0x4F, 0x47, 0x71, 0x32, 0x48, 0x51, 0x45, 0x41, 0x31, 0x0A, 0x78, 0x39, 0x71, 0x39, 0x6B, 0x77,
  0x74, 0x79, 0x43, 0x44, 0x6F, 0x58, 0x61, 0x74, 0x65, 0x79, 0x48, 0x75, 0x4E, 0x35, 0x74, 0x59,
  0x37, 0x48, 0x7A, 0x59, 0x4B, 0x6A, 0x4C, 0x4C, 0x74, 0x4D, 0x53, 0x50, 0x2B, 0x47, 0x56, 0x65,
  0x31, 0x5A, 0x55, 0x51, 0x70, 0x6C, 0x35, 0x5A, 0x78, 0x59, 0x59, 0x6C, 0x46, 0x4C, 0x2F, 0x47,
  0x4F, 0x7A, 0x32, 0x4C, 0x52, 0x59, 0x30, 0x79, 0x41, 0x57, 0x0A, 0x30, 0x42, 0x31, 0x58, 0x76,
  0x47, 0x6A, 0x6A, 0x39, 0x78, 0x70, 0x59, 0x64, 0x75, 0x4E, 0x52, 0x30, 0x73, 0x55, 0x53, 0x7A,
  0x46, 0x62, 0x36, 0x72, 0x70, 0x41, 0x7A, 0x6F, 0x4E, 0x55, 0x7A, 0x6C, 0x31, 0x73, 0x56, 0x4F,
  0x6D, 0x50, 0x54, 0x4A, 0x76, 0x37, 0x41, 0x42, 0x57, 0x34, 0x73, 0x4C, 0x44, 0x6B, 0x47, 0x35,
  0x6B, 0x56, 0x32, 0x43, 0x6F, 0x6C, 0x46, 0x4A, 0x75, 0x4F, 0x6C, 0x0A, 0x30, 0x68, 0x54, 0x74,
  0x6F, 0x6A, 0x73, 0x58, 0x48, 0x4A, 0x55, 0x44, 0x4D, 0x61, 0x42, 0x6E, 0x31, 0x4B, 0x34, 0x42,
  0x53, 0x71, 0x76, 0x46, 0x55, 0x64, 0x39, 0x78, 0x63, 0x6B, 0x76, 0x64, 0x49, 0x34, 0x44, 0x36,
  0x77, 0x32, 0x62, 0x70, 0x4D, 0x44, 0x56, 0x56, 0x37, 0x4B, 0x6B, 0x3D, 0x0A, 0x2D, 0x2D, 0x2D,
  0x2D, 0x2D, 0x45, 0x4E, 0x44, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46, 0x49, 0x43, 0x41, 0x54,
  0x45, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x0A, 0xFF
};

const unsigned char client_cert[0x1208] = {
  0xF1, 0xF1, 0x01, 0x00, 0x00, 0x12, 0x00, 0x00, 0x02, 0x00, 0xFC, 0x11, 0x43, 0x65, 0x72, 0x74,
  0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x44, 0x61, 0x74,
  0x61, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69,
  0x6F, 0x6E, 0x3A, 0x20, 0x33, 0x20, 0x28, 0x30, 0x78, 0x32, 0x29, 0x0A, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6C, 0x20, 0x4E, 0x75, 0x6D, 0x62, 0x65,
  0x72, 0x3A, 0x20, 0x32, 0x20, 0x28, 0x30, 0x78, 0x32, 0x29, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x53,
  0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 0x72, 0x65, 0x20, 0x41, 0x6C, 0x67, 0x6F, 0x72, 0x69, 0x74,
  0x68, 0x6D, 0x3A, 0x20, 0x73, 0x68, 0x61, 0x32, 0x35, 0x36, 0x57, 0x69, 0x74, 0x68, 0x52, 0x53,
  0x41, 0x45, 0x6E, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x0A, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x49, 0x73, 0x73, 0x75, 0x65, 0x72, 0x3A, 0x20, 0x43, 0x3D, 0x43, 0x4E,
  0x2C, 0x20, 0x53, 0x54, 0x3D, 0x63, 0x68, 0x69, 0x6E, 0x61, 0x2C, 0x20, 0x4C, 0x3D, 0x73, 0x68,
  0x65, 0x6E, 0x7A, 0x68, 0x65, 0x6E, 0x2C, 0x20, 0x4F, 0x3D, 0x76, 0x61, 0x6E, 0x73, 0x74, 0x6F,
  0x6E, 0x65, 0x2C, 0x20, 0x4F, 0x55, 0x3D, 0x76, 0x61, 0x6E, 0x73, 0x74, 0x6F, 0x6E, 0x65, 0x2C,
  0x20, 0x43, 0x4E, 0x3D, 0x43, 0x41, 0x2F, 0x65, 0x6D, 0x61, 0x69, 0x6C, 0x41, 0x64, 0x64, 0x72,
  0x65, 0x73, 0x73, 0x3D, 0x77, 0x65, 0x69, 0x6A, 0x69, 0x61, 0x6B, 0x61, 0x69, 0x40, 0x43, 0x41,
  0x2E, 0x63, 0x6F, 0x6D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x56, 0x61, 0x6C,
  0x69, 0x64, 0x69, 0x74, 0x79, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x4E, 0x6F, 0x74, 0x20, 0x42, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x3A, 0x20, 0x46, 0x65,
  0x62, 0x20, 0x32, 0x33, 0x20, 0x30, 0x32, 0x3A, 0x31, 0x30, 0x3A, 0x32, 0x32, 0x20, 0x32, 0x30,
  0x32, 0x31, 0x20, 0x47, 0x4D, 0x54, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x4E, 0x6F, 0x74, 0x20, 0x41, 0x66, 0x74, 0x65, 0x72, 0x20, 0x3A, 0x20, 0x4A,
  0x61, 0x6E, 0x20, 0x33, 0x30, 0x20, 0x30, 0x32, 0x3A, 0x31, 0x30, 0x3A, 0x32, 0x32, 0x20, 0x32,
  0x31, 0x32, 0x31, 0x20, 0x47, 0x4D, 0x54, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x53, 0x75, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x3A, 0x20, 0x43, 0x3D, 0x43, 0x4E, 0x2C, 0x20, 0x53,
  0x54, 0x3D, 0x63, 0x68, 0x69, 0x6E, 0x61, 0x2C, 0x20, 0x4F, 0x3D, 0x76, 0x61, 0x6E, 0x73, 0x74,
  0x6F, 0x6E, 0x65, 0x2C, 0x20, 0x4F, 0x55, 0x3D, 0x76, 0x61, 0x6E, 0x73, 0x74, 0x6F, 0x6E, 0x65,
  0x2C, 0x20, 0x43, 0x4E, 0x3D, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x2F, 0x65, 0x6D, 0x61, 0x69,
  0x6C, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3D, 0x77, 0x65, 0x69, 0x6A, 0x69, 0x61, 0x6B,
  0x61, 0x69, 0x40, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x0A, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x53, 0x75, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x20, 0x50, 0x75,
  0x62, 0x6C, 0x69, 0x63, 0x20, 0x4B, 0x65, 0x79, 0x20, 0x49, 0x6E, 0x66, 0x6F, 0x3A, 0x0A, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69,
  0x63, 0x20, 0x4B, 0x65, 0x79, 0x20, 0x41, 0x6C, 0x67, 0x6F, 0x72, 0x69, 0x74, 0x68, 0x6D, 0x3A,
  0x20, 0x72, 0x73, 0x61, 0x45, 0x6E, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x0A, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x50,
  0x75, 0x62, 0x6C, 0x69, 0x63, 0x2D, 0x4B, 0x65, 0x79, 0x3A, 0x20, 0x28, 0x32, 0x30, 0x34, 0x38,
  0x20, 0x62, 0x69, 0x74, 0x29, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4D, 0x6F, 0x64, 0x75, 0x6C, 0x75, 0x73, 0x3A, 0x0A, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x30, 0x30, 0x3A, 0x64, 0x34, 0x3A, 0x36, 0x61, 0x3A, 0x35, 0x62, 0x3A, 0x33,
  0x63, 0x3A, 0x33, 0x30, 0x3A, 0x31, 0x30, 0x3A, 0x31, 0x38, 0x3A, 0x39, 0x64, 0x3A, 0x39, 0x36,
  0x3A, 0x34, 0x30, 0x3A, 0x35, 0x31, 0x3A, 0x62, 0x32, 0x3A, 0x33, 0x62, 0x3A, 0x35, 0x62, 0x3A,
  0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x36, 0x3A, 0x37, 0x32, 0x3A, 0x66, 0x34, 0x3A, 0x33, 0x39,
  0x3A, 0x32, 0x33, 0x3A, 0x30, 0x35, 0x3A, 0x63, 0x64, 0x3A, 0x32, 0x38, 0x3A, 0x38, 0x31, 0x3A,
  0x64, 0x32, 0x3A, 0x66, 0x33, 0x3A, 0x65, 0x36, 0x3A, 0x64, 0x32, 0x3A, 0x39, 0x62, 0x3A, 0x36,
  0x62, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x38, 0x3A, 0x38, 0x64, 0x3A, 0x38, 0x64, 0x3A,
  0x38, 0x30, 0x3A, 0x38, 0x35, 0x3A, 0x64, 0x34, 0x3A, 0x61, 0x35, 0x3A, 0x63, 0x62, 0x3A, 0x33,
  0x35, 0x3A, 0x32, 0x35, 0x3A, 0x38, 0x39, 0x3A, 0x31, 0x34, 0x3A, 0x37, 0x37, 0x3A, 0x32, 0x34,
  0x3A, 0x64, 0x34, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x38, 0x63, 0x3A, 0x39, 0x66, 0x3A, 0x39,
  0x64, 0x3A, 0x37, 0x30, 0x3A, 0x31, 0x31, 0x3A, 0x66, 0x33, 0x3A, 0x31, 0x38, 0x3A, 0x30, 0x38,
  0x3A, 0x37, 0x37, 0x3A, 0x61, 0x64, 0x3A, 0x39, 0x65, 0x3A, 0x63, 0x37, 0x3A, 0x38, 0x62, 0x3A,
  0x33, 0x64, 0x3A, 0x32, 0x36, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x38, 0x65, 0x3A, 0x33, 0x61,
  0x3A, 0x63, 0x30, 0x3A, 0x38, 0x39, 0x3A, 0x37, 0x62, 0x3A, 0x30, 0x33, 0x3A, 0x61, 0x65, 0x3A,
  0x61, 0x64, 0x3A, 0x65, 0x31, 0x3A, 0x35, 0x62, 0x3A, 0x31, 0x38, 0x3A, 0x66, 0x38, 0x3A, 0x65,
  0x30, 0x3A, 0x36, 0x33, 0x3A, 0x62, 0x62, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x36, 0x61, 0x3A,
  0x39, 0x33, 0x3A, 0x30, 0x62, 0x3A, 0x63, 0x39, 0x3A, 0x64, 0x38, 0x3A, 0x30, 0x63, 0x3A, 0x36,
  0x30, 0x3A, 0x65, 0x32, 0x3A, 0x30, 0x31, 0x3A, 0x32, 0x66, 0x3A, 0x61, 0x34, 0x3A, 0x64, 0x34,
  0x3A, 0x39, 0x65, 0x3A, 0x33, 0x38, 0x3A, 0x31, 0x37, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x33,
  0x32, 0x3A, 0x63, 0x34, 0x3A, 0x31, 0x63, 0x3A, 0x36, 0x36, 0x3A, 0x37, 0x33, 0x3A, 0x32, 0x63,
  0x3A, 0x61, 0x64, 0x3A, 0x64, 0x62, 0x3A, 0x34, 0x37, 0x3A, 0x35, 0x64, 0x3A, 0x30, 0x38, 0x3A,
  0x66, 0x38, 0x3A, 0x65, 0x32, 0x3A, 0x63, 0x31, 0x3A, 0x62, 0x33, 0x3A, 0x0A, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x39, 0x61, 0x3A, 0x34, 0x39, 0x3A, 0x32, 0x39, 0x3A, 0x38, 0x30, 0x3A, 0x65, 0x37, 0x3A,
  0x31, 0x62, 0x3A, 0x66, 0x34, 0x3A, 0x65, 0x37, 0x3A, 0x39, 0x35, 0x3A, 0x32, 0x35, 0x3A, 0x62,
  0x30, 0x3A, 0x33, 0x34, 0x3A, 0x35, 0x36, 0x3A, 0x31, 0x63, 0x3A, 0x63, 0x61, 0x3A, 0x0A, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x63, 0x33, 0x3A, 0x32, 0x32, 0x3A, 0x62, 0x66, 0x3A, 0x38, 0x31, 0x3A, 0x33,
  0x66, 0x3A, 0x64, 0x35, 0x3A, 0x65, 0x35, 0x3A, 0x64, 0x39, 0x3A, 0x31, 0x34, 0x3A, 0x39, 0x64,
  0x3A, 0x66, 0x61, 0x3A, 0x66, 0x62, 0x3A, 0x31, 0x35, 0x3A, 0x34, 0x35, 0x3A, 0x32, 0x63, 0x3A,
  0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x32, 0x30, 0x3A, 0x37, 0x63, 0x3A, 0x39, 0x38, 0x3A, 0x31, 0x63,
  0x3A, 0x63, 0x66, 0x3A, 0x36, 0x33, 0x3A, 0x34, 0x30, 0x3A, 0x39, 0x62, 0x3A, 0x35, 0x38, 0x3A,
  0x31, 0x33, 0x3A, 0x35, 0x61, 0x3A, 0x64, 0x33, 0x3A, 0x31, 0x61, 0x3A, 0x30, 0x37, 0x3A, 0x62,
  0x61, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x66, 0x32, 0x3A, 0x39, 0x37, 0x3A, 0x33, 0x32, 0x3A,
  0x30, 0x32, 0x3A, 0x35, 0x36, 0x3A, 0x62, 0x37, 0x3A, 0x31, 0x66, 0x3A, 0x35, 0x62, 0x3A, 0x35,
  0x35, 0x3A, 0x30, 0x31, 0x3A, 0x39, 0x62, 0x3A, 0x65, 0x62, 0x3A, 0x33, 0x31, 0x3A, 0x61, 0x61,
  0x3A, 0x63, 0x36, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x63, 0x63, 0x3A, 0x61, 0x63, 0x3A, 0x64,
  0x64, 0x3A, 0x38, 0x36, 0x3A, 0x66, 0x65, 0x3A, 0x38, 0x62, 0x3A, 0x63, 0x61, 0x3A, 0x65, 0x66,
  0x3A, 0x33, 0x34, 0x3A, 0x39, 0x37, 0x3A, 0x39, 0x62, 0x3A, 0x34, 0x39, 0x3A, 0x35, 0x33, 0x3A,
  0x38, 0x62, 0x3A, 0x66, 0x61, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x62, 0x3A, 0x33, 0x39,
  0x3A, 0x64, 0x37, 0x3A, 0x36, 0x32, 0x3A, 0x31, 0x62, 0x3A, 0x33, 0x63, 0x3A, 0x65, 0x34, 0x3A,
  0x32, 0x61, 0x3A, 0x64, 0x65, 0x3A, 0x66, 0x32, 0x3A, 0x34, 0x62, 0x3A, 0x65, 0x39, 0x3A, 0x61,
  0x65, 0x3A, 0x31, 0x36, 0x3A, 0x33, 0x38, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x36, 0x3A,
  0x65, 0x64, 0x3A, 0x39, 0x65, 0x3A, 0x31, 0x32, 0x3A, 0x62, 0x61, 0x3A, 0x34, 0x31, 0x3A, 0x34,
  0x34, 0x3A, 0x30, 0x33, 0x3A, 0x38, 0x33, 0x3A, 0x62, 0x64, 0x3A, 0x30, 0x30, 0x3A, 0x34, 0x35,
  0x3A, 0x66, 0x62, 0x3A, 0x35, 0x38, 0x3A, 0x66, 0x61, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61,
  0x37, 0x3A, 0x36, 0x33, 0x3A, 0x66, 0x65, 0x3A, 0x61, 0x34, 0x3A, 0x65, 0x35, 0x3A, 0x34, 0x39,
  0x3A, 0x32, 0x64, 0x3A, 0x34, 0x62, 0x3A, 0x66, 0x39, 0x3A, 0x31, 0x63, 0x3A, 0x30, 0x62, 0x3A,
  0x31, 0x38, 0x3A, 0x61, 0x34, 0x3A, 0x64, 0x37, 0x3A, 0x64, 0x32, 0x3A, 0x0A, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x63, 0x63, 0x3A, 0x32, 0x66, 0x3A, 0x39, 0x66, 0x3A, 0x32, 0x65, 0x3A, 0x31, 0x62, 0x3A,
  0x32, 0x31, 0x3A, 0x37, 0x37, 0x3A, 0x64, 0x36, 0x3A, 0x39, 0x64, 0x3A, 0x39, 0x63, 0x3A, 0x38,
  0x30, 0x3A, 0x63, 0x33, 0x3A, 0x36, 0x30, 0x3A, 0x32, 0x33, 0x3A, 0x66, 0x65, 0x3A, 0x0A, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x34, 0x30, 0x3A, 0x64, 0x35, 0x3A, 0x32, 0x61, 0x3A, 0x63, 0x62, 0x3A, 0x34,
  0x37, 0x3A, 0x33, 0x31, 0x3A, 0x64, 0x61, 0x3A, 0x65, 0x37, 0x3A, 0x32, 0x39, 0x3A, 0x31, 0x63,
  0x3A, 0x62, 0x64, 0x3A, 0x38, 0x66, 0x3A, 0x32, 0x64, 0x3A, 0x36, 0x64, 0x3A, 0x63, 0x64, 0x3A,
  0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x39, 0x39, 0x3A, 0x63, 0x37, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x45, 0x78, 0x70, 0x6F, 0x6E,
  0x65, 0x6E, 0x74, 0x3A, 0x20, 0x36, 0x35, 0x35, 0x33, 0x37, 0x20, 0x28, 0x30, 0x78, 0x31, 0x30,
  0x30, 0x30, 0x31, 0x29, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x58, 0x35, 0x30,
  0x39, 0x76, 0x33, 0x20, 0x65, 0x78, 0x74, 0x65, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x3A, 0x0A,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x58, 0x35, 0x30, 0x39,
  0x76, 0x33, 0x20, 0x42, 0x61, 0x73, 0x69, 0x63, 0x20, 0x43, 0x6F, 0x6E, 0x73, 0x74, 0x72, 0x61,
  0x69, 0x6E, 0x74, 0x73, 0x3A, 0x20, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x43, 0x41, 0x3A, 0x46, 0x41, 0x4C, 0x53, 0x45, 0x0A,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4E, 0x65, 0x74, 0x73,
  0x63, 0x61, 0x70, 0x65, 0x20, 0x43, 0x6F, 0x6D, 0x6D, 0x65, 0x6E, 0x74, 0x3A, 0x20, 0x0A, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4F,
  0x70, 0x65, 0x6E, 0x53, 0x53, 0x4C, 0x20, 0x47, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64,
  0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x0A, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x58, 0x35, 0x30, 0x39, 0x76, 0x33, 0x20,
  0x53, 0x75, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x20, 0x4B, 0x65, 0x79, 0x20, 0x49, 0x64, 0x65, 0x6E,
  0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x3A, 0x20, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x38, 0x30, 0x3A, 0x33, 0x38, 0x3A, 0x39,
  0x35, 0x3A, 0x44, 0x46, 0x3A, 0x46, 0x39, 0x3A, 0x33, 0x31, 0x3A, 0x41, 0x30, 0x3A, 0x41, 0x37,
  0x3A, 0x36, 0x38, 0x3A, 0x35, 0x39, 0x3A, 0x34, 0x46, 0x3A, 0x39, 0x35, 0x3A, 0x43, 0x33, 0x3A,
  0x35, 0x46, 0x3A, 0x42, 0x38, 0x3A, 0x31, 0x33, 0x3A, 0x42, 0x30, 0x3A, 0x46, 0x31, 0x3A, 0x32,
  0x46, 0x3A, 0x39, 0x33, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x58, 0x35, 0x30, 0x39, 0x76, 0x33, 0x20, 0x41, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x74,
  0x79, 0x20, 0x4B, 0x65, 0x79, 0x20, 0x49, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72,
  0x3A, 0x20, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x6B, 0x65, 0x79, 0x69, 0x64, 0x3A, 0x31, 0x43, 0x3A, 0x36, 0x39, 0x3A, 0x35,
  0x39, 0x3A, 0x36, 0x42, 0x3A, 0x33, 0x44, 0x3A, 0x32, 0x39, 0x3A, 0x42, 0x36, 0x3A, 0x36, 0x44,
  0x3A, 0x46, 0x39, 0x3A, 0x35, 0x34, 0x3A, 0x37, 0x42, 0x3A, 0x31, 0x42, 0x3A, 0x33, 0x39, 0x3A,
  0x34, 0x30, 0x3A, 0x38, 0x43, 0x3A, 0x36, 0x30, 0x3A, 0x39, 0x35, 0x3A, 0x43, 0x33, 0x3A, 0x42,
  0x36, 0x3A, 0x41, 0x46, 0x0A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x61, 0x74,
  0x75, 0x72, 0x65, 0x20, 0x41, 0x6C, 0x67, 0x6F, 0x72, 0x69, 0x74, 0x68, 0x6D, 0x3A, 0x20, 0x73,
  0x68, 0x61, 0x32, 0x35, 0x36, 0x57, 0x69, 0x74, 0x68, 0x52, 0x53, 0x41, 0x45, 0x6E, 0x63, 0x72,
  0x79, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x38, 0x37, 0x3A, 0x35, 0x64, 0x3A, 0x31, 0x61, 0x3A, 0x30, 0x38, 0x3A, 0x39, 0x38, 0x3A, 0x61,
  0x61, 0x3A, 0x32, 0x30, 0x3A, 0x36, 0x36, 0x3A, 0x62, 0x36, 0x3A, 0x63, 0x37, 0x3A, 0x39, 0x65,
  0x3A, 0x65, 0x35, 0x3A, 0x37, 0x37, 0x3A, 0x31, 0x66, 0x3A, 0x31, 0x65, 0x3A, 0x34, 0x35, 0x3A,
  0x37, 0x65, 0x3A, 0x34, 0x62, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x35, 0x61, 0x3A, 0x33, 0x33, 0x3A, 0x32, 0x35, 0x3A, 0x38, 0x66, 0x3A, 0x38, 0x38, 0x3A, 0x61,
  0x34, 0x3A, 0x33, 0x35, 0x3A, 0x36, 0x65, 0x3A, 0x33, 0x36, 0x3A, 0x61, 0x65, 0x3A, 0x38, 0x32,
  0x3A, 0x63, 0x62, 0x3A, 0x64, 0x37, 0x3A, 0x65, 0x32, 0x3A, 0x35, 0x62, 0x3A, 0x39, 0x36, 0x3A,
  0x65, 0x35, 0x3A, 0x62, 0x39, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x33, 0x66, 0x3A, 0x61, 0x66, 0x3A, 0x63, 0x66, 0x3A, 0x32, 0x32, 0x3A, 0x62, 0x35, 0x3A, 0x31,
  0x34, 0x3A, 0x61, 0x63, 0x3A, 0x65, 0x66, 0x3A, 0x65, 0x66, 0x3A, 0x34, 0x37, 0x3A, 0x63, 0x39,
  0x3A, 0x36, 0x30, 0x3A, 0x65, 0x30, 0x3A, 0x66, 0x38, 0x3A, 0x64, 0x35, 0x3A, 0x38, 0x66, 0x3A,
  0x39, 0x38, 0x3A, 0x38, 0x64, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x65, 0x62, 0x3A, 0x65, 0x37, 0x3A, 0x31, 0x31, 0x3A, 0x31, 0x30, 0x3A, 0x33, 0x64, 0x3A, 0x38,
  0x37, 0x3A, 0x36, 0x30, 0x3A, 0x39, 0x33, 0x3A, 0x37, 0x33, 0x3A, 0x63, 0x34, 0x3A, 0x30, 0x64,
  0x3A, 0x65, 0x32, 0x3A, 0x38, 0x37, 0x3A, 0x62, 0x63, 0x3A, 0x36, 0x34, 0x3A, 0x62, 0x32, 0x3A,
  0x63, 0x32, 0x3A, 0x63, 0x62, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x61, 0x65, 0x3A, 0x65, 0x35, 0x3A, 0x38, 0x37, 0x3A, 0x38, 0x33, 0x3A, 0x30, 0x63, 0x3A, 0x65,
  0x61, 0x3A, 0x33, 0x39, 0x3A, 0x34, 0x34, 0x3A, 0x36, 0x37, 0x3A, 0x65, 0x36, 0x3A, 0x36, 0x33,
  0x3A, 0x36, 0x34, 0x3A, 0x66, 0x36, 0x3A, 0x30, 0x33, 0x3A, 0x66, 0x66, 0x3A, 0x33, 0x32, 0x3A,
  0x35, 0x39, 0x3A, 0x64, 0x36, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x63, 0x38, 0x3A, 0x36, 0x39, 0x3A, 0x35, 0x37, 0x3A, 0x63, 0x31, 0x3A, 0x38, 0x36, 0x3A, 0x65,
  0x61, 0x3A, 0x36, 0x61, 0x3A, 0x65, 0x35, 0x3A, 0x38, 0x65, 0x3A, 0x36, 0x64, 0x3A, 0x33, 0x30,
  0x3A, 0x64, 0x30, 0x3A, 0x35, 0x63, 0x3A, 0x35, 0x62, 0x3A, 0x63, 0x30, 0x3A, 0x61, 0x64, 0x3A,
  0x34, 0x61, 0x3A, 0x65, 0x64, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x35, 0x64, 0x3A, 0x31, 0x37, 0x3A, 0x66, 0x32, 0x3A, 0x31, 0x36, 0x3A, 0x38, 0x35, 0x3A, 0x36,
  0x66, 0x3A, 0x31, 0x63, 0x3A, 0x34, 0x39, 0x3A, 0x39, 0x36, 0x3A, 0x33, 0x35, 0x3A, 0x65, 0x38,
  0x3A, 0x62, 0x37, 0x3A, 0x33, 0x35, 0x3A, 0x65, 0x64, 0x3A, 0x31, 0x63, 0x3A, 0x37, 0x38, 0x3A,
  0x34, 0x30, 0x3A, 0x66, 0x63, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x62, 0x64, 0x3A, 0x63, 0x39, 0x3A, 0x39, 0x62, 0x3A, 0x33, 0x34, 0x3A, 0x64, 0x64, 0x3A, 0x64,
  0x63, 0x3A, 0x39, 0x62, 0x3A, 0x61, 0x33, 0x3A, 0x62, 0x30, 0x3A, 0x34, 0x38, 0x3A, 0x37, 0x34,
  0x3A, 0x38, 0x38, 0x3A, 0x33, 0x62, 0x3A, 0x34, 0x62, 0x3A, 0x36, 0x35, 0x3A, 0x30, 0x31, 0x3A,
  0x39, 0x31, 0x3A, 0x63, 0x39, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x34, 0x39, 0x3A, 0x63, 0x31, 0x3A, 0x62, 0x66, 0x3A, 0x65, 0x31, 0x3A, 0x35, 0x30, 0x3A, 0x63,
  0x38, 0x3A, 0x35, 0x61, 0x3A, 0x37, 0x34, 0x3A, 0x39, 0x31, 0x3A, 0x32, 0x36, 0x3A, 0x33, 0x30,
  0x3A, 0x31, 0x36, 0x3A, 0x66, 0x31, 0x3A, 0x31, 0x34, 0x3A, 0x62, 0x37, 0x3A, 0x62, 0x35, 0x3A,
  0x35, 0x63, 0x3A, 0x64, 0x30, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x32, 0x36, 0x3A, 0x35, 0x65, 0x3A, 0x32, 0x61, 0x3A, 0x32, 0x35, 0x3A, 0x35, 0x36, 0x3A, 0x39,
  0x35, 0x3A, 0x65, 0x65, 0x3A, 0x62, 0x30, 0x3A, 0x38, 0x62, 0x3A, 0x30, 0x32, 0x3A, 0x65, 0x61,
  0x3A, 0x65, 0x32, 0x3A, 0x33, 0x33, 0x3A, 0x36, 0x35, 0x3A, 0x63, 0x38, 0x3A, 0x32, 0x39, 0x3A,
  0x32, 0x37, 0x3A, 0x33, 0x38, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x33, 0x32, 0x3A, 0x32, 0x31, 0x3A, 0x37, 0x36, 0x3A, 0x64, 0x66, 0x3A, 0x37, 0x35, 0x3A, 0x64,
  0x38, 0x3A, 0x66, 0x35, 0x3A, 0x35, 0x34, 0x3A, 0x61, 0x61, 0x3A, 0x63, 0x38, 0x3A, 0x35, 0x38,
  0x3A, 0x39, 0x31, 0x3A, 0x39, 0x37, 0x3A, 0x63, 0x39, 0x3A, 0x65, 0x36, 0x3A, 0x39, 0x36, 0x3A,
  0x30, 0x36, 0x3A, 0x66, 0x32, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x37, 0x33, 0x3A, 0x38, 0x34, 0x3A, 0x32, 0x32, 0x3A, 0x38, 0x63, 0x3A, 0x32, 0x62, 0x3A, 0x31,
  0x31, 0x3A, 0x39, 0x33, 0x3A, 0x36, 0x36, 0x3A, 0x35, 0x31, 0x3A, 0x33, 0x32, 0x3A, 0x36, 0x38,
  0x3A, 0x30, 0x35, 0x3A, 0x62, 0x39, 0x3A, 0x39, 0x32, 0x3A, 0x35, 0x31, 0x3A, 0x62, 0x61, 0x3A,
  0x63, 0x61, 0x3A, 0x63, 0x32, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x37, 0x36, 0x3A, 0x38, 0x30, 0x3A, 0x38, 0x66, 0x3A, 0x32, 0x65, 0x3A, 0x39, 0x33, 0x3A, 0x39,
  0x37, 0x3A, 0x36, 0x64, 0x3A, 0x38, 0x66, 0x3A, 0x64, 0x38, 0x3A, 0x30, 0x35, 0x3A, 0x36, 0x62,
  0x3A, 0x65, 0x33, 0x3A, 0x34, 0x36, 0x3A, 0x36, 0x66, 0x3A, 0x31, 0x38, 0x3A, 0x31, 0x66, 0x3A,
  0x61, 0x62, 0x3A, 0x39, 0x32, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x32, 0x36, 0x3A, 0x39, 0x63, 0x3A, 0x38, 0x61, 0x3A, 0x30, 0x31, 0x3A, 0x65, 0x62, 0x3A, 0x63,
  0x63, 0x3A, 0x30, 0x64, 0x3A, 0x30, 0x38, 0x3A, 0x62, 0x63, 0x3A, 0x31, 0x66, 0x3A, 0x32, 0x32,
  0x3A, 0x65, 0x63, 0x3A, 0x64, 0x35, 0x3A, 0x63, 0x33, 0x3A, 0x63, 0x32, 0x3A, 0x36, 0x37, 0x3A,
  0x63, 0x61, 0x3A, 0x32, 0x38, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x34, 0x30, 0x3A, 0x66, 0x37, 0x3A, 0x38, 0x38, 0x3A, 0x65, 0x36, 0x0A, 0x2D, 0x2D, 0x2D, 0x2D,
  0x2D, 0x42, 0x45, 0x47, 0x49, 0x4E, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46, 0x49, 0x43, 0x41,
  0x54, 0x45, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x0A, 0x4D, 0x49, 0x49, 0x44, 0x39, 0x6A, 0x43, 0x43,
  0x41, 0x74, 0x36, 0x67, 0x41, 0x77, 0x49, 0x42, 0x41, 0x67, 0x49, 0x42, 0x41, 0x6A, 0x41, 0x4E,
  0x42, 0x67, 0x6B, 0x71, 0x68, 0x6B, 0x69, 0x47, 0x39, 0x77, 0x30, 0x42, 0x41, 0x51, 0x73, 0x46,
  0x41, 0x44, 0x43, 0x42, 0x68, 0x44, 0x45, 0x4C, 0x4D, 0x41, 0x6B, 0x47, 0x41, 0x31, 0x55, 0x45,
  0x42, 0x68, 0x4D, 0x43, 0x51, 0x30, 0x34, 0x78, 0x0A, 0x44, 0x6A, 0x41, 0x4D, 0x42, 0x67, 0x4E,
  0x56, 0x42, 0x41, 0x67, 0x4D, 0x42, 0x57, 0x4E, 0x6F, 0x61, 0x57, 0x35, 0x68, 0x4D, 0x52, 0x45,
  0x77, 0x44, 0x77, 0x59, 0x44, 0x56, 0x51, 0x51, 0x48, 0x44, 0x41, 0x68, 0x7A, 0x61, 0x47, 0x56,
  0x75, 0x65, 0x6D, 0x68, 0x6C, 0x62, 0x6A, 0x45, 0x52, 0x4D, 0x41, 0x38, 0x47, 0x41, 0x31, 0x55,
  0x45, 0x43, 0x67, 0x77, 0x49, 0x64, 0x6D, 0x46, 0x75, 0x0A, 0x63, 0x33, 0x52, 0x76, 0x62, 0x6D,
  0x55, 0x78, 0x45, 0x54, 0x41, 0x50, 0x42, 0x67, 0x4E, 0x56, 0x42, 0x41, 0x73, 0x4D, 0x43, 0x48,
  0x5A, 0x68, 0x62, 0x6E, 0x4E, 0x30, 0x62, 0x32, 0x35, 0x6C, 0x4D, 0x51, 0x73, 0x77, 0x43, 0x51,
  0x59, 0x44, 0x56, 0x51, 0x51, 0x44, 0x44, 0x41, 0x4A, 0x44, 0x51, 0x54, 0x45, 0x66, 0x4D, 0x42,
  0x30, 0x47, 0x43, 0x53, 0x71, 0x47, 0x53, 0x49, 0x62, 0x33, 0x0A, 0x44, 0x51, 0x45, 0x4A, 0x41,
  0x52, 0x59, 0x51, 0x64, 0x32, 0x56, 0x70, 0x61, 0x6D, 0x6C, 0x68, 0x61, 0x32, 0x46, 0x70, 0x51,
  0x45, 0x4E, 0x42, 0x4C, 0x6D, 0x4E, 0x76, 0x62, 0x54, 0x41, 0x67, 0x46, 0x77, 0x30, 0x79, 0x4D,
  0x54, 0x41, 0x79, 0x4D, 0x6A, 0x4D, 0x77, 0x4D, 0x6A, 0x45, 0x77, 0x4D, 0x6A, 0x4A, 0x61, 0x47,
  0x41, 0x38, 0x79, 0x4D, 0x54, 0x49, 0x78, 0x4D, 0x44, 0x45, 0x7A, 0x0A, 0x4D, 0x44, 0x41, 0x79,
  0x4D, 0x54, 0x41, 0x79, 0x4D, 0x6C, 0x6F, 0x77, 0x65, 0x54, 0x45, 0x4C, 0x4D, 0x41, 0x6B, 0x47,
  0x41, 0x31, 0x55, 0x45, 0x42, 0x68, 0x4D, 0x43, 0x51, 0x30, 0x34, 0x78, 0x44, 0x6A, 0x41, 0x4D,
  0x42, 0x67, 0x4E, 0x56, 0x42, 0x41, 0x67, 0x4D, 0x42, 0x57, 0x4E, 0x6F, 0x61, 0x57, 0x35, 0x68,
  0x4D, 0x52, 0x45, 0x77, 0x44, 0x77, 0x59, 0x44, 0x56, 0x51, 0x51, 0x4B, 0x0A, 0x44, 0x41, 0x68,
  0x32, 0x59, 0x57, 0x35, 0x7A, 0x64, 0x47, 0x39, 0x75, 0x5A, 0x54, 0x45, 0x52, 0x4D, 0x41, 0x38,
  0x47, 0x41, 0x31, 0x55, 0x45, 0x43, 0x77, 0x77, 0x49, 0x64, 0x6D, 0x46, 0x75, 0x63, 0x33, 0x52,
  0x76, 0x62, 0x6D, 0x55, 0x78, 0x44, 0x7A, 0x41, 0x4E, 0x42, 0x67, 0x4E, 0x56, 0x42, 0x41, 0x4D,
  0x4D, 0x42, 0x6D, 0x4E, 0x73, 0x61, 0x57, 0x56, 0x75, 0x64, 0x44, 0x45, 0x6A, 0x0A, 0x4D, 0x43,
  0x45, 0x47, 0x43, 0x53, 0x71, 0x47, 0x53, 0x49, 0x62, 0x33, 0x44, 0x51, 0x45, 0x4A, 0x41, 0x52,
  0x59, 0x55, 0x64, 0x32, 0x56, 0x70, 0x61, 0x6D, 0x6C, 0x68, 0x61, 0x32, 0x46, 0x70, 0x51, 0x47,
  0x4E, 0x73, 0x61, 0x57, 0x56, 0x75, 0x64, 0x43, 0x35, 0x6A, 0x62, 0x32, 0x30, 0x77, 0x67, 0x67,
  0x45, 0x69, 0x4D, 0x41, 0x30, 0x47, 0x43, 0x53, 0x71, 0x47, 0x53, 0x49, 0x62, 0x33, 0x0A, 0x44,
  0x51, 0x45, 0x42, 0x41, 0x51, 0x55, 0x41, 0x41, 0x34, 0x49, 0x42, 0x44, 0x77, 0x41, 0x77, 0x67,
  0x67, 0x45, 0x4B, 0x41, 0x6F, 0x49, 0x42, 0x41, 0x51, 0x44, 0x55, 0x61, 0x6C, 0x73, 0x38, 0x4D,
  0x42, 0x41, 0x59, 0x6E, 0x5A, 0x5A, 0x41, 0x55, 0x62, 0x49, 0x37, 0x57, 0x78, 0x5A, 0x79, 0x39,
  0x44, 0x6B, 0x6A, 0x42, 0x63, 0x30, 0x6F, 0x67, 0x64, 0x4C, 0x7A, 0x35, 0x74, 0x4B, 0x62, 0x0A,
  0x61, 0x78, 0x69, 0x4E, 0x6A, 0x59, 0x43, 0x46, 0x31, 0x4B, 0x58, 0x4C, 0x4E, 0x53, 0x57, 0x4A,
  0x46, 0x48, 0x63, 0x6B, 0x31, 0x49, 0x79, 0x66, 0x6E, 0x58, 0x41, 0x52, 0x38, 0x78, 0x67, 0x49,
  0x64, 0x36, 0x32, 0x65, 0x78, 0x34, 0x73, 0x39, 0x4A, 0x6F, 0x34, 0x36, 0x77, 0x49, 0x6C, 0x37,
  0x41, 0x36, 0x36, 0x74, 0x34, 0x56, 0x73, 0x59, 0x2B, 0x4F, 0x42, 0x6A, 0x75, 0x32, 0x71, 0x54,
  0x0A, 0x43, 0x38, 0x6E, 0x59, 0x44, 0x47, 0x44, 0x69, 0x41, 0x53, 0x2B, 0x6B, 0x31, 0x4A, 0x34,
  0x34, 0x46, 0x7A, 0x4C, 0x45, 0x48, 0x47, 0x5A, 0x7A, 0x4C, 0x4B, 0x33, 0x62, 0x52, 0x31, 0x30,
  0x49, 0x2B, 0x4F, 0x4C, 0x42, 0x73, 0x35, 0x70, 0x4A, 0x4B, 0x59, 0x44, 0x6E, 0x47, 0x2F, 0x54,
  0x6E, 0x6C, 0x53, 0x57, 0x77, 0x4E, 0x46, 0x59, 0x63, 0x79, 0x73, 0x4D, 0x69, 0x76, 0x34, 0x45,
  0x2F, 0x0A, 0x31, 0x65, 0x58, 0x5A, 0x46, 0x4A, 0x33, 0x36, 0x2B, 0x78, 0x56, 0x46, 0x4C, 0x43,
  0x42, 0x38, 0x6D, 0x42, 0x7A, 0x50, 0x59, 0x30, 0x43, 0x62, 0x57, 0x42, 0x4E, 0x61, 0x30, 0x78,
  0x6F, 0x48, 0x75, 0x76, 0x4B, 0x58, 0x4D, 0x67, 0x4A, 0x57, 0x74, 0x78, 0x39, 0x62, 0x56, 0x51,
  0x47, 0x62, 0x36, 0x7A, 0x47, 0x71, 0x78, 0x73, 0x79, 0x73, 0x33, 0x59, 0x62, 0x2B, 0x69, 0x38,
  0x72, 0x76, 0x0A, 0x4E, 0x4A, 0x65, 0x62, 0x53, 0x56, 0x4F, 0x4C, 0x2B, 0x75, 0x73, 0x35, 0x31,
  0x32, 0x49, 0x62, 0x50, 0x4F, 0x51, 0x71, 0x33, 0x76, 0x4A, 0x4C, 0x36, 0x61, 0x34, 0x57, 0x4F,
  0x41, 0x62, 0x74, 0x6E, 0x68, 0x4B, 0x36, 0x51, 0x55, 0x51, 0x44, 0x67, 0x37, 0x30, 0x41, 0x52,
  0x66, 0x74, 0x59, 0x2B, 0x71, 0x64, 0x6A, 0x2F, 0x71, 0x54, 0x6C, 0x53, 0x53, 0x31, 0x4C, 0x2B,
  0x52, 0x77, 0x4C, 0x0A, 0x47, 0x4B, 0x54, 0x58, 0x30, 0x73, 0x77, 0x76, 0x6E, 0x79, 0x34, 0x62,
  0x49, 0x58, 0x66, 0x57, 0x6E, 0x5A, 0x79, 0x41, 0x77, 0x32, 0x41, 0x6A, 0x2F, 0x6B, 0x44, 0x56,
  0x4B, 0x73, 0x74, 0x48, 0x4D, 0x64, 0x72, 0x6E, 0x4B, 0x52, 0x79, 0x39, 0x6A, 0x79, 0x31, 0x74,
  0x7A, 0x5A, 0x6E, 0x48, 0x41, 0x67, 0x4D, 0x42, 0x41, 0x41, 0x47, 0x6A, 0x65, 0x7A, 0x42, 0x35,
  0x4D, 0x41, 0x6B, 0x47, 0x0A, 0x41, 0x31, 0x55, 0x64, 0x45, 0x77, 0x51, 0x43, 0x4D, 0x41, 0x41,
  0x77, 0x4C, 0x41, 0x59, 0x4A, 0x59, 0x49, 0x5A, 0x49, 0x41, 0x59, 0x62, 0x34, 0x51, 0x67, 0x45,
  0x4E, 0x42, 0x42, 0x38, 0x57, 0x48, 0x55, 0x39, 0x77, 0x5A, 0x57, 0x35, 0x54, 0x55, 0x30, 0x77,
  0x67, 0x52, 0x32, 0x56, 0x75, 0x5A, 0x58, 0x4A, 0x68, 0x64, 0x47, 0x56, 0x6B, 0x49, 0x45, 0x4E,
  0x6C, 0x63, 0x6E, 0x52, 0x70, 0x0A, 0x5A, 0x6D, 0x6C, 0x6A, 0x59, 0x58, 0x52, 0x6C, 0x4D, 0x42,
  0x30, 0x47, 0x41, 0x31, 0x55, 0x64, 0x44, 0x67, 0x51, 0x57, 0x42, 0x42, 0x53, 0x41, 0x4F, 0x4A,
  0x58, 0x66, 0x2B, 0x54, 0x47, 0x67, 0x70, 0x32, 0x68, 0x5A, 0x54, 0x35, 0x58, 0x44, 0x58, 0x37,
  0x67, 0x54, 0x73, 0x50, 0x45, 0x76, 0x6B, 0x7A, 0x41, 0x66, 0x42, 0x67, 0x4E, 0x56, 0x48, 0x53,
  0x4D, 0x45, 0x47, 0x44, 0x41, 0x57, 0x0A, 0x67, 0x42, 0x51, 0x63, 0x61, 0x56, 0x6C, 0x72, 0x50,
  0x53, 0x6D, 0x32, 0x62, 0x66, 0x6C, 0x55, 0x65, 0x78, 0x73, 0x35, 0x51, 0x49, 0x78, 0x67, 0x6C,
  0x63, 0x4F, 0x32, 0x72, 0x7A, 0x41, 0x4E, 0x42, 0x67, 0x6B, 0x71, 0x68, 0x6B, 0x69, 0x47, 0x39,
  0x77, 0x30, 0x42, 0x41, 0x51, 0x73, 0x46, 0x41, 0x41, 0x4F, 0x43, 0x41, 0x51, 0x45, 0x41, 0x68,
  0x31, 0x30, 0x61, 0x43, 0x4A, 0x69, 0x71, 0x0A, 0x49, 0x47, 0x61, 0x32, 0x78, 0x35, 0x37, 0x6C,
  0x64, 0x78, 0x38, 0x65, 0x52, 0x58, 0x35, 0x4C, 0x57, 0x6A, 0x4D, 0x6C, 0x6A, 0x34, 0x69, 0x6B,
  0x4E, 0x57, 0x34, 0x32, 0x72, 0x6F, 0x4C, 0x4C, 0x31, 0x2B, 0x4A, 0x62, 0x6C, 0x75, 0x57, 0x35,
  0x50, 0x36, 0x2F, 0x50, 0x49, 0x72, 0x55, 0x55, 0x72, 0x4F, 0x2F, 0x76, 0x52, 0x38, 0x6C, 0x67,
  0x34, 0x50, 0x6A, 0x56, 0x6A, 0x35, 0x69, 0x4E, 0x0A, 0x36, 0x2B, 0x63, 0x52, 0x45, 0x44, 0x32,
  0x48, 0x59, 0x4A, 0x4E, 0x7A, 0x78, 0x41, 0x33, 0x69, 0x68, 0x37, 0x78, 0x6B, 0x73, 0x73, 0x4C,
  0x4C, 0x72, 0x75, 0x57, 0x48, 0x67, 0x77, 0x7A, 0x71, 0x4F, 0x55, 0x52, 0x6E, 0x35, 0x6D, 0x4E,
  0x6B, 0x39, 0x67, 0x50, 0x2F, 0x4D, 0x6C, 0x6E, 0x57, 0x79, 0x47, 0x6C, 0x58, 0x77, 0x59, 0x62,
  0x71, 0x61, 0x75, 0x57, 0x4F, 0x62, 0x54, 0x44, 0x51, 0x0A, 0x58, 0x46, 0x76, 0x41, 0x72, 0x55,
  0x72, 0x74, 0x58, 0x52, 0x66, 0x79, 0x46, 0x6F, 0x56, 0x76, 0x48, 0x45, 0x6D, 0x57, 0x4E, 0x65,
  0x69, 0x33, 0x4E, 0x65, 0x30, 0x63, 0x65, 0x45, 0x44, 0x38, 0x76, 0x63, 0x6D, 0x62, 0x4E, 0x4E,
  0x33, 0x63, 0x6D, 0x36, 0x4F, 0x77, 0x53, 0x48, 0x53, 0x49, 0x4F, 0x30, 0x74, 0x6C, 0x41, 0x5A,
  0x48, 0x4A, 0x53, 0x63, 0x47, 0x2F, 0x34, 0x56, 0x44, 0x49, 0x0A, 0x57, 0x6E, 0x53, 0x52, 0x4A,
  0x6A, 0x41, 0x57, 0x38, 0x52, 0x53, 0x33, 0x74, 0x56, 0x7A, 0x51, 0x4A, 0x6C, 0x34, 0x71, 0x4A,
  0x56, 0x61, 0x56, 0x37, 0x72, 0x43, 0x4C, 0x41, 0x75, 0x72, 0x69, 0x4D, 0x32, 0x58, 0x49, 0x4B,
  0x53, 0x63, 0x34, 0x4D, 0x69, 0x46, 0x32, 0x33, 0x33, 0x58, 0x59, 0x39, 0x56, 0x53, 0x71, 0x79,
  0x46, 0x69, 0x52, 0x6C, 0x38, 0x6E, 0x6D, 0x6C, 0x67, 0x62, 0x79, 0x0A, 0x63, 0x34, 0x51, 0x69,
  0x6A, 0x43, 0x73, 0x52, 0x6B, 0x32, 0x5A, 0x52, 0x4D, 0x6D, 0x67, 0x46, 0x75, 0x5A, 0x4A, 0x52,
  0x75, 0x73, 0x72, 0x43, 0x64, 0x6F, 0x43, 0x50, 0x4C, 0x70, 0x4F, 0x58, 0x62, 0x59, 0x2F, 0x59,
  0x42, 0x57, 0x76, 0x6A, 0x52, 0x6D, 0x38, 0x59, 0x48, 0x36, 0x75, 0x53, 0x4A, 0x70, 0x79, 0x4B,
  0x41, 0x65, 0x76, 0x4D, 0x44, 0x51, 0x69, 0x38, 0x48, 0x79, 0x4C, 0x73, 0x0A, 0x31, 0x63, 0x50,
  0x43, 0x5A, 0x38, 0x6F, 0x6F, 0x51, 0x50, 0x65, 0x49, 0x35, 0x67, 0x3D, 0x3D, 0x0A, 0x2D, 0x2D,
  0x2D, 0x2D, 0x2D, 0x45, 0x4E, 0x44, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46, 0x49, 0x43, 0x41,
  0x54, 0x45, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x0A
};

const unsigned char client_key[0x698] = {
  0xF1, 0xF1, 0x01, 0x00, 0x90, 0x06, 0x00, 0x00, 0x02, 0x00, 0x8B, 0x06, 0x2D, 0x2D, 0x2D, 0x2D,
  0x2D, 0x42, 0x45, 0x47, 0x49, 0x4E, 0x20, 0x52, 0x53, 0x41, 0x20, 0x50, 0x52, 0x49, 0x56, 0x41,
  0x54, 0x45, 0x20, 0x4B, 0x45, 0x59, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x0A, 0x4D, 0x49, 0x49, 0x45,
  0x6F, 0x77, 0x49, 0x42, 0x41, 0x41, 0x4B, 0x43, 0x41, 0x51, 0x45, 0x41, 0x31, 0x47, 0x70, 0x62,
  0x50, 0x44, 0x41, 0x51, 0x47, 0x4A, 0x32, 0x57, 0x51, 0x46, 0x47, 0x79, 0x4F, 0x31, 0x73, 0x57,
  0x63, 0x76, 0x51, 0x35, 0x49, 0x77, 0x58, 0x4E, 0x4B, 0x49, 0x48, 0x53, 0x38, 0x2B, 0x62, 0x53,
  0x6D, 0x32, 0x73, 0x59, 0x6A, 0x59, 0x32, 0x41, 0x68, 0x64, 0x53, 0x6C, 0x0A, 0x79, 0x7A, 0x55,
  0x6C, 0x69, 0x52, 0x52, 0x33, 0x4A, 0x4E, 0x53, 0x4D, 0x6E, 0x35, 0x31, 0x77, 0x45, 0x66, 0x4D,
  0x59, 0x43, 0x48, 0x65, 0x74, 0x6E, 0x73, 0x65, 0x4C, 0x50, 0x53, 0x61, 0x4F, 0x4F, 0x73, 0x43,
  0x4A, 0x65, 0x77, 0x4F, 0x75, 0x72, 0x65, 0x46, 0x62, 0x47, 0x50, 0x6A, 0x67, 0x59, 0x37, 0x74,
  0x71, 0x6B, 0x77, 0x76, 0x4A, 0x32, 0x41, 0x78, 0x67, 0x34, 0x67, 0x45, 0x76, 0x0A, 0x70, 0x4E,
  0x53, 0x65, 0x4F, 0x42, 0x63, 0x79, 0x78, 0x42, 0x78, 0x6D, 0x63, 0x79, 0x79, 0x74, 0x32, 0x30,
  0x64, 0x64, 0x43, 0x50, 0x6A, 0x69, 0x77, 0x62, 0x4F, 0x61, 0x53, 0x53, 0x6D, 0x41, 0x35, 0x78,
  0x76, 0x30, 0x35, 0x35, 0x55, 0x6C, 0x73, 0x44, 0x52, 0x57, 0x48, 0x4D, 0x72, 0x44, 0x49, 0x72,
  0x2B, 0x42, 0x50, 0x39, 0x58, 0x6C, 0x32, 0x52, 0x53, 0x64, 0x2B, 0x76, 0x73, 0x56, 0x0A, 0x52,
  0x53, 0x77, 0x67, 0x66, 0x4A, 0x67, 0x63, 0x7A, 0x32, 0x4E, 0x41, 0x6D, 0x31, 0x67, 0x54, 0x57,
  0x74, 0x4D, 0x61, 0x42, 0x37, 0x72, 0x79, 0x6C, 0x7A, 0x49, 0x43, 0x56, 0x72, 0x63, 0x66, 0x57,
  0x31, 0x55, 0x42, 0x6D, 0x2B, 0x73, 0x78, 0x71, 0x73, 0x62, 0x4D, 0x72, 0x4E, 0x32, 0x47, 0x2F,
  0x6F, 0x76, 0x4B, 0x37, 0x7A, 0x53, 0x58, 0x6D, 0x30, 0x6C, 0x54, 0x69, 0x2F, 0x72, 0x72, 0x0A,
  0x4F, 0x64, 0x64, 0x69, 0x47, 0x7A, 0x7A, 0x6B, 0x4B, 0x74, 0x37, 0x79, 0x53, 0x2B, 0x6D, 0x75,
  0x46, 0x6A, 0x67, 0x47, 0x37, 0x5A, 0x34, 0x53, 0x75, 0x6B, 0x46, 0x45, 0x41, 0x34, 0x4F, 0x39,
  0x41, 0x45, 0x58, 0x37, 0x57, 0x50, 0x71, 0x6E, 0x59, 0x2F, 0x36, 0x6B, 0x35, 0x55, 0x6B, 0x74,
  0x53, 0x2F, 0x6B, 0x63, 0x43, 0x78, 0x69, 0x6B, 0x31, 0x39, 0x4C, 0x4D, 0x4C, 0x35, 0x38, 0x75,
  0x0A, 0x47, 0x79, 0x46, 0x33, 0x31, 0x70, 0x32, 0x63, 0x67, 0x4D, 0x4E, 0x67, 0x49, 0x2F, 0x35,
  0x41, 0x31, 0x53, 0x72, 0x4C, 0x52, 0x7A, 0x48, 0x61, 0x35, 0x79, 0x6B, 0x63, 0x76, 0x59, 0x38,
  0x74, 0x62, 0x63, 0x32, 0x5A, 0x78, 0x77, 0x49, 0x44, 0x41, 0x51, 0x41, 0x42, 0x41, 0x6F, 0x49,
  0x42, 0x41, 0x51, 0x43, 0x66, 0x35, 0x56, 0x4F, 0x36, 0x55, 0x64, 0x2B, 0x37, 0x39, 0x39, 0x77,
  0x6A, 0x0A, 0x6E, 0x4A, 0x76, 0x53, 0x37, 0x48, 0x56, 0x51, 0x6F, 0x53, 0x44, 0x6C, 0x69, 0x54,
  0x64, 0x76, 0x4E, 0x35, 0x4C, 0x4A, 0x67, 0x4D, 0x61, 0x6D, 0x73, 0x59, 0x35, 0x77, 0x39, 0x38,
  0x52, 0x34, 0x65, 0x61, 0x4D, 0x33, 0x2F, 0x56, 0x43, 0x39, 0x43, 0x49, 0x66, 0x4C, 0x56, 0x4B,
  0x68, 0x71, 0x65, 0x6F, 0x50, 0x6A, 0x4C, 0x78, 0x2B, 0x33, 0x4F, 0x41, 0x65, 0x63, 0x7A, 0x30,
  0x36, 0x30, 0x0A, 0x41, 0x48, 0x4C, 0x75, 0x4C, 0x51, 0x4D, 0x51, 0x63, 0x36, 0x77, 0x70, 0x50,
  0x63, 0x74, 0x71, 0x56, 0x2B, 0x58, 0x70, 0x6A, 0x53, 0x6E, 0x6A, 0x65, 0x4F, 0x73, 0x2B, 0x30,
  0x38, 0x71, 0x57, 0x4E, 0x68, 0x68, 0x63, 0x4E, 0x71, 0x54, 0x48, 0x53, 0x6B, 0x63, 0x76, 0x73,
  0x73, 0x55, 0x34, 0x43, 0x37, 0x6A, 0x76, 0x71, 0x4A, 0x2B, 0x53, 0x34, 0x6D, 0x38, 0x6E, 0x4B,
  0x6F, 0x43, 0x49, 0x0A, 0x64, 0x46, 0x4B, 0x52, 0x4A, 0x63, 0x31, 0x4D, 0x43, 0x6B, 0x79, 0x74,
  0x67, 0x43, 0x67, 0x57, 0x55, 0x6C, 0x64, 0x6A, 0x72, 0x38, 0x36, 0x6D, 0x63, 0x2B, 0x67, 0x71,
  0x61, 0x47, 0x69, 0x4F, 0x5A, 0x45, 0x56, 0x70, 0x4D, 0x44, 0x51, 0x38, 0x63, 0x48, 0x7A, 0x2B,
  0x36, 0x6A, 0x46, 0x58, 0x41, 0x55, 0x63, 0x61, 0x6B, 0x65, 0x67, 0x35, 0x52, 0x4B, 0x42, 0x4E,
  0x43, 0x4F, 0x5A, 0x66, 0x0A, 0x48, 0x6B, 0x53, 0x61, 0x6F, 0x30, 0x4B, 0x69, 0x6C, 0x4B, 0x68,
  0x4D, 0x41, 0x4E, 0x6C, 0x6F, 0x4D, 0x62, 0x53, 0x34, 0x6B, 0x4A, 0x6B, 0x42, 0x5A, 0x55, 0x52,
  0x62, 0x75, 0x6F, 0x34, 0x68, 0x4B, 0x4C, 0x5A, 0x4C, 0x7A, 0x70, 0x67, 0x69, 0x66, 0x66, 0x41,
  0x39, 0x63, 0x72, 0x62, 0x78, 0x75, 0x4E, 0x7A, 0x37, 0x4D, 0x4B, 0x77, 0x33, 0x46, 0x33, 0x69,
  0x66, 0x50, 0x68, 0x2F, 0x70, 0x0A, 0x5A, 0x6D, 0x64, 0x64, 0x72, 0x62, 0x37, 0x31, 0x54, 0x50,
  0x4A, 0x67, 0x36, 0x69, 0x31, 0x55, 0x6A, 0x48, 0x49, 0x31, 0x76, 0x5A, 0x38, 0x44, 0x7A, 0x54,
  0x33, 0x65, 0x43, 0x77, 0x42, 0x6A, 0x47, 0x63, 0x30, 0x4B, 0x56, 0x52, 0x78, 0x68, 0x45, 0x73,
  0x4F, 0x70, 0x68, 0x34, 0x67, 0x52, 0x6D, 0x4A, 0x52, 0x2F, 0x4A, 0x4F, 0x45, 0x6C, 0x79, 0x6F,
  0x4C, 0x34, 0x72, 0x77, 0x61, 0x78, 0x0A, 0x64, 0x52, 0x37, 0x31, 0x34, 0x78, 0x35, 0x68, 0x41,
  0x6F, 0x47, 0x42, 0x41, 0x4F, 0x76, 0x61, 0x47, 0x6B, 0x4F, 0x51, 0x79, 0x62, 0x6B, 0x76, 0x62,
  0x70, 0x48, 0x61, 0x6F, 0x62, 0x4E, 0x79, 0x75, 0x32, 0x36, 0x6C, 0x45, 0x56, 0x79, 0x44, 0x41,
  0x6A, 0x4C, 0x50, 0x70, 0x64, 0x6D, 0x4F, 0x38, 0x4A, 0x4C, 0x41, 0x30, 0x61, 0x64, 0x36, 0x6E,
  0x36, 0x2F, 0x43, 0x74, 0x31, 0x63, 0x75, 0x0A, 0x73, 0x6C, 0x70, 0x75, 0x78, 0x55, 0x64, 0x6C,
  0x47, 0x42, 0x74, 0x39, 0x73, 0x4C, 0x79, 0x74, 0x4D, 0x6F, 0x4B, 0x49, 0x76, 0x64, 0x4D, 0x4A,
  0x6F, 0x38, 0x6D, 0x66, 0x68, 0x41, 0x46, 0x43, 0x44, 0x59, 0x72, 0x63, 0x41, 0x4C, 0x48, 0x72,
  0x54, 0x79, 0x6C, 0x2B, 0x5A, 0x68, 0x45, 0x4F, 0x35, 0x56, 0x36, 0x47, 0x6F, 0x31, 0x79, 0x42,
  0x50, 0x4C, 0x79, 0x61, 0x52, 0x74, 0x75, 0x59, 0x0A, 0x5A, 0x44, 0x37, 0x4C, 0x35, 0x46, 0x68,
  0x53, 0x51, 0x72, 0x79, 0x6C, 0x4E, 0x44, 0x61, 0x46, 0x6F, 0x2B, 0x77, 0x32, 0x4E, 0x35, 0x79,
  0x4B, 0x50, 0x45, 0x6C, 0x33, 0x38, 0x4F, 0x56, 0x33, 0x32, 0x4D, 0x2B, 0x62, 0x68, 0x34, 0x4C,
  0x64, 0x30, 0x6D, 0x55, 0x36, 0x6F, 0x4E, 0x5A, 0x37, 0x4B, 0x78, 0x43, 0x48, 0x4E, 0x78, 0x57,
  0x58, 0x41, 0x6F, 0x47, 0x42, 0x41, 0x4F, 0x61, 0x50, 0x0A, 0x74, 0x7A, 0x71, 0x43, 0x54, 0x69,
  0x43, 0x45, 0x58, 0x64, 0x35, 0x68, 0x6B, 0x72, 0x65, 0x69, 0x2B, 0x48, 0x69, 0x71, 0x4A, 0x67,
  0x43, 0x62, 0x36, 0x47, 0x79, 0x2B, 0x52, 0x30, 0x76, 0x53, 0x74, 0x32, 0x48, 0x77, 0x4D, 0x57,
  0x32, 0x70, 0x77, 0x6E, 0x69, 0x57, 0x6F, 0x56, 0x79, 0x38, 0x48, 0x66, 0x55, 0x69, 0x56, 0x55,
  0x4C, 0x67, 0x61, 0x57, 0x36, 0x53, 0x58, 0x70, 0x38, 0x4B, 0x0A, 0x49, 0x52, 0x63, 0x6D, 0x6E,
  0x45, 0x4B, 0x5A, 0x6B, 0x69, 0x67, 0x65, 0x43, 0x32, 0x49, 0x75, 0x6E, 0x62, 0x35, 0x78, 0x4B,
  0x41, 0x42, 0x42, 0x4D, 0x41, 0x31, 0x66, 0x67, 0x4A, 0x6C, 0x39, 0x37, 0x49, 0x4A, 0x30, 0x38,
  0x44, 0x74, 0x2B, 0x71, 0x31, 0x69, 0x34, 0x37, 0x74, 0x35, 0x68, 0x59, 0x7A, 0x35, 0x70, 0x31,
  0x4B, 0x48, 0x57, 0x34, 0x54, 0x33, 0x30, 0x45, 0x47, 0x58, 0x4D, 0x0A, 0x54, 0x56, 0x47, 0x74,
  0x32, 0x75, 0x52, 0x30, 0x31, 0x61, 0x6D, 0x32, 0x74, 0x35, 0x38, 0x78, 0x6A, 0x43, 0x62, 0x78,
  0x58, 0x5A, 0x52, 0x6D, 0x4C, 0x5A, 0x65, 0x71, 0x35, 0x48, 0x31, 0x39, 0x72, 0x63, 0x32, 0x4B,
  0x75, 0x51, 0x4E, 0x52, 0x41, 0x6F, 0x47, 0x41, 0x4A, 0x30, 0x31, 0x54, 0x2F, 0x52, 0x68, 0x65,
  0x6C, 0x53, 0x35, 0x7A, 0x52, 0x58, 0x6A, 0x69, 0x59, 0x30, 0x33, 0x6D, 0x0A, 0x4C, 0x2F, 0x7A,
  0x76, 0x31, 0x4C, 0x4F, 0x38, 0x4A, 0x51, 0x31, 0x33, 0x50, 0x4C, 0x62, 0x57, 0x48, 0x67, 0x35,
  0x6C, 0x6F, 0x58, 0x77, 0x4D, 0x71, 0x6A, 0x52, 0x50, 0x61, 0x77, 0x62, 0x4D, 0x44, 0x38, 0x66,
  0x50, 0x74, 0x69, 0x4D, 0x42, 0x6A, 0x6D, 0x73, 0x32, 0x6A, 0x57, 0x70, 0x72, 0x4E, 0x56, 0x64,
  0x6D, 0x45, 0x6F, 0x6E, 0x54, 0x73, 0x6D, 0x43, 0x54, 0x6C, 0x63, 0x59, 0x56, 0x0A, 0x44, 0x61,
  0x4F, 0x31, 0x74, 0x66, 0x42, 0x5A, 0x59, 0x37, 0x65, 0x39, 0x65, 0x48, 0x41, 0x38, 0x42, 0x72,
  0x46, 0x32, 0x2F, 0x59, 0x35, 0x48, 0x75, 0x63, 0x49, 0x58, 0x74, 0x72, 0x5A, 0x42, 0x56, 0x6A,
  0x6D, 0x52, 0x31, 0x71, 0x6E, 0x32, 0x6C, 0x77, 0x73, 0x4D, 0x6C, 0x56, 0x31, 0x56, 0x77, 0x4B,
  0x49, 0x55, 0x53, 0x46, 0x43, 0x38, 0x31, 0x52, 0x31, 0x59, 0x6C, 0x6C, 0x53, 0x50, 0x0A, 0x57,
  0x36, 0x45, 0x32, 0x52, 0x72, 0x65, 0x43, 0x50, 0x50, 0x34, 0x31, 0x47, 0x53, 0x69, 0x7A, 0x4E,
  0x33, 0x44, 0x67, 0x33, 0x41, 0x63, 0x43, 0x67, 0x59, 0x42, 0x4A, 0x74, 0x4E, 0x48, 0x33, 0x6B,
  0x32, 0x61, 0x55, 0x67, 0x4A, 0x78, 0x64, 0x6C, 0x6B, 0x58, 0x49, 0x44, 0x51, 0x4A, 0x76, 0x32,
  0x4C, 0x30, 0x54, 0x58, 0x73, 0x51, 0x62, 0x31, 0x32, 0x79, 0x46, 0x63, 0x64, 0x53, 0x4D, 0x0A,
  0x4B, 0x37, 0x51, 0x78, 0x67, 0x5A, 0x36, 0x59, 0x33, 0x46, 0x61, 0x7A, 0x68, 0x62, 0x50, 0x79,
  0x42, 0x4D, 0x72, 0x4B, 0x2B, 0x57, 0x44, 0x62, 0x4A, 0x31, 0x47, 0x32, 0x65, 0x41, 0x2B, 0x43,
  0x44, 0x69, 0x62, 0x51, 0x4A, 0x37, 0x59, 0x51, 0x75, 0x79, 0x49, 0x61, 0x66, 0x68, 0x71, 0x52,
  0x6F, 0x69, 0x30, 0x4F, 0x66, 0x38, 0x68, 0x7A, 0x7A, 0x66, 0x38, 0x58, 0x6B, 0x71, 0x6B, 0x45,
  0x0A, 0x50, 0x34, 0x76, 0x35, 0x43, 0x52, 0x4B, 0x50, 0x35, 0x33, 0x62, 0x39, 0x67, 0x70, 0x61,
  0x75, 0x67, 0x6A, 0x69, 0x6D, 0x6B, 0x45, 0x49, 0x72, 0x67, 0x78, 0x57, 0x6D, 0x35, 0x58, 0x77,
  0x6D, 0x53, 0x33, 0x54, 0x35, 0x71, 0x64, 0x77, 0x51, 0x53, 0x45, 0x68, 0x46, 0x54, 0x52, 0x71,
  0x6E, 0x37, 0x47, 0x74, 0x6C, 0x49, 0x4A, 0x45, 0x63, 0x74, 0x6C, 0x59, 0x62, 0x52, 0x41, 0x31,
  0x47, 0x0A, 0x38, 0x7A, 0x30, 0x59, 0x4D, 0x51, 0x4B, 0x42, 0x67, 0x41, 0x52, 0x4F, 0x54, 0x4B,
  0x71, 0x59, 0x71, 0x36, 0x4E, 0x33, 0x51, 0x4F, 0x38, 0x56, 0x7A, 0x41, 0x7A, 0x66, 0x2F, 0x54,
  0x2B, 0x39, 0x47, 0x39, 0x54, 0x64, 0x45, 0x71, 0x72, 0x65, 0x61, 0x32, 0x68, 0x59, 0x4F, 0x38,
  0x31, 0x59, 0x67, 0x5A, 0x35, 0x62, 0x76, 0x42, 0x36, 0x4C, 0x63, 0x37, 0x2F, 0x54, 0x57, 0x36,
  0x74, 0x78, 0x0A, 0x4C, 0x6A, 0x56, 0x33, 0x43, 0x32, 0x6D, 0x31, 0x69, 0x6B, 0x2F, 0x45, 0x67,
  0x37, 0x70, 0x30, 0x31, 0x65, 0x77, 0x78, 0x6D, 0x61, 0x5A, 0x4D, 0x6A, 0x4B, 0x6A, 0x6C, 0x50,
  0x39, 0x49, 0x39, 0x77, 0x4D, 0x73, 0x2F, 0x69, 0x58, 0x70, 0x73, 0x74, 0x31, 0x2F, 0x71, 0x47,
  0x4D, 0x46, 0x6F, 0x31, 0x4E, 0x63, 0x64, 0x43, 0x6B, 0x42, 0x33, 0x6C, 0x70, 0x67, 0x71, 0x31,
  0x2B, 0x55, 0x6C, 0x0A, 0x38, 0x61, 0x6A, 0x57, 0x6D, 0x76, 0x34, 0x50, 0x59, 0x4D, 0x6F, 0x7A,
  0x72, 0x31, 0x57, 0x69, 0x50, 0x62, 0x70, 0x47, 0x4E, 0x6C, 0x56, 0x63, 0x66, 0x43, 0x48, 0x64,
  0x41, 0x4A, 0x34, 0x51, 0x4C, 0x6C, 0x38, 0x4F, 0x7A, 0x74, 0x50, 0x43, 0x77, 0x6A, 0x4A, 0x6A,
  0x63, 0x74, 0x78, 0x51, 0x67, 0x4C, 0x56, 0x72, 0x0A, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x45, 0x4E,
  0x44, 0x20, 0x52, 0x53, 0x41, 0x20, 0x50, 0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x20, 0x4B, 0x45,
  0x59, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x0A, 0xFF
};

#endif 

#endif


