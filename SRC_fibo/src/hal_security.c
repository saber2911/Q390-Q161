/********************************Copyright ( c ) ********************************
**					Vanstone Electronic (Beijing) Co., Ltd
**						https://www.vanstone.com.cn
**
**
** File Name:		hal_security.c
** Description:		APP、L1Puk验签
**
** Version:	1.0, 渠忠磊,2022-03-01
** a) 修改内容 1 //修改内容精确到函数，并添加相应说明
** b) 修改内容 2 //代码中只有修改后内容
**
** History:
** a) 完成内容 1
** b) 完成内容 2
******************************************************************************/


#include "comm.h"



#define RSA_LEN			0x100

//#define __S_V_DEBUG__
#undef  __S_V_DEBUG__

int signverify_encode(sign_info_t* ptsi,unsigned char* emout,int bfile);


static int g_em_len[]={11,EM_LEN_1024b,EM_LEN_2048b,EM_LEN_3072b,EM_LEN_4096b};


/*
*@Brief:		get file end flag,判断签名尾部最后16个字节是否是“SIGNED.VERSION01”
*@Param IN:		*img_addr:数据指针，img_len:数据长度
*@Return:		0-成功，其他-失败
*/
int signverify_get_e(unsigned char *img_addr,unsigned int img_len)
{
	int rv; 
	unsigned char* ptr=NULL;

	ptr =img_addr+img_len-SIGN_PACKAGE_FLAG_LEN;
	
	rv = memcmp(SIGN_PACKAGE_FLAG_STR,ptr,SIGN_PACKAGE_FLAG_LEN);
	
	if(rv)
		return SIGN_ERR_EFLAG;
	return 0;
}

int signverify_p_view(sign_info_t* pptsi)
{
#ifdef __S_V_DEBUG__
	int i,j;
	unsigned char* pdata,buffer[64];
	sign_info_t* ptr = (sign_info_t*) pptsi;

	/*sign package struct*/
	sysLOG(SECURITY_LOG_LEVEL_5, "****sign info struct strart(0x%08x)****\r\n", ptr);
	sysLOG(SECURITY_LOG_LEVEL_5, "file addr ptr->f_addr:0x%08x\n", ptr->f_addr);
	sysLOG(SECURITY_LOG_LEVEL_5, "data sign ptr->d_sign_addr:0x%08x\n", ptr->d_sign_addr);
	sysLOG(SECURITY_LOG_LEVEL_5, "file sign ptr->f_sign_addr:0x%08x\n", ptr->f_sign_addr);
	sysLOG(SECURITY_LOG_LEVEL_5, "s_pack len ptr->tspf_len:0x%08x\n", ptr->tspf_len);
	sysLOG(SECURITY_LOG_LEVEL_5, "****sign package struct strart(ptr->tSpf=0x%08x)****\n", ptr->tSpf);
	sysLOG(SECURITY_LOG_LEVEL_5, "algorithm  :sign(ptr->tSpf.alg._t.as=0x%02x) hash(ptr->tSpf.alg._t.ah=0x%02x)\n", ptr->tSpf.alg._t.as, ptr->tSpf.alg._t.ah);
	sysLOG(SECURITY_LOG_LEVEL_5, "puk id ptr->tSpf.puk_id:");
	for(i=0;i<SPF_PUKID_SIZE;i++)
		sysLOG(SECURITY_LOG_LEVEL_5, "%02x ", ptr->tSpf.puk_id[i]);
	sysLOG(SECURITY_LOG_LEVEL_5, "\n");
	sysLOG(SECURITY_LOG_LEVEL_5, "****extra info****\n");
	sysLOG(SECURITY_LOG_LEVEL_5, "sign corp ptr->tSpf.ex_info._t.s_corp:%s\n", ptr->tSpf.ex_info._t.s_corp);
	sysLOG(SECURITY_LOG_LEVEL_5, "sign name ptr->tSpf.ex_info._t.s_id:%s\n", ptr->tSpf.ex_info._t.s_id);
	sysLOG(SECURITY_LOG_LEVEL_5, "sign time ptr->tSpf.ex_info._t.s_time:\n");
	for(i=0;i<SPF_TIME_SIZE;i++)
		sysLOG(SECURITY_LOG_LEVEL_5, "%02x ", ptr->tSpf.ex_info._t.s_time[i]);
	sysLOG(SECURITY_LOG_LEVEL_5, "\n");
	sysLOG(SECURITY_LOG_LEVEL_5, "****file info****\n");
	sysLOG(SECURITY_LOG_LEVEL_5, "file length:ptr->tSpf.f_info._t.f_len=0x%04x(%06d)\n", ptr->tSpf.f_info._t.f_len,ptr->tSpf.f_info._t.f_len);
	sysLOG(SECURITY_LOG_LEVEL_5, "data length:%04x(%06d)\n", ptr->tSpf.f_info._t.d_len,ptr->tSpf.f_info._t.d_len);
	sysLOG(SECURITY_LOG_LEVEL_5, "file format:ptr->tSpf.f_info._t.fmt=0x%02x\n", ptr->tSpf.f_info._t.fmt);
	sysLOG(SECURITY_LOG_LEVEL_5, "file type:ptr->tSpf.f_info._t.type=0x%02x\n\n", ptr->tSpf.f_info._t.type);
	sysLOG(SECURITY_LOG_LEVEL_5, "****sign length****\n");
	sysLOG(SECURITY_LOG_LEVEL_5, "file signlength:ptr->tSpf.f_sig_len=0x%04x(%06d)\n", ptr->tSpf.f_sig_len,ptr->tSpf.f_sig_len);
	sysLOG(SECURITY_LOG_LEVEL_5, "data signlength:ptr->tSpf.d_sig_len=0x%04x(%06d)\n", ptr->tSpf.d_sig_len,ptr->tSpf.d_sig_len);
	sysLOG(SECURITY_LOG_LEVEL_5, "****file sign****\n");
	pdata= (unsigned char*)ptr->f_sign_addr;
	
	for(i=0;i<ptr->tSpf.f_sig_len;i++)
		sysLOG(SECURITY_LOG_LEVEL_5, "%02x ", pdata[i]);
	sysLOG(SECURITY_LOG_LEVEL_5, "\n");

	sysLOG(SECURITY_LOG_LEVEL_5, "****data sign****\n");
	pdata= (unsigned char*)ptr->d_sign_addr;
	for(i=0;i<ptr->tSpf.d_sig_len;i++)
		sysLOG(SECURITY_LOG_LEVEL_5, "%02x ", pdata[i]);
	sysLOG(SECURITY_LOG_LEVEL_5, "****sign package struct end****\n");

	sysLOG(SECURITY_LOG_LEVEL_5, "****sign info struct end****\n");
#endif //#ifdef __S_V_DEBUG__
	return 0;
}


/*
*@Brief:		get file sign package,读取文件的签名部分内容
*@Param IN:		*img_addr:数据指针，img_len:数据长度;*ptsi:sign_info_t指针
*/
int signverify_get_p(unsigned char *img_addr,unsigned int img_len,sign_info_t *ptsi)
{
	int i;	
	unsigned int temp1;
	unsigned char* ptr;

	ptr =img_addr+img_len;
	temp1 = sizeof(sign_package_fmt_t) -SIGN_PACKAGE_FLAG_LEN;

	memcpy((uchar*)(&(ptsi->tSpf)),ptr-sizeof(sign_package_fmt_t),temp1);
	
	// endian hal_commConvert
	ptsi->tSpf.f_info._t.f_len = BigLittleSwap32(ptsi->tSpf.f_info._t.f_len);
	ptsi->tSpf.f_info._t.d_len = BigLittleSwap32(ptsi->tSpf.f_info._t.d_len);
	ptsi->tSpf.f_sig_len       = BigLittleSwap32(ptsi->tSpf.f_sig_len);
	ptsi->tSpf.d_sig_len       = BigLittleSwap32(ptsi->tSpf.d_sig_len);		

	return 0;
}

int signverify_check_algorithmOld(sign_info_t* ptsi)
{
	if( (ptsi->tSpf.alg._t.as == 0 ) 
		&&(ptsi->tSpf.alg._t.ah == 0 ) 
		)
		return SIGN_ERR_ALG;
	return 0;
}
int signverify_check_algorithm(sign_info_t* ptsi)
{
	if( (ptsi->tSpf.alg._t.as == 0x02 ) 
		&&(ptsi->tSpf.alg._t.ah == 0x03 ) 
		)
		return 0;
	return SIGN_ERR_ALG;
	
}
int signverify_check_fmt(sign_info_t* ptsi)
{
	if(ptsi->tSpf.f_info._t.fmt != SFILE_FMT_BIN )
		return SIGN_ERR_FILEFMT;
	if(ptsi->tSpf.f_info._t.type != SFILE_TYPE_FIRMWARE )
		return SIGN_ERR_FILETYPE;
	return 0;

	
}


void signverify_hash_view(int mode,uchar* hash)
{
#ifdef __S_V_DEBUG__

	int i,len;
	sysLOG(SECURITY_LOG_LEVEL_5, "****HASH DUMP STRART****\n");

	switch(mode)
	{
		case 0:
			sysLOG(SECURITY_LOG_LEVEL_5, "SHA-1 result \n");
			len =160/8;
			break;
		case 1:
			sysLOG(SECURITY_LOG_LEVEL_5, "SHA-224 result \n");
			len =224/8;
			break;
		case 2:
			sysLOG(SECURITY_LOG_LEVEL_5, "SHA2    result \n");
			len =256/8;
			break;
		case 3:
			sysLOG(SECURITY_LOG_LEVEL_5, "SHA-384 result \n");
			len =384/8;
			break;
		case 4:
			sysLOG(SECURITY_LOG_LEVEL_5, "SHA-512 result \n");
			len =512/8;
			break;
		default:
			sysLOG(SECURITY_LOG_LEVEL_5, "Mode Error \n");
			return ;
	}

//	for(i=0;i<len;i++)
//		sysLOG(SECURITY_LOG_LEVEL_5, "%02x ", hash[i]);
//	sysLOG(SECURITY_LOG_LEVEL_5, "\n");
	sysLOG(SECURITY_LOG_LEVEL_5, "****HASH DUMP END****\n");
	
#endif //#ifdef __S_V_DEBUG__

}
#define CRYPTO_BLOCK_LENGTH                 (1024)



int signverify_get_hash(uchar *data_addr, uint32_t data_len,uchar hash_mode,uchar* hash_out)
{
	unsigned char  buffer[64],*ptr;
	int Leftlength=0;
	int i=0;
	unsigned int TempCount = 0;
	//mbedtls_sha256_context ctxt;

	Leftlength = data_len % CRYPTO_BLOCK_LENGTH;
		
	hash_mode -= 1;

	ptr = data_addr;
	

	//mbedtls_sha256_starts(&ctxt);
	 saSha256(NULL, 0, NULL, HASH_MODE_INIT);

	TempCount = data_len / CRYPTO_BLOCK_LENGTH;
	if(TempCount > 0)
	{
		for(i = 0; i < TempCount; i++)
		{
			
			ptr = data_addr + CRYPTO_BLOCK_LENGTH * i;
			
			//mbedtls_sha256_update(&ctxt, ptr, CRYPTO_BLOCK_LENGTH);
			saSha256((uint8*)ptr, (uint16)CRYPTO_BLOCK_LENGTH, NULL, HASH_MODE_UPDATE);
		}
	}
	if(Leftlength > 0)
	{
		
		ptr = data_addr + CRYPTO_BLOCK_LENGTH * i;
		
		//mbedtls_sha256_update(&ctxt, ptr, Leftlength);
		saSha256((uint8*)ptr, (uint16)Leftlength, NULL, HASH_MODE_UPDATE);
	}

	//mbedtls_sha256_finish(&ctxt,hash_out);
	saSha256(NULL, SHA256_RESULT_LENGTH, hash_out, HASH_MODE_FINAL);

	return 0;

}


void signverify_recover_view(signkey_t* ptr)
{
#ifdef __S_V_DEBUG__

	int i;

	/*key struct*/
	sysLOG(SECURITY_LOG_LEVEL_5, "****sign key struct strart(%08x)****\n", ptr);
	sysLOG(SECURITY_LOG_LEVEL_5, "algorithm  :%02x%02x\n", ptr->tSkf.alg[0], ptr->tSkf.alg[1]);
	sysLOG(SECURITY_LOG_LEVEL_5, "issue corp :%s\n", ptr->tSkf.issue_corp);
	sysLOG(SECURITY_LOG_LEVEL_5, "issue name :%s\n", ptr->tSkf.issue_id);

	sysLOG(SECURITY_LOG_LEVEL_5, "init time  :");

//	for(i=0;i<SKF_TIME_SIZE;i++)
//		sysLOG(SECURITY_LOG_LEVEL_5, "%02x ",ptr->tSkf.init_time[i]);
//	sysLOG(SECURITY_LOG_LEVEL_5, "\n",ptr->tSkf.init_time[i]);
	sysLOG(SECURITY_LOG_LEVEL_5, "exp  time  :");
	for(i=0;i<SKF_TIME_SIZE;i++)
		sysLOG(SECURITY_LOG_LEVEL_5, "%02x ",ptr->tSkf.exp_time[i]);
	sysLOG(SECURITY_LOG_LEVEL_5, "\n");
	sysLOG(SECURITY_LOG_LEVEL_5, "issue corp :%s\n", ptr->tSkf.usr_corp);
	sysLOG(SECURITY_LOG_LEVEL_5, "issue name :%s\n", ptr->tSkf.usr_id);
	sysLOG(SECURITY_LOG_LEVEL_5, "sn         :\n");
//	for(i=0;i<SKF_SN_SIZE;i++)
//		sysLOG(SECURITY_LOG_LEVEL_5, "%02x ",ptr->tSkf.sn[i]);
//	sysLOG(SECURITY_LOG_LEVEL_5, "\n");
	sysLOG(SECURITY_LOG_LEVEL_5, "data length:%d\n", ptr->tSkf.keylen._us);
	sysLOG(SECURITY_LOG_LEVEL_5, "****key datastruct strart****\n");
	sysLOG(SECURITY_LOG_LEVEL_5, "RSA key length =%d\n", ptr->tPK.BitLen);
	sysLOG(SECURITY_LOG_LEVEL_5, "RSA key n(%08x):\n", ptr->tPK.n);
//	for(i=0;i<ptr->tPK.BitLen/8;i++)
//		sysLOG(SECURITY_LOG_LEVEL_5, "%02x ",*(ptr->tPK.n+i));
//	sysLOG(SECURITY_LOG_LEVEL_5, "\n\n");

	sysLOG(SECURITY_LOG_LEVEL_5, "RSA key e(%08x) \n", ptr->tPK.e);
//	for(i=0;i<4;i++)
//		sysLOG(SECURITY_LOG_LEVEL_5, "%02x ",ptr->tPK.e[i]);
//	sysLOG(SECURITY_LOG_LEVEL_5, "\n\n");
	sysLOG(SECURITY_LOG_LEVEL_5, "****key datastruct end****\n");

	sysLOG(SECURITY_LOG_LEVEL_5, "sign key struct cs(%08x) \n", ptr->cs);

//	for(i=0;i<8;i++)
//		sysLOG(SECURITY_LOG_LEVEL_5, "%02x ",ptr->cs[i]);
//	sysLOG(SECURITY_LOG_LEVEL_5, "\n");
	sysLOG(SECURITY_LOG_LEVEL_5, "****sign key struct end****\n");
#endif //#ifdef __S_V_DEBUG__
	
}

static unsigned char gucDesKey[16]={0x64, 0x30, 0x94, 0xA8, 0x49, 0x71, 0x0D, 0x56, 0xCD, 0xF7, 0x13, 0xDD, 0xFC, 0x61, 0x2E, 0x44};

const unsigned char gs_puk_data[562] = {//RootPUK
		0x00, 0x02, 0x56, 0x41, 0x4E, 0x53, 0x54, 0x4F, 0x4E, 0x45, 0x20, 0x45, 0x4C, 0x45, 0x43, 0x54, 
		0x52, 0x4F, 0x4E, 0x49, 0x43, 0x20, 0x28, 0x42, 0x45, 0x49, 0x4A, 0x49, 0x4E, 0x47, 0x29, 0x43, 
		0x4F, 0x2C, 0x2E, 0x20, 0x4C, 0x54, 0x44, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x44, 0x49, 0x4E, 0x47, 0x5A, 0x48, 0x41, 0x4F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x20, 0x15, 0x12, 0x11, 0x09, 0x32, 0x47, 0x05, 0x20, 0x18, 0x12, 0x11, 0x09, 0x32, 
		0x47, 0x05, 0x56, 0x41, 0x4E, 0x53, 0x54, 0x4F, 0x4E, 0x45, 0x20, 0x45, 0x4C, 0x45, 0x43, 0x54, 
		0x52, 0x4F, 0x4E, 0x49, 0x43, 0x20, 0x28, 0x42, 0x45, 0x49, 0x4A, 0x49, 0x4E, 0x47, 0x29, 0x43, 
		0x4F, 0x2C, 0x2E, 0x20, 0x4C, 0x54, 0x44, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x52, 0x26, 0x44, 0x2C, 0x42, 0x65, 0x69, 0x6A, 0x69, 0x6E, 0x67, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x20, 0x15, 0x12, 0x11, 0x09, 0x32, 0x47, 0x05, 
		0xB9, 0x2C, 0x01, 0x06, 0x00, 0x08, 0xD0, 0x1A, 0x4F, 0x92, 0x3A, 0x62, 0x9D, 0xC4, 0x52, 0x71, 
		0x93, 0x3E, 0xAE, 0x5D, 0x9A, 0x42, 0x7E, 0x48, 0xF1, 0x66, 0xEF, 0x3D, 0xFA, 0x7A, 0x67, 0xAE, 
		0x30, 0xE0, 0xF9, 0x9A, 0xC7, 0x28, 0xF8, 0x93, 0xFB, 0xF9, 0x69, 0x06, 0x6D, 0xC0, 0x5D, 0x91,
		0x8A, 0xEB, 0xE9, 0xA2, 0xE1, 0x09, 0x67, 0xED, 0xFB, 0x14, 0x2B, 0x71, 0x98, 0x84, 0xDF, 0xA8, 
		0x72, 0xBF, 0xBC, 0x41, 0x1D, 0x5C, 0x20, 0x51, 0xA2, 0xDC, 0x2E, 0xFA, 0xE1, 0xC9, 0xBB, 0xED, 
		0xB3, 0xB5, 0x29, 0xA2, 0x37, 0x2F, 0xB0, 0xA7, 0x38, 0x44, 0x51, 0x35, 0x00, 0xA6, 0xFC, 0xDD, 
		0x1D, 0x0F, 0x80, 0xE9, 0x7E, 0x9B, 0xA9, 0xA6, 0xA9, 0xC4, 0x9B, 0x50, 0xBE, 0x14, 0x64, 0xC7,
		0x86, 0xE6, 0x4C, 0x66, 0xF2, 0x2B, 0x77, 0x04, 0x64, 0x45, 0x1A, 0x98, 0xC4, 0xA3, 0x2E, 0x74,
		0xAE, 0x78, 0x6D, 0xAE, 0x20, 0xBF, 0xA6, 0x6B, 0xE5, 0x12, 0xF1, 0xAE, 0x68, 0x18, 0x48, 0xC2,
		0xA3, 0xC8, 0x76, 0xC5, 0xF3, 0x99, 0x41, 0x0B, 0x04, 0x25, 0xFC, 0x1C, 0xED, 0x46, 0x6E, 0xC3,
		0xDE, 0x1B, 0x7E, 0xA8, 0x4D, 0xF6, 0x40, 0xB8, 0x7C, 0xAB, 0xB8, 0x86, 0x2D, 0x0D, 0x98, 0x08,
		0xCE, 0x9C, 0xD4, 0xDD, 0xC6, 0x56, 0x26, 0x4F, 0xBE, 0x98, 0x80, 0x2A, 0xB8, 0xFB, 0xE1, 0x05,
		0xAE, 0x42, 0x61, 0x2C, 0x08, 0x44, 0x94, 0x65, 0xD8, 0xAC, 0x1B, 0xD2, 0xF3, 0xE6, 0xB1, 0xB5,
		0x42, 0x70, 0x07, 0x86, 0x13, 0xF1, 0x04, 0x9C, 0x9B, 0x68, 0x2F, 0xA4, 0xA4, 0xF0, 0xB1, 0xAA,
		0xFF, 0xF1, 0xD2, 0xFA, 0x57, 0xCF, 0xE1, 0xB1, 0x7C, 0x8B, 0xC3, 0x96, 0x3E, 0xD8, 0xB6, 0xD5,
		0x20, 0x82, 0x1F, 0x26, 0xEA, 0x4B, 0x43, 0x72, 0x01, 0x09, 0x8E, 0x4F, 0x8D, 0xA5, 0xF7, 0x55, 
		0x2F, 0xA3, 0xAE, 0xEB, 0xE9, 0x31, 0x00, 0x01, 0x00, 0x01, 0x2C, 0x68, 0xAE, 0xAD, 0x00, 0x00, 
		0x00, 0x00
};



/*
*@Brief:		3Des 加密运算
*@Param IN:		*input [输入] 输入数据 
				lenth [输入] 输入数据长度，8 字节倍数 
                *deskey [输入] 16/24 字节 DES 密钥
				*IV [输入] 初始化向量，ECB IV 为 NULL。 
				mode [输入] 0－ECB;1－CBC 				
*@Param OUT:	output [输出] 输出数据 
*@Return:		>0:成功,加密后的密文长度; <0:失败
*/
int calcTdesEnc(uint8_t *input,int lenth, uint8_t *output, uint8_t *deskey, uint32_t keyLen, uint8_t *IV, int mode)
{
    uint8_t  bKey[25] = {0};
    int iRet = -1;
	int lenthtmp = 0;
	char *rP = NULL;

	rP = malloc(lenth+16);
	if(rP == NULL)
	{
		return -3;
	}

	memset(rP, 0, lenth+16);

	*(rP+4) = (lenth & 0xFF000000)>>24;
	*(rP+5) = (lenth & 0x00FF0000)>>16;
	*(rP+6) = (lenth & 0x0000FF00)>>8;
	*(rP+7) = (lenth & 0x000000FF);

	memcpy(rP+8, input, lenth);
	
	if(lenth % 8 != 0)
    {
    	lenthtmp = lenth + 8 + 8 - (lenth%8);
    }
	else
	{
		lenthtmp = lenth + 8;
	}
	memset(bKey, 0, sizeof(bKey));
	if(keyLen == 24)
	{
	    memcpy(bKey, deskey, 24);
	}
	else if(keyLen == 16)
	{
	    memcpy(bKey, deskey, 16);
        memcpy(bKey+16, deskey, 8);
	}
	else
	{
	    iRet = -2;
		goto RET_END;
	}

    if(mode == 0)
    {
        if(Des3ECB(FALSE, bKey, rP, lenthtmp, output))
    	iRet = lenthtmp;
    }
    else if(mode == 1)
    {
	    if(IV == NULL)
	    {
	    	iRet = -3;
	    	goto RET_END;
	    }
        if(Des3CBC(FALSE, bKey, rP, lenthtmp, output, IV))
    	iRet = lenthtmp;
    }
	else
	{
    	iRet = -4;
		goto RET_END;
    }

RET_END:

	sysLOG(SECURITY_LOG_LEVEL_1, "iRet = %d\n", iRet);

	free(rP);
	return iRet;
}



/*
*@Brief:		3Des 解密运算
*@Param IN:		*input [输入] 输入数据 
				lenth [输入] 输入数据长度，8 字节倍数 
                *deskey [输入] 16/24 字节 DES 密钥
				*IV [输入] 初始化向量，ECB IV 为 NULL。 
				mode [输入] 0－ECB;1－CBC 				
*@Param OUT:	output [输出] 输出数据 
*@Return:		>0:成功,解密后的文件长度; <0:失败
*/
int calcTdesDec(uint8_t *input,int lenth, uint8_t *output, uint8_t *deskey, uint32_t keyLen, uint8_t *IV, int mode)
{
	uint8_t  bKey[25] = {0};
    int iRet = -1;
	int lenthtmp = 0;
	char *rP = NULL;

	rP = malloc(lenth+16);
	if(rP == NULL)
	{
		return -3;
	}

	memset(rP, 0, lenth+16);
	
	if(lenth % 8 != 0)
    {
    	iRet = -2;
    	goto RET_END;
    }
	memset(bKey, 0, sizeof(bKey));
	if(keyLen == 24)
	{
	    memcpy(bKey, deskey, 24);
	}
	else if(keyLen == 16)
	{
	    memcpy(bKey, deskey, 16);
        memcpy(bKey+16, deskey, 8);
	}
	else
	{
	    iRet = -2;
		goto RET_END;
	}
	
    if(mode == 0)
    {
        if(Des3ECB(TRUE, bKey, input, lenth, rP))
    	iRet = 0;
    }
    else if(mode == 1)
    {
	    if(IV == NULL)
	    {
	    	iRet = -3;
	    	goto RET_END;
	    }
        if(Des3CBC(TRUE, bKey, input, lenth, rP, IV))
    	iRet = 0;
    }
	else
	{
    	iRet = -4;
		goto RET_END;
    }

	lenthtmp += (*(rP+4))<< 24;
	lenthtmp += (*(rP+5))<< 16;
	lenthtmp += (*(rP+6))<< 8;
	lenthtmp += (*(rP+7));

	sysLOG(SECURITY_LOG_LEVEL_2, "lenthtmp = %d\n", lenthtmp);

	memcpy(output, rP+8, lenthtmp);
	iRet = lenthtmp;

RET_END:

	sysLOG(SECURITY_LOG_LEVEL_1, "iRet = %d\n", iRet);
	
	free(rP);
	return iRet;
}



int signverify_recover(uchar *data_addr, uint32_t data_len,uchar sign_mode,
					uchar* data_out,unsigned int* data_out_len)
{
	
	signkey_t  tSignkey;
	//unsigned short	key_len;
	unsigned short* plen;
	unsigned char* ptr;
	unsigned char buffer[512];
	//unsigned int dataout_len;
	int i,rv;
	R_RSA_PUBLIC_KEY rsa_pk;
	
	//RSA_PUBLIC_KEY tRSAPK;
	

	/*Get sign public key struct*/

	memcpy((unsigned char *)&tSignkey.tSkf,gs_puk_data,sizeof(signkey_fmt_t));
	tSignkey.tSkf.keylen._us = BigLittleSwap16(tSignkey.tSkf.keylen._us );

	plen = (unsigned short*)(((unsigned int)gs_puk_data+sizeof(signkey_fmt_t)));
	tSignkey.tPK.BitLen = *plen;
	tSignkey.tPK.n = (uchar*)(((unsigned int)gs_puk_data+sizeof(signkey_fmt_t)) + 2);
	tSignkey.tPK.e = (uchar*)((unsigned int)tSignkey.tPK.n +  tSignkey.tPK.BitLen/8);
	tSignkey.cs    = (uchar*)( (unsigned int)tSignkey.tPK.e + 4 );

	signverify_recover_view(&tSignkey);
	
	ptr = data_addr;

	switch(sign_mode)
	{
		case 0x01://1024bits
		case 0x02:
		rsa_pk.bits=tSignkey.tPK.BitLen;
		memcpy(rsa_pk.modulus ,tSignkey.tPK.n,rsa_pk.bits/8);
		memcpy(rsa_pk.exponent,tSignkey.tPK.e,4);			
		rv= RSAPublicDecrypt(data_out,         /* output block */
	                        data_out_len,       /* length of output block */
	                         ptr,          		/* input block */
	                        data_len,         /* length of input block */
	                         &rsa_pk);   /* RSA public key */			
			break;
		default: return SIGN_ERR_ASYMTYPE;
	}
	
	return rv;
}
int signverify_recover_expuk(uchar *data_addr, 
                                uint32_t data_len,
                                uchar sign_mode,
                                uchar* data_out,
                                unsigned int* data_out_len,
                                R_RSA_PUBLIC_KEY* ptrsapk)
{    
    unsigned char* ptr;
    unsigned char buffer[512];
    int i,rv;

    /*Get sign public key struct*/
	
	ptr = data_addr;
	

    switch(sign_mode)
    {
        case 0x01://1024bits
        case 0x02:
        rv= RSAPublicDecrypt(data_out,         /* output block */
                             data_out_len,       /* length of output block */
                             ptr,               /* input block */
                             data_len,         /* length of input block */
                             ptrsapk);   /* RSA public key */           
            break;
        default: return SIGN_ERR_ASYMTYPE;
    }
    
    return rv;
}

void signverify_result_view(uchar* data, int data_len,sign_package_fmt_t* psft)
{
#ifdef __S_V_DEBUG__

	int i=0;
	int ihash[]={0,160,224,256,384,512};
	int isign[]={0,1024,2048,3072,4096};
	int temp;

	sysLOG(SECURITY_LOG_LEVEL_5, "****sign verify start****\n");
	sysLOG(SECURITY_LOG_LEVEL_5, "signature format is {I | H1| R1|0xDC}\n");
	temp = offsetof(sign_package_fmt_t, f_sig_len);
	sysLOG(SECURITY_LOG_LEVEL_5, "length of I : (%02x)%0d\n", temp, temp);
	sysLOG(SECURITY_LOG_LEVEL_5, "length of H1: (%d)%0d in bits\n", ihash[psft->alg._t.ah]/8,ihash[psft->alg._t.ah]);
	sysLOG(SECURITY_LOG_LEVEL_5, "length of S1: (%d)%0d in bits\n", isign[psft->alg._t.as]/8,isign[psft->alg._t.as]);
	temp = isign[psft->alg._t.as]/8-temp-ihash[psft->alg._t.ah]/8;

	sysLOG(SECURITY_LOG_LEVEL_5, "length of R1 : (%02x)%0d\n", temp, temp);
	
//	for(i=0;i<data_len;i++)
//	{
//		sysLOG(SECURITY_LOG_LEVEL_5, " %02X", data[i]);
//	}
//	sysLOG(SECURITY_LOG_LEVEL_5, "\n");
	sysLOG(SECURITY_LOG_LEVEL_5, "****signverify_result_view end****\n");
#endif //#ifdef __S_V_DEBUG__

}

void signverify_em_view(uchar* EM, unsigned int Emlen)
{
#ifdef __S_V_DEBUG__

	int i;
	sysLOG(SECURITY_LOG_LEVEL_5, "****EM start****\n");
	sysLOG(SECURITY_LOG_LEVEL_5, "length of EM : (%02x)%0d\n", Emlen, Emlen);

//	for(i=0;i<Emlen;i++)
//	{
//		sysLOG(SECURITY_LOG_LEVEL_5, " %02X", EM[i]);
//	}
//	sysLOG(SECURITY_LOG_LEVEL_5, "\n");
	sysLOG(SECURITY_LOG_LEVEL_5, "****EM_view end****\n");
#endif //#ifdef __S_V_DEBUG__

}

int signverify_get_result(uchar* EM,uchar* EMCalc,unsigned int emLen)
{
	int rv;
	rv = memcmp(EM,EMCalc,emLen);
	if( rv){
		return SIGN_ERR_I;
	}
	
	return 0;
}



int signverify_check_size(unsigned long size)
{
#define CPU_FALSH_BASE 0x00000000 //
#define CPU_FLASH_SIZE 0x00080000 //512kb
	
#define CPU_SRAM_BASE  0x20000000 //
#define CPU_SRAM_SIZE  0X00018000 //96Kb

	

	return 0;
	
	return SIGN_ERR_BADADDR;
	
}

//int SignVerify_GetRawSize(uchar *img_addr,BIN_INFO* pbi, int isSpiFlash)
//{
//	 int len=0;
//	
//	memcpy((uchar*)pbi, (uchar*)img_addr, sizeof(BIN_INFO));
//
//	len = pbi->uiBinEnd - pbi->uiBinStart;
//	return len;
//}

/*
*@Brief:		读取签名部分数据长度
*@Param IN：		*img_addr:数据指针，raw_size:被签名数据的长度
*@Return:		签名部分数据长度
*/
int signverify_sp_size(uchar *img_addr,int raw_size)
{

	int sp_len;
	
	memcpy((uchar*)&sp_len , (uchar*)(img_addr+raw_size), sizeof(unsigned int));
	
	return (BigLittleSwap32(sp_len));
}

int sGetAppPukId(unsigned char * img_addr, 
						unsigned int raw_size, 
						unsigned char* id)
{
	int iRet;
    sign_info_t spt;
    unsigned int data_len,img_size;
    int rv;
    //获取签名信息的长度
    iRet = signverify_sp_size(img_addr,raw_size);
	if(iRet <= 0)return -2;
	spt.tspf_len = iRet;
	
	img_size = spt.tspf_len +raw_size;
	
  	/*1)	查看文件是否含有E标志，如果存在则存在签名数据，
  	如果不存在，则不存在签名数据。
  	整个源文件为原始文件，不存在签名所附加的任何信息。
  	如果存在签名，假定得到的文件格式为F | SD | SF | I | Lsf | Lsd | E*/
	rv = signverify_check_size(img_size);
	if(rv) return rv;

	rv = signverify_get_e(img_addr,img_size);
  	if(rv) return rv;
	signverify_get_p(img_addr,img_size,&spt);
	spt.f_addr = (unsigned int )img_addr;

	if(spt.tSpf.d_sig_len)
		spt.d_sign_addr = spt.f_addr + raw_size +4;
	else 
		spt.d_sign_addr = 0;//not availbe 
		
	if(spt.tSpf.f_sig_len)
		spt.f_sign_addr = spt.f_addr + raw_size +4 + spt.tSpf.d_sig_len;
	else 
		spt.f_sign_addr = 0;//not availbe 

	if ((spt.tSpf.f_sig_len != RSA_LEN) || (spt.tSpf.f_info._t.f_len != raw_size))
	{
		return -1;
	}

	if (spt.tSpf.f_info._t.d_len)
	{
		if (spt.tSpf.d_sig_len != RSA_LEN)
		{
			return -1;
		}
		if (spt.tspf_len != (sizeof(sign_package_fmt_t) + 4 + RSA_LEN * 2))
		{
			return -1;
		}
	}
	else
	{
		if (spt.tSpf.d_sig_len != 0)
		{
			return -1;
		}
		if (spt.tspf_len != (sizeof(sign_package_fmt_t) + 4 + RSA_LEN))
		{
			return -1;
		}
	}
	if(id)
		memcpy(id,spt.tSpf.puk_id,SPF_PUKID_SIZE);

    return 0;

}
int sGetSignFileType(unsigned char * img_addr, unsigned int raw_size,  unsigned char* psFileType)
{
	int iRet;
    sign_info_t spt;
    unsigned int data_len,img_size;
    int rv;
    //获取签名信息的长度
    iRet = signverify_sp_size(img_addr,raw_size);
	if(iRet <= 0 || iRet > 1024)
	{
		sysLOG(SECURITY_LOG_LEVEL_1, "iRet=%d\n", iRet);
		return -2;
	}
	spt.tspf_len = iRet;
	img_size = spt.tspf_len +raw_size;
	sysLOG(SECURITY_LOG_LEVEL_1, "img_size=%d\n", img_size);
	
  	/*1)	查看文件是否含有E标志，如果存在则存在签名数据，
  	如果不存在，则不存在签名数据。
  	整个源文件为原始文件，不存在签名所附加的任何信息。
  	如果存在签名，假定得到的文件格式为F | SD | SF | I | Lsf | Lsd | E*/
	rv = signverify_check_size(img_size);
	if(rv) return rv;

	rv = signverify_get_e(img_addr,img_size);
  	if(rv) return rv;
	signverify_get_p(img_addr,img_size,&spt);
	spt.f_addr = (unsigned int )img_addr;

	if(spt.tSpf.d_sig_len)
		spt.d_sign_addr = spt.f_addr + raw_size +4;
	else 
		spt.d_sign_addr = 0;//not availbe 
		
	if(spt.tSpf.f_sig_len)
		spt.f_sign_addr = spt.f_addr + raw_size +4 + spt.tSpf.d_sig_len;
	else 
		spt.f_sign_addr = 0;//not availbe 

	if ((spt.tSpf.f_sig_len != RSA_LEN) || (spt.tSpf.f_info._t.f_len != raw_size))
	{
		return -1;
	}

	if (spt.tSpf.f_info._t.d_len)
	{
		if (spt.tSpf.d_sig_len != RSA_LEN)
		{
			return -1;
		}
		if (spt.tspf_len != (sizeof(sign_package_fmt_t) + 4 + RSA_LEN * 2))
		{
			return -1;
		}
	}
	else
	{
		if (spt.tSpf.d_sig_len != 0)
		{
			return -1;
		}
		if (spt.tspf_len != (sizeof(sign_package_fmt_t) + 4 + RSA_LEN))
		{
			return -1;
		}
	}

    if(spt.tSpf.f_info._t.type < 6)
    {
        *psFileType = spt.tSpf.f_info._t.type;
		sysLOG(SECURITY_LOG_LEVEL_1, "spt.tSpf.f_info._t.type=%d\n", spt.tSpf.f_info._t.type);
    }

    return 0;

}
/**
 * [Function]       
 * [Description]    读取外部puk
 * [param]          puk_addr: 存储起始地址
 * [param]          pskt: 缓存
 * [return]         0-成功; <0-失败
 * [modify]         [author]  [version]  2017-11-29       
 */
int ReadPukEx(unsigned char *puk_filenameaddr,uint8_t *dataout,uint32_t MAX_lenth)
{
	int iRet = -1; 

	char *rP = NULL;

	rP = malloc(MAX_lenth+16);
	if(rP == NULL)
	{
		return -3;
	}
	memset(rP, 0, MAX_lenth+16);
	
	
	iRet = hal_fileReadPro(puk_filenameaddr, 0, rP, MAX_lenth+16);
	if(iRet > 0)
	{
		iRet = calcTdesDec(rP, iRet, dataout, gucDesKey, 16, NULL, 0);
		if(iRet < 0)goto exit;
		iRet = 0;
	}
	else
	{
		iRet = -2;
		goto exit;
	}

exit:
	free(rP);
    return iRet;

}

int sLoadPublickey( unsigned int filetype, char *id, signkey_t *pskt)
{
    int rv,len;
    unsigned short* plen;
    uint32_t crc32_jam;
    unsigned char app_puk[1024];
    //signkey_t pskt;
    unsigned char filename_addr[128];
    unsigned int pukFlen;
	int iRet = -1;
	

	memset(filename_addr, 0, sizeof(filename_addr));
    switch(filetype)
    {

        case SFILE_TYPE_FW_PUK://get root puk
        case SFILE_TYPE_APP_MVPUK:
            memcpy(app_puk,gs_puk_data,sizeof(gs_puk_data));
        break;
             
        case SFILE_TYPE_FIRMWARE://app use L2 puk
            //1.get_puk_address
            memcpy(filename_addr, VOS_PUK_FILENAME, strlen(VOS_PUK_FILENAME));
            rv = ReadPukEx(filename_addr,app_puk,sizeof(app_puk));//若有则用存储的 若无则用默认的 
            if(rv != 0)
            {
                memcpy(app_puk,gs_puk_data,sizeof(gs_puk_data));
            }
        break;
            
        case SFILE_TYPE_APP_PUK:
			memcpy(filename_addr, L1_PUK_FILENAME, strlen(L1_PUK_FILENAME));
            rv = ReadPukEx(filename_addr,app_puk,sizeof(app_puk));//若有则用存储的 若无则用默认的 
            if(rv != 0)
            {
                memcpy(app_puk,gs_puk_data,sizeof(gs_puk_data));
            }
        break;        
            
        case SFILE_TYPE_APP:
            //1.get_puk_address
            memcpy(filename_addr, APP_PUK_FILENAME, strlen(APP_PUK_FILENAME));
            rv = ReadPukEx(filename_addr,app_puk,sizeof(app_puk));//若有则用存储的 若无则用默认的 
            if(rv != 0)
            {
                memcpy(app_puk,gs_puk_data,sizeof(gs_puk_data));
            }
        break;
        default:
            iRet = -1;
			goto exit;
        break;

    }

    memcpy((unsigned char *)(&(pskt->tSkf)),(unsigned char*)app_puk,sizeof(signkey_fmt_t));
	pskt->tSkf.keylen._us = BigLittleSwap16(pskt->tSkf.keylen._us );

	plen = (unsigned short*)(((unsigned int)app_puk+sizeof(signkey_fmt_t)));
	pskt->tPK.BitLen = *plen;
	if(pskt->tPK.n)
		memcpy(pskt->tPK.n,
		(uchar*)((unsigned int)app_puk+sizeof(signkey_fmt_t) + 2),
		pskt->tPK.BitLen/8);
	if(pskt->tPK.e)
		memcpy(pskt->tPK.e,
		(uchar*)((unsigned int)app_puk+sizeof(signkey_fmt_t) + 2 +  *plen/8),
		4);
	if(pskt->cs)
		memcpy(pskt->cs,
		(uchar*)((unsigned int)app_puk+sizeof(signkey_fmt_t)+ 2 +  *plen/8 +4),
		8);
        iRet = 0;
		goto exit;
    

exit:

	return iRet;
}                  
int sVerifySignature(unsigned char * img_addr, 
						unsigned int raw_size, 
						R_RSA_PUBLIC_KEY* ptrsapk)
{
	int iRet;
    int rv = 0;
    sign_info_t spt;
    uchar hash[64],data[256];
    unsigned int data_len,img_size;
    uchar EmOut[256];

	iRet = signverify_sp_size(img_addr,raw_size);//读取签名部分数据长度
	if(iRet <= 0)return -2;
    spt.tspf_len = iRet;
    img_size = spt.tspf_len +raw_size;
	sysLOG(SECURITY_LOG_LEVEL_1, "img_size=%d,spt.tspf_len=%d,raw_size=%d\n", img_size, spt.tspf_len, raw_size);

    rv = signverify_check_size(img_size);
    if(rv) return rv;

    rv = signverify_get_e(img_addr,img_size);//判断尾部16字节是否为“SIGNED.VERSION01”
    if(rv) return rv;
    signverify_get_p(img_addr,img_size,&spt);
    spt.f_addr = (unsigned int )img_addr;

    if(spt.tSpf.d_sig_len)
        spt.d_sign_addr = spt.f_addr + raw_size +4;
    else 
        spt.d_sign_addr = 0;//not availbe 
        
    if(spt.tSpf.f_sig_len)
        spt.f_sign_addr = spt.f_addr + raw_size +4 + spt.tSpf.d_sig_len;
    else 
        spt.f_sign_addr = 0;//not availbe 

        

    signverify_p_view(&spt);
    rv =signverify_check_algorithm(&spt);
    if(rv)  return rv;

    if(spt.f_sign_addr){

        rv = signverify_recover_expuk((uchar*)spt.f_sign_addr ,
            spt.tSpf.f_sig_len,
            spt.tSpf.alg._t.as,
            data,&data_len,
            ptrsapk);
        if(rv) return rv; 
        
		signverify_result_view(data,data_len,&spt.tSpf);
		if(rv) return rv; 
		rv = signverify_encode(&spt,EmOut,1);
		if(rv) return rv; 
		rv = signverify_get_result(EmOut,data,g_em_len[spt.tSpf.alg._t.as]);  //
		if(rv) return rv; 

    }
    


    if(spt.d_sign_addr){
        
    	rv = signverify_recover_expuk((uchar*)spt.d_sign_addr,
        	spt.tSpf.f_info._t.d_len,
       		spt.tSpf.alg._t.as,
        	data,&data_len,ptrsapk);

		if(rv) return rv; 
		rv = signverify_encode(&spt,EmOut,0);
		if(rv) return rv; 
		rv = signverify_get_result(EmOut,data,g_em_len[spt.tSpf.alg._t.as]);
		if(rv) return rv; 
      
    }

    return 0;

}

int EMSA_PKCS1_v1_5_ENCODE (
	unsigned char* hash,
	int hash_type,
	unsigned int emLen,unsigned char* EM)
{
	int ps_len,t_len,alg_len;
	unsigned char* ops = EM;
	unsigned char* AlgorithmIdentifier;
	
	if(EM==NULL) return SIGN_ERR_ENCODE;
	if(hash==NULL) return SIGN_ERR_ENCODE;

	/*check hash type,and get t_len*/
	switch(hash_type)
	{
		case 0x01: 
			alg_len =ALGID_LEN_SHA1;
			t_len = T_LEN_SHA1;
			AlgorithmIdentifier = (unsigned char*)DigestInfo_DER_SHA1;
			break;
		case 0x03: 
			alg_len =ALGID_LEN_SHA256;
			t_len = T_LEN_SHA256;
			AlgorithmIdentifier = (unsigned char*)DigestInfo_DER_SHA256;
			break;
		case 0x04: 
			alg_len =ALGID_LEN_SHA384;
			t_len = T_LEN_SHA384;
			AlgorithmIdentifier = (unsigned char*)DigestInfo_DER_SHA384;
			break;
		case 0x05: 
			alg_len =ALGID_LEN_SHA512;
			t_len = T_LEN_SHA512;
			AlgorithmIdentifier = (unsigned char*)DigestInfo_DER_SHA512;
			break;
		default: 
			return SIGN_ERR_ENCODE;
	}
	/*如果 emLen < tLen + 11，则输出“期望的编码消息长度太短”然后中止运算。*/
	if(emLen < (t_len+11))
		return SIGN_ERR_ENCODE;
	ps_len = emLen-t_len-3;
	/*EM = 0x00 || 0x01 || PS || 0x00 || T*/
	*ops++=0x00;
	*ops++=0x01;
	memset(ops,0xFF,ps_len);
	ops+=ps_len;
	*ops++ = 0x00;
	memcpy(ops, AlgorithmIdentifier, alg_len); 
	ops+=alg_len;
	memcpy(ops, hash, t_len-alg_len);  

	return 0;

}
int signverify_encode(sign_info_t* ptsi,unsigned char* emout, int bfile)
{
	int rv;
	int i,hash_type;
	unsigned char* addr;
	unsigned char hash[64];
	uint32_t len;

	i = ptsi->tSpf.alg._t.as;
	
	hash_type = ptsi->tSpf.alg._t.ah;
	addr = (unsigned char*)ptsi->f_addr;
	if(bfile) 	{
		len = ptsi->tSpf.f_info._t.f_len;
	}
	else{
		len = ptsi->tSpf.f_info._t.d_len;
	}
	rv = signverify_get_hash(addr,
		len,
		hash_type,
		hash);
		if(rv) return rv; 
		
	rv = EMSA_PKCS1_v1_5_ENCODE (hash, hash_type,g_em_len[i],emout);

	signverify_em_view(emout,g_em_len[i]);
	return rv;
}

uint32_t ImageCalcSize_kflash(dl_info_t *p)
{
	uint32_t ptr, size = 0;
	for(ptr = p->addr_end; ptr >= p->addr_start; ptr--)
	{
		if(*(uchar*)ptr != 0xff)
		{
			size = ptr - p->addr_start + 1;
			break;
		}
	}

	if(size == 0)
		return 0;

	
//	ImageWriteSize(p, size);
	
	return size;
}

int ImageCalcSize(dl_info_t *image)
{
	uint32_t size = 0;

	size = ImageCalcSize_kflash(image);

	//dprintf("Image %08x size: %lu(0x%08x)\n", image->addr_header, size, size);

	if(size > (image->addr_end - image->addr_start))
	{
		//dprintf("  Oversize");
		return -1;
	}
	if(size == 0)
	{
		//dprintf("  No image");
		return -1;
	}
	return size;
	
}

/*
*@Brief:		读取被签名部分APP大小
*/
uint32 readAppimgLen(char *img_addr)
{
	uint32 iRet = 0;

	iRet |= (*(img_addr+BININFO_HEAD_SIZE+BININFO_FORMAT_SIZE))<<24;
	iRet |= (*(img_addr+BININFO_HEAD_SIZE+BININFO_FORMAT_SIZE+1))<<16;
	iRet |= (*(img_addr+BININFO_HEAD_SIZE+BININFO_FORMAT_SIZE+2))<<8;
	iRet |= (*(img_addr+BININFO_HEAD_SIZE+BININFO_FORMAT_SIZE+3));

	iRet += 1024;
	return iRet;
}


int sysAppSignVerify(uchar *img_addr)
{
    int rv;
    uint8_t puk_id[SPF_PUKID_SIZE];
    signkey_t skt;
    R_RSA_PUBLIC_KEY trsapk;
    unsigned char cs[8];
    int iMonRawLen;
//    BIN_INFO monitor_info;
    
    //1.提取info中的相关信息
    /*校验备份区数据*/
    iMonRawLen = readAppimgLen(img_addr);
//    if((iMonRawLen<0)||(iMonRawLen>EXT_FLASH_APP_SIZE))
//    {
//        api_sCLcdPrint(0, 2, 2, "文件过大!!", "file too large!!");
//        rv = -1;
//        goto err_finish;
//    }
    //2.获取pukID
//	rv = sGetAppPukId(addr ,iMonRawLen,puk_id, 1);
//	if(rv ) 
//      goto err_finish;
//	
//	TRACE("*puk_id :%02x%02x%02x%02x\n",puk_id[0],puk_id[1],puk_id[2],puk_id[3],puk_id[4],puk_id[5],puk_id[6],puk_id[7]);

    memset((uint8_t*)&trsapk,0,sizeof(trsapk));
    memset(cs,0,sizeof(cs));
    skt.tPK.n = trsapk.modulus;
    skt.tPK.e = trsapk.exponent;
    skt.cs    = cs;
        
	//取出公钥即可									
	rv = sLoadPublickey(SFILE_TYPE_APP,puk_id, &skt);
	sysLOG(SECURITY_LOG_LEVEL_1, "sLoadPublickey return %d\n", rv);
	if(rv) 
        goto err_finish;
    trsapk.bits = skt.tPK.BitLen;
    
	rv = sVerifySignature((unsigned char*)img_addr,iMonRawLen,&trsapk);
	sysLOG(SECURITY_LOG_LEVEL_1, "iVerifySignature return %d\n", rv);
	if(rv) goto err_finish;

	/*rv = sCheckSignInfo((unsigned char*)addr,iRawLen, SFILE_FMT_BIN,SFILE_TYPE_APP,0);
	TRACE("*sCheckSignInfo return %d\n",rv);
	if(rv ) goto err_finish;*/	

err_finish:
    return rv;

}

uint32_t sysReadSignFileLenth(uint8_t *addr)
{
    signkey_fmt_t  tSkf;
    uint32_t iMonRawLen;
    memcpy((uint8_t *)&tSkf,addr,sizeof(tSkf));
    iMonRawLen = sizeof(signkey_fmt_t) + BigLittleSwap16(tSkf.keylen._us ) + 8;//PUK+SIGN_INFO+CRC32

    return iMonRawLen;
}
/**
 * [Function]       sysL2PukVerify
 * [Description]    校验被签名的公钥。
 * [param]     [in]: iMonRawLen : 待验签文件长度
 *                   addr : 数据存储地址
 * [return]         
 *                   
 * [modify]         []  [version]  
 */

int sysL2PukVerify(uint8_t *addr, uint32_t *pPukLenth, uint8_t *psFileType)
{
    
    uint8_t puk_id[SPF_PUKID_SIZE];
    uint8_t cs[8];
    uint32_t iMonRawLen;//被签名数据的长度
    signkey_t skt;
    R_RSA_PUBLIC_KEY trsapk;
    
    int rv;
    
    iMonRawLen = sysReadSignFileLenth(addr);
    *pPukLenth = iMonRawLen;
	sysLOG(SECURITY_LOG_LEVEL_1, "iMonRawLen=%d\n", iMonRawLen);
    //1.判断导入文件的长度
//    if(iMonRawLen>EXT_FLASH_APP_SIZE)
//    {
//        api_sCLcdPrint(0, 2, 2, "文件过大!!", "file too large!!");
//        rv = -1;
//        goto err_finish;
//    }
    //2.获取pukType
	rv = sGetSignFileType(addr ,iMonRawLen,psFileType);
	if(rv ) 
        goto err_finish;
	

    skt.tPK.n = trsapk.modulus;
    skt.tPK.e = trsapk.exponent;
    skt.cs    = cs;
        
	//取出公钥即可									
	rv = sLoadPublickey(*psFileType,puk_id, &skt);
	sysLOG(SECURITY_LOG_LEVEL_1, "sLoadPublickey return %d\n", rv);
	if(rv ) 
        goto err_finish;
    trsapk.bits = skt.tPK.BitLen;

	//验证签名
	rv = sVerifySignature((unsigned char*)addr,iMonRawLen,&trsapk);
	sysLOG(SECURITY_LOG_LEVEL_1, "sVerifySignature return %d, iMonRawLen=%d\n", rv, iMonRawLen);
	if(rv ) goto err_finish;

	/*rv = sCheckSignInfo((unsigned char*)addr,iRawLen, SFILE_FMT_BIN,SFILE_TYPE_APP,0);
	TRACE("*sCheckSignInfo return %d\n",rv);
	if(rv ) goto err_finish;*/	

err_finish:
    return rv;

}

int sysL2PukWrite(uint8_t fileType, uint8_t *pukData, uint32_t PukLenth)
{
    uint8_t buf[4096];
    uint8_t *pb = buf;
    uint8_t pukHeader[5];
    int iRet;
	int lenthtmp = 0;
	char *rP = NULL;

	rP = malloc(PukLenth+16);
	if(rP == NULL)
	{
		return -3;
	}
	memset(rP, 0, PukLenth+16);
	iRet = calcTdesEnc(pukData, PukLenth, rP, gucDesKey, 16, NULL, 0);
	if(iRet < 0)goto exit;
	lenthtmp = iRet;

    switch(fileType)
    {
        case SFILE_TYPE_FW_PUK:
			iRet = hal_fileExist(VOS_PUK_FILENAME);
			if(iRet == 1)hal_fileRemove(VOS_PUK_FILENAME);
			iRet = hal_fileWritePro(VOS_PUK_FILENAME, 0, rP, lenthtmp);
        break;
        case SFILE_TYPE_APP_MVPUK:
			iRet = hal_fileExist(L1_PUK_FILENAME);
			if(iRet == 1)hal_fileRemove(L1_PUK_FILENAME);
			iRet = hal_fileWritePro(L1_PUK_FILENAME, 0, rP, lenthtmp);
        break;        
        case SFILE_TYPE_APP_PUK:
			iRet = hal_fileExist(APP_PUK_FILENAME);
			if(iRet == 1)hal_fileRemove(APP_PUK_FILENAME);
			iRet = hal_fileWritePro(APP_PUK_FILENAME, 0, rP, lenthtmp);
        break;

        default :
            iRet = -1;
			goto exit;
        break;        
    }

    
    if(iRet < 0) 
	{
		iRet = -2;
		goto exit;
    }

    iRet = 0;

exit:

	free(rP);
	return iRet;
	
    
}


/*
*@Brief:		写公钥到文件系统中
*@Param IN:		*filename:存放要写入公钥的临时文件
*@Return:		0-succ; <0-failed
*/
int WritePuk(char *filename)
{
	int iRet = -1;
	int filesizetmp = 0;
	uint8_t pukType = 0;
   	uint32_t pukLen;
	char *rP = NULL;

	filesizetmp = hal_fileGetFileSize(filename);
	if(filesizetmp <= 0)return -1;
	
	rP = malloc(filesizetmp);
	if(rP == NULL)
	{
		return -2;
	}

	memset(rP, 0, filesizetmp);
	iRet = hal_fileReadPro(filename, 0, rP, filesizetmp);
	if(iRet < 0)
	{
		goto exit;
	}
	
	iRet = sysL2PukVerify(rP,&pukLen,&pukType);            
    if(iRet == 0)
    {
        iRet = sysL2PukWrite(pukType,rP,pukLen);
       
    }

exit:

	free(rP);
	return iRet;

}

/************************TEST************************/

#if MAINTEST_FLAG


const uint8_t L1_PUK_Rootsign[1010] = {
	0x00, 0x02, 0x56, 0x41, 0x4E, 0x53, 0x54, 0x4F, 0x4E, 0x45, 0x20, 0x45, 0x4C, 0x45, 0x43, 0x54, 
	0x52, 0x4F, 0x4E, 0x49, 0x43, 0x20, 0x28, 0x42, 0x45, 0x49, 0x4A, 0x49, 0x4E, 0x47, 0x29, 0x43, 
	0x4F, 0x2C, 0x2E, 0x20, 0x4C, 0x54, 0x44, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x52, 0x26, 0x44, 0x2E, 0x62, 0x65, 0x69, 0x6A, 0x69, 0x6E, 0x67, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x20, 0x21, 0x12, 0x03, 0x10, 0x52, 0x19, 0x05, 0x20, 0x24, 0x12, 0x03, 0x10, 0x52, 
	0x19, 0x05, 0x42, 0x68, 0x61, 0x72, 0x61, 0x74, 0x50, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x4E, 0x55, 0x4C, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x20, 0x21, 0x12, 0x03, 0x10, 0x52, 0x19, 0x05, 
	0x4D, 0x94, 0x01, 0x06, 0x00, 0x08, 0xBF, 0x62, 0x84, 0x40, 0x20, 0x97, 0xBC, 0xA1, 0x4E, 0x6F, 
	0x16, 0x9B, 0xB9, 0x9B, 0x6E, 0x29, 0x0D, 0x0F, 0x85, 0xED, 0x0E, 0x6E, 0xBC, 0xE7, 0x29, 0x06, 
	0xED, 0x2E, 0x82, 0xB6, 0xB5, 0x67, 0x4A, 0x5A, 0x3B, 0x4F, 0x1B, 0xD3, 0xB3, 0x4B, 0x0D, 0x74, 
	0x93, 0xDE, 0xC6, 0xDA, 0x30, 0xDF, 0x54, 0xBC, 0x18, 0x74, 0xAF, 0x7D, 0xC7, 0x91, 0xF5, 0x7A, 
	0x0B, 0x75, 0xFC, 0x6E, 0xA7, 0xFC, 0xDA, 0xE1, 0x5D, 0xEA, 0xA4, 0x89, 0xF1, 0xD9, 0x84, 0x60, 
	0xFA, 0xD0, 0x91, 0xEE, 0xF7, 0xE1, 0x4F, 0x93, 0xA7, 0x18, 0x50, 0x77, 0x8B, 0x43, 0x65, 0xBB, 
	0x8B, 0xF8, 0xF2, 0xE5, 0x6E, 0x08, 0xEB, 0x87, 0xF3, 0xB4, 0x2B, 0x25, 0x4E, 0x12, 0x74, 0xF6, 
	0x70, 0xB0, 0x4D, 0x80, 0x57, 0x59, 0xC3, 0x74, 0x7B, 0x3A, 0xD3, 0xAD, 0xB6, 0x81, 0x0B, 0x69, 
	0xF6, 0x6D, 0x01, 0x20, 0x0F, 0xF9, 0xB8, 0x89, 0xBD, 0xDA, 0x8D, 0x6A, 0xAC, 0x80, 0x2E, 0x47, 
	0xF0, 0x29, 0xD4, 0x7F, 0xF9, 0x6B, 0x2F, 0xFF, 0xCE, 0xC5, 0x86, 0x38, 0xD0, 0x34, 0x79, 0xBC, 
	0xFD, 0xE4, 0x0F, 0x1B, 0x3D, 0x64, 0x9A, 0x56, 0x1A, 0xF2, 0x0C, 0xEF, 0x59, 0x64, 0x24, 0x15, 
	0xE5, 0xEC, 0xB2, 0xB9, 0xD0, 0x06, 0x6B, 0x9B, 0x18, 0x78, 0x23, 0x9D, 0x0D, 0x77, 0x6A, 0x05, 
	0xD5, 0xE5, 0xAF, 0x77, 0x7B, 0x96, 0x22, 0x1C, 0xE1, 0x54, 0xE2, 0xBE, 0xA4, 0x12, 0xDD, 0xA1, 
	0x1B, 0x62, 0xD1, 0x3E, 0x5D, 0xA5, 0x08, 0x27, 0xE7, 0xF1, 0xDF, 0x05, 0x2B, 0x72, 0x91, 0xD6, 
	0x3D, 0xC9, 0xBE, 0xBE, 0x47, 0x0C, 0xD2, 0xFC, 0xF8, 0x97, 0x23, 0xCC, 0xFA, 0x9C, 0x09, 0x4B, 
	0x8C, 0x5E, 0xE9, 0xC8, 0x47, 0x10, 0x3D, 0x70, 0x70, 0x21, 0xE5, 0xD5, 0xF9, 0xB2, 0xFB, 0xA0, 
	0xF6, 0x42, 0xFF, 0xAF, 0xEA, 0xD1, 0x00, 0x01, 0x00, 0x01, 0x0B, 0x2B, 0x35, 0xB7, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x6D, 0x82, 0xF8, 0x4D, 0xA1, 0x16, 0x63, 0xC3, 0xAF, 0x6C, 
	0xC0, 0xB6, 0xDE, 0x3E, 0xD6, 0xA8, 0x66, 0x7A, 0x82, 0x5B, 0xDF, 0xF9, 0xF5, 0xAE, 0xF1, 0xEC, 
	0xED, 0x71, 0x26, 0xC8, 0x17, 0xDC, 0x23, 0x1F, 0xC6, 0x45, 0xA7, 0xD5, 0xE4, 0x5C, 0x52, 0xE7, 
	0x38, 0x3C, 0x0C, 0x58, 0x02, 0xB4, 0x93, 0x02, 0x2D, 0x70, 0xC9, 0x87, 0x59, 0x92, 0x17, 0x53, 
	0xBC, 0x86, 0x01, 0x0D, 0x6A, 0x83, 0x3E, 0xE5, 0x5B, 0x84, 0x15, 0xFB, 0xC4, 0xCD, 0x62, 0xA3, 
	0xF2, 0x6C, 0x54, 0x8C, 0x76, 0x42, 0x66, 0x96, 0xFE, 0xBA, 0x07, 0x12, 0x19, 0xD3, 0x1A, 0x17, 
	0xDA, 0x34, 0x9F, 0xA6, 0x65, 0xF4, 0xFF, 0xF0, 0x41, 0x50, 0x88, 0x14, 0xB8, 0x8A, 0xF5, 0x7E, 
	0x3B, 0xB4, 0x7B, 0xFE, 0xF3, 0x49, 0xD3, 0x4F, 0xAF, 0xA6, 0x28, 0xCC, 0x1A, 0x45, 0x08, 0x55, 
	0xC1, 0x01, 0x4E, 0xF9, 0x2B, 0x05, 0x82, 0x03, 0x13, 0xCC, 0xA4, 0x65, 0x6A, 0xAD, 0xDE, 0x74, 
	0x27, 0x98, 0x67, 0x9C, 0xB3, 0xD3, 0x90, 0x3E, 0xFF, 0xB0, 0xBD, 0x94, 0xC7, 0x48, 0x07, 0xF9, 
	0x37, 0x42, 0xC1, 0x70, 0x81, 0x75, 0x6D, 0xC3, 0x92, 0xBC, 0x8E, 0x07, 0x80, 0x0E, 0x99, 0xE7, 
	0x5B, 0xF8, 0x2F, 0xB1, 0x2A, 0xA7, 0x4A, 0x76, 0x0E, 0x52, 0xC1, 0x32, 0x59, 0x45, 0xD6, 0x01, 
	0x2E, 0x6E, 0xC2, 0x49, 0xF4, 0xCE, 0xEF, 0x4E, 0x89, 0x69, 0xF6, 0x2F, 0x23, 0x82, 0x7E, 0x00, 
	0x0F, 0x9D, 0x13, 0x06, 0x4A, 0xED, 0x35, 0xB8, 0x09, 0x8E, 0x9B, 0xB3, 0xFB, 0xEB, 0x5C, 0xE6, 
	0xEB, 0xD3, 0xC2, 0xDF, 0x74, 0x04, 0x14, 0x00, 0xF4, 0x25, 0xC7, 0x0A, 0xBE, 0xAA, 0x9B, 0x30, 
	0xCD, 0xE6, 0xBA, 0x81, 0x2E, 0xAD, 0xDB, 0x8D, 0x11, 0xC7, 0x59, 0xDA, 0x37, 0x43, 0xE2, 0xAD, 
	0x6C, 0xD2, 0x27, 0x4B, 0x1F, 0xAD, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x20, 0x21, 
	0x12, 0x01, 0x15, 0x51, 0x25, 0x03, 0xC8, 0xD3, 0x42, 0x68, 0x61, 0x72, 0x61, 0x74, 0x50, 0x65, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E, 0x55, 0x4C, 0x4C, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x12, 0x07, 0x13, 0x56, 0x16, 0x02, 
	0x00, 0x00, 0x02, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x53, 0x49, 0x47, 0x4E, 0x45, 0x44, 0x2E, 0x56, 0x45, 0x52, 0x53, 0x49, 0x4F, 0x4E, 
	0x30, 0x31
};

const unsigned char APP_PUK_L1sign[1010] = {
	0x00, 0x02, 0x56, 0x41, 0x4E, 0x53, 0x54, 0x4F, 0x4E, 0x45, 0x20, 0x45, 0x4C, 0x45, 0x43, 0x54, 
	0x52, 0x4F, 0x4E, 0x49, 0x43, 0x20, 0x28, 0x42, 0x45, 0x49, 0x4A, 0x49, 0x4E, 0x47, 0x29, 0x43, 
	0x4F, 0x2C, 0x2E, 0x20, 0x4C, 0x54, 0x44, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x52, 0x26, 0x44, 0x2E, 0x62, 0x65, 0x69, 0x6A, 0x69, 0x6E, 0x67, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x20, 0x21, 0x12, 0x01, 0x15, 0x51, 0x25, 0x03, 0x20, 0x24, 0x12, 0x01, 0x15, 0x51, 
	0x25, 0x03, 0x42, 0x68, 0x61, 0x72, 0x61, 0x74, 0x50, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x4E, 0x55, 0x4C, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x20, 0x21, 0x12, 0x01, 0x15, 0x51, 0x25, 0x03, 
	0xC8, 0xD3, 0x01, 0x06, 0x00, 0x08, 0xBE, 0xE2, 0x74, 0xC1, 0x87, 0x60, 0x00, 0xC8, 0x83, 0x4B, 
	0x77, 0x9F, 0xE6, 0x31, 0xA4, 0x6F, 0x6D, 0x04, 0xBF, 0xB7, 0xA7, 0x6B, 0x22, 0x22, 0xA9, 0xB0, 
	0xD4, 0x2B, 0xB6, 0x23, 0x90, 0x39, 0x50, 0x07, 0xFE, 0x89, 0xF9, 0x84, 0xA7, 0x52, 0x0E, 0xBB, 
	0x14, 0x1C, 0xE9, 0x4B, 0x7C, 0xD8, 0x3A, 0x3A, 0xEF, 0x5B, 0x21, 0x1D, 0xB0, 0x1B, 0x27, 0x10, 
	0x34, 0x68, 0x80, 0x5E, 0x8E, 0x72, 0x2A, 0xA3, 0xC2, 0x02, 0xB2, 0x4A, 0xB4, 0x72, 0xAB, 0x62, 
	0xC6, 0xE7, 0x3B, 0xD4, 0x74, 0xF2, 0x05, 0x93, 0x22, 0xF0, 0x28, 0x40, 0x24, 0x0D, 0x91, 0xC8, 
	0x0C, 0x49, 0x28, 0xA3, 0xC0, 0x2E, 0xD2, 0xDF, 0xDA, 0x8C, 0xEF, 0x01, 0x49, 0x6C, 0x0F, 0xA8, 
	0xD4, 0x97, 0xFB, 0x6A, 0x93, 0x30, 0x87, 0xD5, 0x07, 0x01, 0x7F, 0x1C, 0x5C, 0x0F, 0x76, 0xFF, 
	0x74, 0x61, 0x56, 0x04, 0xBF, 0xEF, 0xDF, 0xCF, 0x41, 0xE4, 0xCC, 0x98, 0xE6, 0xCB, 0xC7, 0x7B, 
	0x4D, 0x05, 0x76, 0x89, 0xDD, 0x7E, 0x77, 0xB5, 0x0E, 0x97, 0xD7, 0xD2, 0x23, 0x98, 0x92, 0x2D, 
	0xB4, 0xFC, 0x3F, 0xED, 0x89, 0x85, 0xAE, 0x5F, 0xF0, 0xDC, 0xD0, 0xBC, 0x81, 0xA5, 0x76, 0xD3, 
	0x20, 0xF4, 0x2A, 0xF3, 0x56, 0x3F, 0x91, 0x75, 0xB0, 0x7F, 0x07, 0x62, 0x98, 0xD3, 0x9F, 0x85, 
	0x45, 0x68, 0xC1, 0xE1, 0xC8, 0xB2, 0xEC, 0x9F, 0xFC, 0x36, 0xC2, 0xB8, 0x48, 0x4D, 0x5A, 0x84, 
	0xC2, 0x50, 0xA3, 0x05, 0xCE, 0xDC, 0xC2, 0x6F, 0x94, 0xFE, 0x36, 0xE8, 0xAC, 0xCD, 0x8C, 0x22, 
	0x28, 0x4C, 0x56, 0x24, 0x8D, 0xB5, 0x27, 0x3B, 0xEB, 0x71, 0x57, 0x76, 0x8E, 0xAB, 0x98, 0xFA, 
	0x25, 0xAD, 0x32, 0xB0, 0x3E, 0x44, 0xFE, 0x22, 0xD2, 0x0A, 0xC0, 0xC8, 0xAF, 0xAC, 0xA6, 0x66, 
	0xB1, 0x5C, 0x45, 0x8F, 0x7E, 0xC9, 0x00, 0x01, 0x00, 0x01, 0x74, 0x37, 0x7B, 0x7E, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x31, 0x08, 0x16, 0x5F, 0x2E, 0x49, 0xFD, 0x48, 0x3C, 0x02, 
	0x79, 0x70, 0x5B, 0xD8, 0xDC, 0x20, 0x4B, 0x8E, 0x0A, 0xFC, 0x90, 0x13, 0x76, 0xA3, 0xDA, 0x3B, 
	0x80, 0x84, 0x22, 0x66, 0x2E, 0xF4, 0xD6, 0x47, 0xD8, 0x6B, 0x1D, 0x1D, 0xBE, 0x69, 0x77, 0x7B, 
	0x08, 0xF1, 0x64, 0x82, 0xAE, 0xD9, 0x47, 0x4C, 0x88, 0xD2, 0xB6, 0x13, 0xF4, 0x77, 0x6A, 0xCB, 
	0x41, 0xA8, 0xCD, 0x8F, 0x4E, 0x82, 0x16, 0xBB, 0x1C, 0xE4, 0x7D, 0x2E, 0x04, 0x28, 0x35, 0x1E, 
	0xC3, 0xEB, 0xB0, 0xCB, 0x28, 0xAB, 0x07, 0xAA, 0xEE, 0xD0, 0xB2, 0x9F, 0x2B, 0x82, 0x99, 0x32, 
	0x8C, 0x3B, 0x4F, 0xDA, 0x2C, 0x5B, 0x4E, 0x0C, 0x41, 0x4C, 0xE5, 0x94, 0xAB, 0x1B, 0x8B, 0x0C, 
	0x31, 0x02, 0x62, 0x9D, 0x99, 0xE6, 0x96, 0x64, 0x88, 0xEA, 0x52, 0x75, 0x97, 0xBE, 0x31, 0xD8, 
	0xD8, 0x30, 0x39, 0x50, 0x7D, 0x45, 0x35, 0xB5, 0xF8, 0xAB, 0x40, 0x8E, 0xB5, 0xD6, 0xB4, 0xF8, 
	0x06, 0x8E, 0xAB, 0xCF, 0x3C, 0x5E, 0xAF, 0x43, 0x41, 0xB1, 0xE0, 0xE2, 0x73, 0x0A, 0xD6, 0x46, 
	0xBF, 0x64, 0x25, 0x2F, 0x85, 0x65, 0x81, 0x9A, 0x4C, 0x1C, 0xBB, 0x3F, 0xC7, 0x84, 0xBC, 0x56, 
	0x09, 0x5C, 0x55, 0xD2, 0x63, 0xD2, 0x36, 0xD7, 0x9E, 0xBF, 0xD2, 0xEA, 0x40, 0x76, 0xA2, 0x94, 
	0xC1, 0x6B, 0x55, 0x20, 0x38, 0x19, 0xBE, 0x2E, 0x81, 0xB2, 0x56, 0x06, 0x94, 0x55, 0xCB, 0xE0, 
	0x59, 0xF8, 0xC3, 0x8E, 0x64, 0x55, 0x8A, 0x99, 0x30, 0x61, 0x68, 0xDB, 0x6A, 0x13, 0xE5, 0x7E, 
	0xDA, 0x59, 0x4B, 0x76, 0xED, 0xA3, 0x89, 0xCB, 0x28, 0x32, 0x55, 0xA3, 0xF7, 0x74, 0x4E, 0xDE, 
	0x20, 0xE9, 0xB3, 0xCD, 0x7E, 0x7B, 0x31, 0x12, 0xD2, 0xD6, 0x8F, 0x01, 0x2E, 0xF3, 0xE2, 0x58, 
	0x69, 0xF2, 0xF9, 0x84, 0xF0, 0x08, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x20, 0x21, 
	0x12, 0x03, 0x10, 0x52, 0x19, 0x05, 0x4D, 0x94, 0x42, 0x68, 0x61, 0x72, 0x61, 0x74, 0x50, 0x65, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E, 0x55, 0x4C, 0x4C, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x12, 0x07, 0x13, 0x58, 0x06, 0x02, 
	0x00, 0x00, 0x02, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x53, 0x49, 0x47, 0x4E, 0x45, 0x44, 0x2E, 0x56, 0x45, 0x52, 0x53, 0x49, 0x4F, 0x4E, 
	0x30, 0x31
};

void test_puk_loading(void)
{
  
   uint8_t pukType = 0;
   uint32_t pukLen;
   int iRet;
   

    iRet = sysL2PukVerify(L1_PUK_Rootsign,&pukLen,&pukType);            
    if(iRet == 0)
    {//write puk to flash
        iRet = sysL2PukWrite(pukType,L1_PUK_Rootsign,pukLen);
        
    }

	iRet = sysL2PukVerify(APP_PUK_L1sign,&pukLen,&pukType);            
    if(iRet == 0)
    {//write puk to flash
        iRet = sysL2PukWrite(pukType,APP_PUK_L1sign,pukLen);
        
    }

    
}

#endif

